<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础：泛型</title>
      <link href="/2018/11/24/Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%B3%9B%E5%9E%8B/"/>
      <url>/2018/11/24/Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        泛型的主要目的之一就是来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性，基本类型无法作为类型参数。</p><h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h3><h5 id="2-1-元组概念"><a href="#2-1-元组概念" class="headerlink" title="2.1 元组概念"></a>2.1 元组概念</h5><p>​        将一组对象打包直接存储在其中一个单一对象中。</p><pre><code>//可被继承 进行扩展public class TwoTuple&lt;A, B&gt;{    public final A first;    public final B second;    public TwoTuple(A a, B b){       first = a;       second = b;   }}public class ThreeTuple&lt;A, B, C&gt; extends TwoTuple&lt;A, B&gt;{    public final C three;    public ThreeTuple(A a, B b, C c){       super(a, b)       three = c;   }    }//元组测试  存放多个返回对象public class Tupletest{    public static TwoTuple&lt;String, Integer&gt; f(){       return new TwoTuple&lt;String, Integer&gt;("hello", 1024);       }}</code></pre><h5 id="2-2-泛型接口"><a href="#2-2-泛型接口" class="headerlink" title="2.2 泛型接口"></a>2.2 泛型接口</h5><pre><code>pulic interface Gernerator&lt;T&gt;{    T next();}public class Coffee implements Generator&lt;String&gt;{    @Override    public String next(){   }}参数化的接口确保next（）的返回值是参数的类型。</code></pre><h5 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h5><p>​        泛型方法使得方法独立于类而产生变化。</p><pre><code>public class GeneratorMethods{    public &lt;T&gt; void f(T x){       sout(x.getClass().getName());   }}</code></pre><p>​        使用泛型类时必须指明参数类型，而泛型方法不必指出， 编译器会进行类型参数推断。 类型参数判断若传入是基本类型，系统会自行进行打包处理。</p><p>​        类型判断只对赋值操作有效，若将泛型方法调用的结果作为参数进行传递，编译器不会类型推断。因为编译器认为：泛型方法调用后，其返回值被赋给了Object类型的变量。</p><pre><code>static void f(Map&lt;People, List&lt;? extends Pet&gt;&gt; petPeople){}f(New.map());</code></pre><p>​        显示进行说明 可以解决上述问题，即泛型显示说明</p><pre><code>f(Map&lt;People, List&lt;Pet&gt; petPeople&gt;){}f(New.&lt;Person.List&lt;Pet&gt;&gt;map());</code></pre><p>​        静态方法</p><pre><code>public static &lt;T&gt; T getSelf(T a){   return a;}</code></pre><h5 id="2-4-泛型的限制"><a href="#2-4-泛型的限制" class="headerlink" title="2.4 泛型的限制"></a>2.4 泛型的限制</h5><ul><li>不能实例化类型变量</li></ul><pre><code>T objg = new T(); ERROR//可以利用反射进行public class GenerateObj&lt;T&gt;(){    private T obj;    public GenerateObj(Class&lt;T&gt; c){       try{       obj = c.newInstance();       }catch(Exception e){           e.printStackTrance();       }   }}test:GenerateObj&lt;String&gt; obj = new GenerateObj&lt;&gt;(String.class);</code></pre><ul><li>不能实例化泛型数据</li></ul><pre><code>T[] arr = new T[3]; ERROR//A.可以先创建Object类型的数组，然后获取时转换为T类型的数组。public class GenerateArray{    private Object[] arr;    public GenerateArray(int n){       this.arr = new object[n];   }    public void set(int i, T o){       arr[i] = o;   }    public T get(int i){       return (T)this,arr[i];   }}//B.利用反射机制public generateArray(Class&lt;T&gt; type, int n){    arr = (T[])Array.newInstance(type, n);}</code></pre><ul><li>不能在<strong>泛型类</strong>的静态上下文使用类型变量</li></ul><pre><code>public class Foo&lt;T&gt;{    private static T t;   public static T get(){     //error       return T;   }}</code></pre><ul><li>不能抛出或者捕获泛型类的实例</li></ul><pre><code>public class Problem&lt;T&gt; extends Exception{  //error}//扩展Throwable也是不合法的public class Foo {    public static &lt;T extends Throwable&gt; void doWork(){       try{       }catch(T t){   //error       }   }}//但在异常规范中使用泛型变量是允许的public class Foo{    public static &lt;T extends Throwable&gt; void doWork(T t) throws T{       try{       }catch(Throwable realCause){           throw t;       }   }}</code></pre><h5 id="2-5-类型变量的规定"><a href="#2-5-类型变量的规定" class="headerlink" title="2.5 类型变量的规定"></a>2.5 类型变量的规定</h5><p>​        <strong>java类库中，常用E表示集合的元素类型，K和V分别表示关键字和值的类型，T（U, S）表示任意类型。</strong></p><ul><li><p>被定义的泛型类作为接收方，也需要对传入的类型变量T的值做一定的限制和约束，如必须是某个超类的子类，或实现某个接口</p></li><li><p>对于实现接口，和继承某个父类。统一使用extends。</p></li><li><p>限定类型之间使用“&amp;”进行分割。</p></li><li><p>如果有类有接口，类名放于前，且至多有一个，接口不限</p><pre><code>public class Foo&lt;T extends SuperClass&amp;Comparable&gt;{}</code></pre></li></ul><h5 id="2-6-泛型的继承关系"><a href="#2-6-泛型的继承关系" class="headerlink" title="2.6 泛型的继承关系"></a>2.6 泛型的继承关系</h5><ul><li>类名相同，但类型变量T不同的两个泛型类没有什么联系（即使Employee 是Manager的父类）。（ArrayList<manager> 和 ArrayList<employee>）</employee></manager></li><li>类型变量T相同，同是本来就是父子关系的两个类，作为泛型类依然保持继承关系。（ArrayList<employee> 和 List<employee>）</employee></employee></li><li>某个类的原始类型，和其对应的泛型类可以看做由“继承关系” (ArrayList 和ArrayList<employee>)</employee></li></ul><h5 id="2-7-统配符的使用"><a href="#2-7-统配符的使用" class="headerlink" title="2.7 统配符的使用"></a>2.7 统配符的使用</h5><ul><li><p>向上造型一个泛型对象的引用（上界通配符）</p><pre><code>List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();List&lt;? extends Fruits&gt; fruits = apples;</code></pre><p>​        <strong>上界通配符，List&lt;? extends Fruits&gt; 是 List<fruits>和List<apple>的基类,一个能放水果以及一切都是水果派生类的盘子。</apple></fruits></strong></p></li><li><p><strong>下界通配符，Plate&lt;? super Fruit&gt; 是 Plate<fruit>的基类，但不是Plate<apple>的基类。一个能放水果以及一切是水果基类的盘子。Food 是 Fruits的基类。</apple></fruit></strong></p><pre><code>List&lt;? super Fruits&gt; list = new List&lt;Fruit&gt;(new Fruit());</code></pre><p><strong><em>副作用：</em></strong></p><ul><li>上界不能存，只能外取。即&lt;? extends Fruits&gt; 会让set方法失效，但get方法还是有效的。</li><li>原因：编译器只知道容器内是Frutis或者它的子类，但不知道具体的类型，所以标上一个占位符，具体类不清楚，插入时，容器类不清楚是否与之匹配，所以就不允许。  并且读出来的东西，只能以父类进行接收。</li><li>T 代表同一类型，而? 代表不同类型。</li><li>下界不影响存，但只能以object进行接收。</li></ul></li></ul><h5 id="2-8-PECS-原则"><a href="#2-8-PECS-原则" class="headerlink" title="2.8 PECS 原则"></a>2.8 PECS 原则</h5><ul><li><p>频繁往外读取内容的，适合上界Extends。</p></li><li><p>经常往里插入的，适合用下界Super。</p></li><li><p>材料：</p><ul><li>Java是单继承，所有继承的类构成一棵树。假设A和B都在一颗继承树里（否则super，extend这些词没意义）。</li><li>A super B 表示A是B的父类或者祖先，在B的上面。</li><li>A extend B 表示A是B的子类或者子孙，在B下面。</li><li>由于树这个结构上下是不对称的，所以这两种表达区别很大。假设有两个泛型写在了函数定义里，作为函数形参（形参和实参有区别）：<ul><li>参数写成：T&lt;? super B&gt;，对于这个泛型，?代表容器里的元素类型，由于只规定了元素必须是B的超类，导致元素没有明确统一的“根”（除了Object这个必然的根），所以这个泛型你其实无法使用它，对吧，除了把元素强制转成Object。所以，对把参数写成这样形态的函数，你函数体内，只能对这个泛型做<strong>插入操作，而无法读</strong>。</li><li>参数写成： T&lt;? extends B&gt;，由于指定了B为所有元素的“根”，你任何时候都可以安全的用B来使用容器里的元素，但是插入有问题，由于供奉B为祖先的子树有很多，不同子树并不兼容，由于实参可能来自于任何一颗子树，所以你的插入很可能破坏函数实参，所以，对这种写法的形参，<strong>禁止做插入操作，只做读取</strong>。</li></ul></li></ul></li></ul><h5 id="2-9-泛型的命名规范"><a href="#2-9-泛型的命名规范" class="headerlink" title="2.9  泛型的命名规范"></a>2.9  泛型的命名规范</h5><ul><li><strong>E</strong>  :Element 常用在 java collection中，如List<e>,Iterator<e>.</e></e></li><li><strong>K, V</strong>: Key Value 代表Map的键值对</li><li><strong>N</strong>: number 数字</li><li><strong>T</strong> : type 类型</li><li><strong>S, U, V</strong> 和 <strong>T</strong>的用法一样</li></ul><h3 id="3-关于泛型的几点建议（Effective-Java）"><a href="#3-关于泛型的几点建议（Effective-Java）" class="headerlink" title="3.关于泛型的几点建议（Effective Java）"></a>3.关于泛型的几点建议（Effective Java）</h3><ul><li><p>第 23 条：请不要在新代码中使用原生类型</p><ul><li><p>如果使用原生类型，就失去了泛型在安全性和标书性方面的优势，所以尽可能的使用泛型参数，少使用原生类型。List 和List<object>  的区别在于前者逃避了泛型检查，后者则告知了编译器。如果使用List就会失去类型的安全性。所以能使用List<object> 就不使用List,并且List<string> 是 List的子类，但不是List<object>的子类。</object></string></object></object></p></li><li><p>在不确定或者不关心实际的参数的时候，就可以用一个问号代替</p></li><li><p>不要在代码中使用泛型的两个例外</p><ul><li>在类文字中必须使用原生态类型，规范不允许使用参数，List.class, String[].class  都是合法的，List&lt;String.class&gt;和 List&lt;?&gt;.class则不合法。</li><li>泛型信息在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用instance操作符是非法的。用无限制通配符类型替换原生类型，对instanceof操作符的行为不会产生任何影响</li></ul><pre><code>if&lt;o instanceof Set&gt;{    Set&lt;?&gt; m = (Set&lt;?&gt;) o;}</code></pre></li></ul></li><li><p>第 24 条：消除非受检警告</p><ul><li>消除非受检警告，要尽可能的消除每一个非受检警告,每一个警告都有可能抛出ClassCastException异常，使用该注解，最好写上原因。</li><li>SuppressWarnings注解放在return语句是非法的，应该新建一个局部变量进行保存返回值</li></ul><pre><code>@SuppressWarnings("uncheck")T[] result = (T[])Arrays.copeOf(elements, size, a.getClass());</code></pre></li><li><p>第 25 条：列表优先于数组</p><ul><li>数组与泛型相比，是协变的，具体化的。 sub是super的子类型，则sub[] 就是super[]的子类型，但是泛型却是不行的。数组的错误会在运行时才抛出异常，而列表则会进行编译检查。</li><li>泛型在编译时强化它们的类型信息，在运行时丢弃或擦出元素类型信息。擦除就是使用泛型可以与没有使用泛型的代码随意互用</li><li>创建泛型、参数化类型或者类型参数的数组都是非法的。 非法的原因在于它不是类型安全的。</li></ul><pre><code>new List&lt;E&gt;[]  new List&lt;String&gt;[] 和 new E[]举例说明非法的原因：创建一个使用参数化类型List的数组List&lt;String&gt;[] stringlist = new List&lt;String&gt;[1];创建一个使用参数化类型的列表List&lt;Integer&gt; intList = new ArrayList[];由于数组是协变的，所以下面的是成立的。Object[] objects = stringList因而，就可以objects[0] = stringList;但是下面的取值方式，看似是合理的，但是由于存入的是一个Integer参数画的List，所以会将Integer转换成String，这时就会抛出异常String s = stringList[0].get(0);</code></pre></li><li><p>第26条：优先考虑使用泛型</p></li></ul><pre><code>当在使用泛型类型时，进行转换的时候，//标量类型private Object[] elements;E result = (E)elements[size];//数组类型private E[] elements;elements = (E[]) new Object[12];两种方式都可以，但当使用SuppressWarnings注解时禁止数组类型的未受检转换比禁止标量类型的更加危险(2比1更加危险)。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础：Java8特性</title>
      <link href="/2018/11/18/Java%E5%9F%BA%E7%A1%80%EF%BC%9Ajava8%E7%89%B9%E6%80%A7/"/>
      <url>/2018/11/18/Java%E5%9F%BA%E7%A1%80%EF%BC%9Ajava8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Default-Method-for-Interfaces（接口的default方法）"><a href="#1-Default-Method-for-Interfaces（接口的default方法）" class="headerlink" title="1. Default Method for Interfaces（接口的default方法）"></a>1. Default Method for Interfaces（接口的default方法）</h4><pre><code>public interface Formula {    double calcute(int a);    default double sqrt(int a){        return Math.sqrt(a);    }    public static void main(String[] args) {        Formula formula = new Formula() {            @Override            public double calcute(int a) {                return sqrt(a * 100);            }        };        System.out.println(formula.calcute(100));        System.out.println(formula.sqrt(16));    }}</code></pre><h4 id="2-Lambda-expression-集合排序"><a href="#2-Lambda-expression-集合排序" class="headerlink" title="2.Lambda expression(集合排序)"></a>2.Lambda expression(集合排序)</h4><pre><code>public static void main(String[] args) {        List&lt;Integer&gt; numList = new ArrayList&lt;&gt;();        numList.add(1);        numList.add(3);        numList.add(2);        // #1        Collections.sort(numList, (Integer a, Integer b) -&gt;{            return b.compareTo(a);        });        // #2        Collections.sort(numList, (Integer a, Integer b) -&gt; b.compareTo(a));        // #3        numList.sort((a,  b) -&gt; b.compareTo(a));        System.out.println(numList.toString());    }</code></pre><h4 id="3-Functional-Intefaces-功能性接口的快速实现"><a href="#3-Functional-Intefaces-功能性接口的快速实现" class="headerlink" title="3.Functional Intefaces(功能性接口的快速实现)"></a>3.Functional Intefaces(功能性接口的快速实现)</h4><pre><code>public static void main(String[] args) {        // #1        Converter&lt;String, Integer&gt; convert = (from -&gt; Integer.valueOf(from));        // #2        Converter&lt;String, Integer&gt; convert = Integer::valueof;        // #3        Converter&lt;String, String&gt; convert = Something::startWith;        Integer converted = convert.convert("123");        System.out.println(converted);    }    @FunctionalInterface    interface Converter&lt;F, T&gt;{        T convert(F from);    }    class Something{        String startWith(String s){            return String.valueOf(s.charAt(0));        }    }    //构造函数的使用    class Person{        String name;        public Person(){}        public Person(String name){            this.name = name;        }    }    interface PersonFactory&lt;T extends Person&gt;{        T create(String name);    }    PersonFactory factory = Person::new;    Person person = factory.create("Peter");</code></pre><h4 id="4-Lambda-Scopes-使用范围"><a href="#4-Lambda-Scopes-使用范围" class="headerlink" title="4. Lambda Scopes(使用范围)"></a>4. Lambda Scopes(使用范围)</h4><h6 id="4-1-Accessing-local-variables-接受本地变量"><a href="#4-1-Accessing-local-variables-接受本地变量" class="headerlink" title="4.1 Accessing local variables(接受本地变量)"></a>4.1 Accessing local variables(接受本地变量)</h6><pre><code>final int num = 1Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2);</code></pre><h6 id="4-2-Accessing-fields-and-static-variables-属性和静态属性"><a href="#4-2-Accessing-fields-and-static-variables-属性和静态属性" class="headerlink" title="4.2 Accessing fields and static variables(属性和静态属性)"></a>4.2 Accessing fields and static variables(属性和静态属性)</h6><pre><code>class Lambda4{    static int outerStaticNum;    int outerNum;    void testScopes(){        java8Study.Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; {            outerNum = 23;            return String.valueOf(from);        };        java8Study.Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {            outerStaticNum = 70;            return String.valueOf(from);        };    }}</code></pre><h4 id="5-Built-in-Functional-Interfaces-内置功能接口"><a href="#5-Built-in-Functional-Interfaces-内置功能接口" class="headerlink" title="5. Built-in Functional Interfaces(内置功能接口)"></a>5. Built-in Functional Interfaces(内置功能接口)</h4><h6 id="5-1-Predicates-用于判断boolean值的接口"><a href="#5-1-Predicates-用于判断boolean值的接口" class="headerlink" title="5.1 Predicates(用于判断boolean值的接口)"></a>5.1 Predicates(用于判断boolean值的接口)</h6><pre><code>  Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;        Predicate&lt;Object&gt; nonNull = Objects::nonNull;        Predicate&lt;Object&gt; isNull = Objects ::isNull;        Predicate&lt;String&gt; isEmpty = String::isEmpty;        Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();        boolean t1 =  predicate.test("job");        boolean t2 = predicate.negate().test("job");        String a = null;        boolean t3 = nonNull.test(a);        boolean t4 = isNull.test(a);        System.out.println(t1+" "+t2+" "+t3+" "+t4);        true false false true</code></pre><p><img src="/2018/11/18/Java基础：java8特性/../../document/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/blog/image/1569555883604.png" alt="1569555883604"></p><h6 id="5-2-Functions-接受一个参数，返回一个结果"><a href="#5-2-Functions-接受一个参数，返回一个结果" class="headerlink" title="5.2 Functions(接受一个参数，返回一个结果)"></a>5.2 Functions(接受一个参数，返回一个结果)</h6><pre><code>    Function&lt;String, Integer&gt; toInteger = Integer::valueOf;    Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);    System.out.println(backToString.apply("123"));        123</code></pre><p><img src="/2018/11/18/Java基础：java8特性/../../document/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/blog/image/1569556224804.png" alt="1569556224804"></p><h6 id="5-3-Suppliers-产生指定类型结果-不接受参数"><a href="#5-3-Suppliers-产生指定类型结果-不接受参数" class="headerlink" title="5.3 Suppliers(产生指定类型结果,不接受参数)"></a>5.3 Suppliers(产生指定类型结果,不接受参数)</h6><pre><code>        Supplier&lt;Person&gt; personSupplier = Person::new;        Person person = personSupplier.get();</code></pre><p><img src="/2018/11/18/Java基础：java8特性/../../document/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/blog/image/1569556641067.png" alt="1569556641067"></p><h6 id="5-4-Consumers-指定对输入参数的处理动作"><a href="#5-4-Consumers-指定对输入参数的处理动作" class="headerlink" title="5.4 Consumers(指定对输入参数的处理动作)"></a>5.4 Consumers(指定对输入参数的处理动作)</h6><pre><code>Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println("Hello" + p.name);greeter.accept(new Person("Lee"));</code></pre><h6 id="5-6-Comparators-比较器接口"><a href="#5-6-Comparators-比较器接口" class="headerlink" title="5.6 Comparators(比较器接口)"></a>5.6 Comparators(比较器接口)</h6><pre><code>Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.name.compareTo(p2.name);        Person p1 = new Person("a");        Person p2 = new Person("b");        comparator.compare(p1, p2);        comparator.reversed().compare(p1, p2);</code></pre><p><img src="/2018/11/18/Java基础：java8特性/../../document/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/blog/image/1569557367186.png" alt="1569557367186"></p><h4 id="6-Optionals-防止空指针异常"><a href="#6-Optionals-防止空指针异常" class="headerlink" title="6.Optionals(防止空指针异常)"></a>6.Optionals(防止空指针异常)</h4><pre><code>Optional&lt;String&gt; optional = Optional.of("bam");optional.isPresent();  //trueoptional.get();  //"bam"optional.orElse("fallback");  //"bam"optional.ifPresent((s) -&gt; System.out.println(s.chartAt(0)));</code></pre><p><img src="/2018/11/18/Java基础：java8特性/../../document/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/blog/image/1569557923854.png" alt="1569557923854"></p><h4 id="7-Streams"><a href="#7-Streams" class="headerlink" title="7. Streams"></a>7. Streams</h4><h6 id="7-1-Filter-过滤器"><a href="#7-1-Filter-过滤器" class="headerlink" title="7.1 Filter(过滤器)"></a>7.1 Filter(过滤器)</h6><pre><code>stringCollection                .stream()                .filter((s) -&gt; s.startsWith("a"))                .forEach(System.out::println);</code></pre><h6 id="7-2-Sorted"><a href="#7-2-Sorted" class="headerlink" title="7.2 Sorted"></a>7.2 Sorted</h6><p>​        元素会自然排序，除非指定Comparator，并且只是流进行了排序，集合并不会被改变。</p><pre><code>stringCollection                .stream()                .sorted()                .filter((s) -&gt; s.startsWith("a"))                .forEach(System.out::println);</code></pre><h6 id="7-3-Map"><a href="#7-3-Map" class="headerlink" title="7.3 Map"></a>7.3 Map</h6><pre><code> stringCollection                .stream()                .map(String::toUpperCase)                .sorted((a, b) -&gt; a.compareTo(b))                .forEach(System.out :: println);</code></pre><h6 id="7-4-Match"><a href="#7-4-Match" class="headerlink" title="7.4 Match"></a>7.4 Match</h6><pre><code>//是否存在以a开头的元素boolean anyStartWithA =                stringCollection                .stream()                .anyMatch((s) -&gt; s.startsWith("a")); //所有元素是否以a开头                     boolean allStartWithA =                stringCollection                .stream()                .allMatch((a) -&gt; a.startsWith("a"));  //没有以Z开头的                boolean nonStartWithZ =                stringCollection                .stream()                .noneMatch((a) -&gt; a.startsWith("z"));</code></pre><h6 id="7-5-Count"><a href="#7-5-Count" class="headerlink" title="7.5 Count"></a>7.5 Count</h6><pre><code>long startWithB =                stringCollection                .stream()                .filter((s)-&gt;s.startsWith("b"))                .count();</code></pre><h6 id="7-6Reduce"><a href="#7-6Reduce" class="headerlink" title="7.6Reduce"></a>7.6Reduce</h6><pre><code>Optional&lt;String&gt; reduced =                stringCollection                .stream()                .sorted()                .reduce((s1, s2) -&gt; s1 + "#" + s2);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础：JDK动态代理</title>
      <link href="/2018/11/10/Java%E5%9F%BA%E7%A1%80%EF%BC%9AJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2018/11/10/Java%E5%9F%BA%E7%A1%80%EF%BC%9AJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  学习动态代理，可以先了解一下设计模式中的代理模式。<br>  <a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">设计模式–代理模式</a></p><h2 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2.JDK动态代理"></a>2.JDK动态代理</h2><p>  JDK生成类的过程中比较高效，其基于java内部的拦截器和反射机制实现的，应用的前提是目标类要基于统一的接口</p><h4 id="2-1-使用JDK动态代理的五大步骤："><a href="#2-1-使用JDK动态代理的五大步骤：" class="headerlink" title="2.1 使用JDK动态代理的五大步骤："></a>2.1 使用JDK动态代理的五大步骤：</h4><ul><li>实现InvocationHandler接口，重写自己的invoke方法。</li><li>通过Prxoy.getProxyClass获得代理类的Class</li><li>通过ProxyClazz.getConstructor获得代理类的构造函数</li><li>通过代理类的构造函数，将实现的InvocationHandler实例作为参数进行传递，获得代理类</li><li>代理类调用具体的函数方法</li></ul><p><strong><em>代码如下</em></strong></p><pre><code>//被代理类接口public interface UserService {    String getName();}//被代理类实现类public class UserServiceImpl implements UserService{    @Override    public String getName() {        System.out.println("this is Jerry");        return "Jerry";    }}//InvocationJHandler的实现类public class MyInvocationHandler implements InvocationHandler {    private Object target;    public MyInvocationHandler(){    }    public MyInvocationHandler(Object target) {        super();        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            System.out.println("beforeExecute---" + method.getName());            Object result = method.invoke(target, args);            System.out.println("afterExecute---" + method.getName());            return result;    }}//测试类public class MainTest {    public static void main(String[] args) throws Exception {        //1.获取代理类的class        Class clazz = Proxy.getProxyClass(UserService.class.getClassLoader(), UserService.class);        //2.获取代理类的构造函数        Constructor constructor = clazz.getConstructor(InvocationHandler.class);        //3.通过构造函数，拿到代理对象        UserService userService  = (UserService) constructor.newInstance(new MyInvocationHandler(new UserServiceImpl()));        //4.代理对象调用方法        userService.getName();        //Proxy 提供了静态方法，可以一步获得代理类的执行结果，以上的几步可以整合为一个方法        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(                UserService.class.getClassLoader(),                new Class[]{UserService.class},                new MyInvocationHandler(new UserServiceImpl())        );        userServiceProxy.getName();    }}//执行结果beforeExecute---getNamethis is JerryafterExecute---getNamebeforeExecute---getNamethis is JerryafterExecute---getName</code></pre><h4 id="2-2-补充整理："><a href="#2-2-补充整理：" class="headerlink" title="2.2 补充整理："></a>2.2 补充整理：</h4><p>  在动态代理中，InvocationHandler是核心，每一个代理实例都具有一个关联的调用处理程序，当代理对象生成后，还最后由InvocationHandler的invoke()方法调用目标方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础：CGLIB</title>
      <link href="/2018/11/04/Java%E5%9F%BA%E7%A1%80%EF%BC%9ACGLIB/"/>
      <url>/2018/11/04/Java%E5%9F%BA%E7%A1%80%EF%BC%9ACGLIB/</url>
      
        <content type="html"><![CDATA[<h1 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h1><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  CGLIB（Code Generator Library）是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。<br>  CGLIB的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。</p><h2 id="2-CGLIB-实例代码："><a href="#2-CGLIB-实例代码：" class="headerlink" title="2.CGLIB 实例代码："></a>2.CGLIB 实例代码：</h2><pre><code>//被代理类public class User {    public String getUserName(){        System.out.println("this is Tom");        return "Tom";    }}//实现接口public class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println("------beforeExecute");        Object object = methodProxy.invokeSuper(o, objects);        System.out.println("------afterExecute");        return object;    }}//测试类public class CglibTest {    public static void main(String[] args) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(User.class);        enhancer.setCallback(new MyMethodInterceptor());        User userProxy = (User)enhancer.create();        userProxy.getUserName();    }}//结果------beforeExecutethis is Tom------afterExecute</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
