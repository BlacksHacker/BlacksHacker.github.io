<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql学习之分区分表</title>
      <link href="/2019/08/27/MySql%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E8%A1%A8/"/>
      <url>/2019/08/27/MySql%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql学习之分区分表"><a href="#MySql学习之分区分表" class="headerlink" title="MySql学习之分区分表"></a>MySql学习之分区分表</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​       日常开发中经常会遇到数据库的一些大表，即单表数据存储可能是百万级甚至千万级，由于表数据的庞大，会导致在数据检索和变更方面的效率很低，如果SQL复杂，级联表众多，其运行性能会变的非常糟糕。一定程度的分区分表能有效提升数据库的效率，但凡事均有度，分区分表过多，会造成内存占用升高，以及主从之间数据的一致性问题等等，怎样分区分表，分多少合适，还是要基于现实的业务情况进行选择处理。</p><h3 id="2-分区"><a href="#2-分区" class="headerlink" title="2.分区"></a>2.分区</h3><p>​        分区是在Mysql5.1引入的，是一种简单的<strong>水平拆分</strong>，在建表时加上分区参数，对应用是透明的，无需代码的修改。</p><p>​        分区可以分为两种：<strong>水平分区</strong>和<strong>垂直分区</strong></p><ul><li>水平分区，通常是对表的行进行分区，将不同的行数据进行切割，但表中定义的列在每个数据集中都能找到。</li><li>垂直分区，通过对表的垂直划分来减少目标表的宽度，使得特定的列被划分到特定的分区，每个分区都包含了该列所对应的所有的行</li></ul><p>​        <strong>水平分区的四大类型</strong></p><ul><li>范围分区（Range）</li><li>列表分区（List）</li><li>哈希分区（Hash）</li><li>Key分区<h5 id="2-1-Range分区"><a href="#2-1-Range分区" class="headerlink" title="2.1 Range分区"></a>2.1 Range分区</h5>​        把一个连续的区间进行划分，把多行分配给分区，常见的字段为自增的主键ID,或者是时间等，基于分区的列最好是整型。</li></ul><pre><code>CREATE TABLE `sql_range` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY RANGE (id)(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN (30),    PARTITION p4 VALUES LESS THAN (40),    PARTITION p5 VALUES LESS THAN (MAXVALUE))</code></pre><p><strong><em>注意</em></strong>：</p><ul><li>按照时间范围分区时，转换函数最好使用UNIX_TIMESTAMP 而不是TIMESTAMP</li><li>对于null值，Range分区会将其作为最小分区值存储<h5 id="2-2-List分区"><a href="#2-2-List分区" class="headerlink" title="2.2 List分区"></a>2.2 List分区</h5>​       类似于Range分区，但区别在于List分区是一个枚举值列表的集合，而非区间，建议分区为非null列，否则插入null，而集合中不包含，则会报错。另外，List分区只支持整型。</li></ul><pre><code>CREATE TABLE `sql_list` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY LIST (id)(    PARTITION p1 VALUES IN (1,3,5),    PARTITION p2 VALUES IN  ('a','b'))会报错：VALUES value for partition 'p2' must have type INT</code></pre><h5 id="2-3-Hash分区"><a href="#2-3-Hash分区" class="headerlink" title="2.3 Hash分区"></a>2.3 Hash分区</h5><p>​        对于一些表，是没有连续的字段或者集合性质的可以用来明显分区的特征字段，但表数据又非常庞大，为了将这些数据分散存储，mysql提供了hash分区，基于给定的分区个数，将数据分配到不同分区，但只针对于整数hash，非整数类型数据需要表达式转换，复杂表达式可能造成性能问题。</p><p>hash分区可以细分为：<strong><em>hash</em></strong>分区和<strong><em>线性hash</em></strong>分区，语法区别在于 partition by linear hash.</p><ul><li>Hash分区，是通过MOD函数取模的方式可以让数据非常平均的分布在每一分区，但由于分区在创建时已经固定，新增和收缩分区，数据的迁移比较大。</li><li>线性Hash分区，优点在于增加，删除，合并和拆分分区变的快捷，有利于处理大量的数据的表，缺点在于数据分布可能不太均匀。</li></ul><p>​       hash分区示例代码如下：</p><pre><code>CREATE TABLE `sql_hash` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY HASH (id)PARTITIONS 4;//不指定PARTITIONS 4子句时，默认分区为1</code></pre><h6 id="2-4-Key分区"><a href="#2-4-Key分区" class="headerlink" title="2.4 Key分区"></a>2.4 Key分区</h6><p>key分区类似于Hash分区，但区别在于以下四点：</p><ul><li><p>KEY分区允许多列，Hash只允许一列。</p></li><li><p>如果有主键或唯一键，key分区可不指定，默认是主键或唯一键。如果没有必须显示指定。</p></li><li><p>KEY分区必须基于列，而不是基于列的表达式</p></li><li><p>Hash的算法是MOD函数，而Key是MD5</p></li></ul><pre><code>CREATE TABLE `sql_key` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY KEY (id)PARTITIONS 4;    </code></pre><h3 id="3-分区表"><a href="#3-分区表" class="headerlink" title="3.分区表"></a>3.分区表</h3><h5 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h5><p>​        分区表是由多个相关的底层表来实现的，这些底层表也是由句柄对象表示，所以我们可以直接访问各个分区，管理分区的各个底层表和普通表对于存储引擎来说是一样的，分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储角度来看没有区别，存储引擎无需知道该表是普通表还是分区表。</p><p><img src="C:%5CUsers%5Cwenhb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566879182129.png" alt="1566879182129"></p><h5 id="3-2-操作分析"><a href="#3-2-操作分析" class="headerlink" title="3.2 操作分析"></a>3.2 操作分析</h5><ul><li>select：查询分区表时，分区层先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</li><li>insert：写入分区表时，分区层先打开并锁住所有的底层表，确定哪个分区接受这条记录，再将记录写入对应的底层</li><li>delete: 删除数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，并进行记录删除</li><li>uodate: 更新数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，取出更新，再确定数据该放到哪个分区，对底层表进行写操作，并删除原分区表的旧数据。</li></ul><p><strong>注意</strong>：如果存储引擎能够自己实现行级锁，如Innodb，则会在分区层释放对应的表锁，这个加锁和解锁的过程与普通Innodb上的查询类似。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><h5 id="4-1-分区的注意事项"><a href="#4-1-分区的注意事项" class="headerlink" title="4.1 分区的注意事项"></a>4.1 分区的注意事项</h5><ul><li><p>primary key  和unique key必须包含在分区key的一部分，否则在创建primary key 和unique index时会报错</p></li><li><p>范围分区添加分区只能在最大值后面追加分区</p></li><li><p>所有分区的engine必须一样</p></li><li><p>范围分区字段：integer，数值表达式，日期列，日期函数表达式（如year(), to_days(), to_seconds(), unix_timestamp()）</p></li><li><p>分区字段尽量避免null值，null值对于range分区，会放置到最左边的分区，对于list分区，必须在集合中加入null，对于key和hash分区，都会将null返回为0</p></li><li><p>一个表最多只能有1024个分区</p></li><li><p>分区表无法使用外键约束</p><h5 id="4-2-分区的优点"><a href="#4-2-分区的优点" class="headerlink" title="4.2 分区的优点"></a>4.2 分区的优点</h5></li><li><p>只获取表的热点数据，其他都是历史数据</p></li><li><p>分区表更容易进行维护，可以针对单个分区删除数据，也可以新增分区进行数据的插入，还可以对一个独立的分区进行优化、检查和修复等操作</p></li><li><p>部分查询能够从查询条件确定只落到少数分区上，速度比较快</p></li><li><p>分区表的数据可以分布到不同的物理设备上，从而高效利用多个硬件设备</p></li><li><p>可以使用分区表避免某些特殊瓶颈，如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</p></li><li><p>可以备份和恢复单个分区</p></li><li><p>优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时，涉及聚合函数是，可以在分区上进行处理，最终只需要汇总所有分区的得到的结果</p><h5 id="4-3-分区与分表的关系"><a href="#4-3-分区与分表的关系" class="headerlink" title="4.3 分区与分表的关系"></a>4.3 分区与分表的关系</h5></li><li><p>都能提高mysql的性能，在高并发状态下有一个良好的表现</p></li><li><p>分表和分区不矛盾，可以相互配合，对于需要大量访问，并且数据比较多的表，可以采用分区加分表的方式，访问量不大，但数据很多的表，可以仅采用分区的方式。</p></li><li><p>分表稍微复杂，需要手动创建子表，读写时需要计算子表名。</p></li><li><p>表分区相对于分表，操作方便，不需要创建子表</p></li></ul><p>  关于分表可详见文章 <a href="">Mysql–分表</a><br>  关于分区管理，详见<a href="https://github.com/bingbo/blog/wiki/MYSQL%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">MYSQL分区管理</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/26/hello-world/"/>
      <url>/2019/08/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
