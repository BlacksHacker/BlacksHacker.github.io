<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>架构设计：AMQP协议</title>
      <link href="/2019/08/30/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AAMQP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/30/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AAMQP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  AMQP协议的全称是：Advanced Message Queuing Protocol（高级消息队列协议）。目前AMQP协议的版本为 Version 1.0，是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><h1 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2. 协议结构"></a>2. 协议结构</h1><p>  AMQP协议结构如下：</p><p><img src="/2019/08/30/架构设计：AMQP协议学习/AMQP1.PNG" alt></p><ul><li>由上图可以看出，AMQP结构的构成分为六块<ul><li><strong>Message</strong>：消息体</li><li><strong>Producer</strong>：生产者</li><li><strong>Consumer</strong>：消费者</li><li><strong>Virtual Host</strong>：虚拟节点</li><li><strong>Exchange</strong>：交换机</li><li><strong>Queue</strong>：队列<ul><li>AMQP的客户端由<strong>Producer</strong>和<strong>Consumer</strong>组成，服务端Broker则是由Virtual Host，Exchange和Queue组成。</li></ul></li></ul></li><li><strong>Message</strong>的传递需要客户端（Producer和Consumer）创建连接到Broker的连接Connection，之后由客户端在Connection之上建立channel通道连接到Virtual host或者Queue上。Connection支持多个Channel的建立，消息的发送与接受只有在channel上才能进行。</li><li><strong>Exchange</strong>作为协议中的交换机，可以和多个Queue以及Exchange进行绑定，消息会根据Exchange上的路由规则进行发送传播。Exchange要至少和一个Queue或者Exchange绑定关系，并且设置好Queue和Exchange的Routing（路由规则），Exchange根据路由规则发送消息到符合路由规则的Queue或Exchange中，路由规则可以和Message中的Routing key属性配合使用。Exchange的路由规则包含三种：<strong>Direct、Fanout、Topic</strong></li><li><strong>Queue</strong>对于消息的处理，没有channel连接到Queue时，消息将会被存储，知道channel被创建，如果channel已经创建，消息按顺序发送给channel</li><li><strong>Consumer</strong>在收到消息后，需要手动（可以设置自动发送和无需发送）发送一条ACK回应消息给对应的Queue，Queue接收到后，会将该消息移除掉，在channel断开之前Queue若未能收到消息，则该消息会被发送给其他的channel。发送NACK，消息会发送给其他channel，不论当前channel是否已经断开。<h1 id="3-消息格式"><a href="#3-消息格式" class="headerlink" title="3.消息格式"></a>3.消息格式</h1>  作为一种网络通讯协议，AMQP工作在七层/五层网路模型的应用层。其消息真正的内容主要在PAYLOAD区域，即交付区，非PAYLOAD区，在网络协议的应用层说明Channel的工作状态。<br>PAULOAD区域共七个数据区域：<table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>header</td><td>记录AMQP消息在“支持AMQP的中间件”中的交互状态，如消息在节点间被交互的总次数，优先级，TTL值等信息</td></tr><tr><td>delivery-annotations</td><td>在header部分只能传递规范的、标准的、经过ISO/IEC组织定义过的属性。所以对应这里用来记录“非标”的header信息</td></tr><tr><td>message-annotations</td><td>用于存储一些自定义的辅助属性，主要用于消息的转换</td></tr><tr><td>properties</td><td>AMQP消息的正文内容是从properties到application-data部分，properties记录了消息正文中标准的，规范的属性，例如消息ID，分组ID,发送者ID等</td></tr><tr><td>application-properties</td><td>主要记录和应用有关的数据，该协议的实现产品需要用这部分数据决定其处理逻辑，例如消息的Routing是什么，是否进行持久化等</td></tr><tr><td>application-data</td><td>使用二进制格式描述的AMQP消息的用户部分内容，即发送的真实内容</td></tr><tr><td>footer</td><td>一般用来存储辅助内容，如消息的哈希值，HMAC，签名或加密细节</td></tr></tbody></table></li></ul><h1 id="3-Exchange路由规则"><a href="#3-Exchange路由规则" class="headerlink" title="3. Exchange路由规则"></a>3. Exchange路由规则</h1><table><thead><tr><th>规则命称</th><th>区别</th></tr></thead><tbody><tr><td>Direct路由</td><td>该模式下Exchange将使用消息中所携带的Routing key 和Queue中的Routing key进行比较，如果匹配，该消息进入该队列</td></tr><tr><td>Fanout</td><td>Exchange接受消息后，会将消息赋值多份，发送到自己绑定的Exchange和Queue中，不需要Routing key</td></tr><tr><td>Topic路由</td><td>Exchange将支持‘#’和’*‘通配符进行Routing key的匹配查找</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计：Stomp协议</title>
      <link href="/2019/08/28/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AStomp%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/28/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AStomp%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  消息从发送到接受的方式有两种：一种称为<strong>即时消息通讯</strong>，即一端发送之后，另一端能够立即接受 ，具体实现就是RPC。另一种称为<strong>延迟消息通讯</strong>，即消息发出后，进入中间容器进行存储，到达一定条件之后，再发送给接受者，中间的容器称为<strong>消息队列</strong>。<br>  <strong>Stomp协议</strong>，英文全名<strong><em>Streaming Text Orientated Message Protocol</em></strong>，中文名称为 ‘流文本定向消息协议’。是一种以纯文本为载体的协议，前身是TTMP协议，专为消息中间件设计。<br>  <strong>Stomp协议属于延迟消息通讯</strong><br>  目前的版本为V1.1和V1.2</p><h3 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2.协议结构"></a>2.协议结构</h3><p>  标准的协议包括：<strong>命令/关键信息，头信息，文本内容</strong></p><pre><code>CONNECT    //命令accept-version:1.2  //版本号（头信息）param1:value1param2:value2this is stomp    //文本内容</code></pre><p>  Stomp协议由两个角色组成：<strong>客户端(Client)</strong>和<strong>消息代理(Broker)</strong></p><p><img src="/2019/08/28/架构设计：Stomp协议学习/1566985233886.png" alt></p><p>  <strong>消息代理（Broker）</strong>只负责接受和存储客户端发送的消息，依据客户端要求的路径进行转发，对消息内容不做任何处理，只负责客户端连接和订阅</p><h3 id="3-交互流程及命令"><a href="#3-交互流程及命令" class="headerlink" title="3. 交互流程及命令"></a>3. 交互流程及命令</h3><p>   交互流程大致如下图：<br><img src="/2019/08/28/架构设计：Stomp协议学习/1566986429790.png" alt></p><ul><li><strong>CONNECT/STOMP</strong>：客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</li><li><strong>CONNECTED</strong>：代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</li><li><strong>SEND</strong>：客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</li><li><strong>BEGIN</strong>：Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</li><li><strong>COMMIT</strong>：提交事务。使得事务中的一条或多条消息进入Stomp代理队列</li><li><strong>ABORT</strong>：取消/终止当前还未COMMIT的事务。</li><li><strong>SUBSCRIBE</strong>：订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</li><li><strong>UNSUBSCRIBE</strong>：取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</li><li><strong>ACK</strong>：若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</li><li><strong>NACK</strong>：若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</li><li><strong>DISCONNECT</strong>：断开客户端和消息代理之间的连接</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong>CONNECT/STOMP</strong></td><td>客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</td></tr><tr><td><strong>CONNECTED</strong></td><td>代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</td></tr><tr><td><strong>SEND</strong></td><td>客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</td></tr><tr><td><strong>BEGIN</strong></td><td>Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</td></tr><tr><td><strong>COMMIT</strong></td><td>提交事务。使得事务中的一条或多条消息进入Stomp代理队列</td></tr><tr><td><strong>ABORT</strong></td><td>取消/终止当前还未COMMIT的事务</td></tr><tr><td><strong>SUBSCRIBE</strong></td><td>订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</td></tr><tr><td><strong>UNSUBSCRIBE</strong></td><td>取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</td></tr><tr><td><strong>ACK</strong></td><td>若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</td></tr><tr><td><strong>NACK</strong></td><td>若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</td></tr><tr><td><strong>DISCONNECT</strong></td><td>断开客户端和消息代理之间的连接</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql深入之分库</title>
      <link href="/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%BA%93/"/>
      <url>/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  大多数的数据库设计往往是一台主库负责数据的写入，多台从库同步主库数据仅提供读数据，但随着业务的增长，主库的写压力会与日俱增，这时往往通过分库+分布式的架构来缓解来自业务数据增长带来的压力，但同时也会引发数据的一致性和事务等诸多问题。</p><h3 id="2-分库"><a href="#2-分库" class="headerlink" title="2.分库"></a>2.分库</h3><p>  数据库的拆分同样也可以分为两种<strong>垂直拆分</strong>和<strong>水平拆分</strong><br>  <strong>垂直拆分</strong>是分库的首选，其分库方式较为简单，因其的依据在于业务的整体架构，可以将独立不相关的业务模块的表迁移到不同的库中，要求数据的增长速度比较平稳。<br>  <strong>水平拆分</strong>复杂度较高，往往会涉及<strong>分表</strong>。<br>  拆分思路：</p><ul><li>按算法对应<br>  将数据的主键按照固定的算法进行分类，放置到不同的数据库中，实现较为方便，但扩展性较差，后续节点收缩或算法变动会造成很大的数据集迁移。</li><li>按索引映射表对应<br>  即建立数据主键与所在数据库的关系表，每次数据请求先去该表查取，再到具体的数据库获取数据，优势在于伸缩性，新的数据进来，只需要放入合适的库中，在关系表上添加对应的记录便可。缺点在于会增加数据库的访问次数。<h3 id="3-分库面临的问题"><a href="#3-分库面临的问题" class="headerlink" title="3.分库面临的问题"></a>3.分库面临的问题</h3></li><li>不能跨库关联查询<br>  当关联数据分布在不同的数据库中或者获取级联数据时不能进行join操作，解决思路要么数据两边均存储一份（全局表），采用空间换时间，要么只能代码层查询之后再进行聚合，牺牲部分性能</li><li>不能保证数据的一致性<br>  跨库的数据没有外键约束，也没有事务保证。</li><li>所有查询必须提供数据库线索<br>  分库之后的数据可能存在于不同库中，每次数据的操作都需要先定位库的位置。</li><li>自增ID<br>  有时跨库数据可能依赖于数据主键，采取自增主键可能导致不同库的数据录入时主键信息不一致，可以采取第三方表数据生成自增主键为标准，作为相关数据的主键，保证自增的一致性。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理CGLIB</title>
      <link href="/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----CGLIB/"/>
      <url>/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----CGLIB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  CGLIB（Code Generator Library）是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。<br>  CGLIB的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。</p><h2 id="2-CGLIB-实例代码："><a href="#2-CGLIB-实例代码：" class="headerlink" title="2.CGLIB 实例代码："></a>2.CGLIB 实例代码：</h2><pre><code>//被代理类public class User {    public String getUserName(){        System.out.println("this is Tom");        return "Tom";    }}//实现接口public class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println("------beforeExecute");        Object object = methodProxy.invokeSuper(o, objects);        System.out.println("------afterExecute");        return object;    }}//测试类public class CglibTest {    public static void main(String[] args) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(User.class);        enhancer.setCallback(new MyMethodInterceptor());        User userProxy = (User)enhancer.create();        userProxy.getUserName();    }}//结果------beforeExecutethis is Tom------afterExecute</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理JDK</title>
      <link href="/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  学习动态代理，可以先了解一下设计模式中的代理模式。<br>  <a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">设计模式–代理模式</a></p><h2 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2.JDK动态代理"></a>2.JDK动态代理</h2><p>  JDK生成类的过程中比较高效，其基于java内部的拦截器和反射机制实现的，应用的前提是目标类要基于统一的接口</p><h4 id="2-1-使用JDK动态代理的五大步骤："><a href="#2-1-使用JDK动态代理的五大步骤：" class="headerlink" title="2.1 使用JDK动态代理的五大步骤："></a>2.1 使用JDK动态代理的五大步骤：</h4><ul><li>实现InvocationHandler接口，重写自己的invoke方法。</li><li>通过Prxoy.getProxyClass获得代理类的Class</li><li>通过ProxyClazz.getConstructor获得代理类的构造函数</li><li>通过代理类的构造函数，将实现的InvocationHandler实例作为参数进行传递，获得代理类</li><li>代理类调用具体的函数方法</li></ul><p><strong><em>代码如下</em></strong></p><pre><code>//被代理类接口public interface UserService {    String getName();}//被代理类实现类public class UserServiceImpl implements UserService{    @Override    public String getName() {        System.out.println("this is Jerry");        return "Jerry";    }}//InvocationJHandler的实现类public class MyInvocationHandler implements InvocationHandler {    private Object target;    public MyInvocationHandler(){    }    public MyInvocationHandler(Object target) {        super();        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            System.out.println("beforeExecute---" + method.getName());            Object result = method.invoke(target, args);            System.out.println("afterExecute---" + method.getName());            return result;    }}//测试类public class MainTest {    public static void main(String[] args) throws Exception {        //1.获取代理类的class        Class clazz = Proxy.getProxyClass(UserService.class.getClassLoader(), UserService.class);        //2.获取代理类的构造函数        Constructor constructor = clazz.getConstructor(InvocationHandler.class);        //3.通过构造函数，拿到代理对象        UserService userService  = (UserService) constructor.newInstance(new MyInvocationHandler(new UserServiceImpl()));        //4.代理对象调用方法        userService.getName();        //Proxy 提供了静态方法，可以一步获得代理类的执行结果，以上的几步可以整合为一个方法        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(                UserService.class.getClassLoader(),                new Class[]{UserService.class},                new MyInvocationHandler(new UserServiceImpl())        );        userServiceProxy.getName();    }}//执行结果beforeExecute---getNamethis is JerryafterExecute---getNamebeforeExecute---getNamethis is JerryafterExecute---getName</code></pre><h4 id="2-2-补充整理："><a href="#2-2-补充整理：" class="headerlink" title="2.2 补充整理："></a>2.2 补充整理：</h4><p>  在动态代理中，InvocationHandler是核心，每一个代理实例都具有一个关联的调用处理程序，当代理对象生成后，还最后由InvocationHandler的invoke()方法调用目标方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql深入之分表</title>
      <link href="/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E8%A1%A8/"/>
      <url>/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  mysql中存在一种机制是表锁定（myisam存储引擎）和行锁定（innodb存储引擎），对于一行数据或一张表，同时只能有一条sql进行操作，其他针对该行或该表的执行sql需要进行排队，在高并发情况下，请求执行的sql如果出现骤增，整个系统的性能将会卡在sql的执行效率上。对一些数据庞大的表，可以采取分表策略，将执行的sql进行均匀分布，减少sql等候执行队列的长度，提高数据库的吞吐量。</p><h3 id="2-分表"><a href="#2-分表" class="headerlink" title="2.分表"></a>2.分表</h3><p> 分表依据不同的业务情况可以分为两种切分方式：<strong>垂直切分</strong>和<strong>水平切分</strong>。</p><h5 id="2-1-垂直切分"><a href="#2-1-垂直切分" class="headerlink" title="2.1 垂直切分"></a>2.1 垂直切分</h5><p> 垂直切分的场景是，表中属性很多，但是基本上是核心的几个属性的操作频率很高，其他的属性平时不怎么需要获取到。</p><ul><li>将长度较短，访问频率高的属性可以放到一个表中，暂且称为主表。</li><li>将长度较短，访问频率低的属性放到一个表中，暂且称为扩展表。</li><li>也可以将经常一起访问的属性，放置到同一表中，具体视业务而定。</li></ul><p> 数据库有自身的内存buffer，会将磁盘上的数据load到内存buffer中，其单位是以row为单位的，在内存有限的情况下，缓存越短的row，就能缓存更多的数据，提高缓存命中率，减少磁盘访问，有效提高操作效率。</p><p><strong>缺点：</strong></p><ul><li>会造成一定量的冗余列</li><li>查询所有数据需要进行join操作，如果进行了分库，表在不同库或服务器，将会增加访问数据库次数。<h5 id="2-2-水平切分"><a href="#2-2-水平切分" class="headerlink" title="2.2 水平切分"></a>2.2 水平切分</h5> 水平切分场景是，单表的数据量很大，执行多条sql会造成排队较长，整体的执行效率降低。这时需要将表中行数据按照一定的规则进行进行划分，创建多个子表，<strong>分表不同于分区，mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对应三个文件，.MYD数据文件，。MYI索引文件，。FRM表结构文件</strong>。这样就能保证sql的执行是在不同的表中，读取的时候从各自的表中进行读取，降低了单表的sql执行的排队长度。</li></ul><p><strong>缺点：</strong></p><ul><li>当分配规则确定后，打破这条规则很麻烦，可能会导致相同的数据，因为规则不同而出现在不同的表中。</li><li>同库不同表数据需要进行union操作</li><li>不同库不同表将会增加数据库访问次数</li></ul><p><strong>利用merge存储引擎分表</strong><br> 把已有的大数据量的表进行切分的确非常困难，可能涉及到要修改代码中大量的sql，利用merge存储引擎分表将会在数据库层面进行表的切分，而对外程序的中依旧是该主表，不需要代码中sql的修改，但仅限于MyISAM存储引擎，采用InnoDB引擎的表不适用。<br> 具体代码如下：</p><pre><code># 分表1CREATE TABLE user_1(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50)) ENGINE=MYISAM#分表2CREATE TABLE user_2(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50)) ENGINE=MYISAM# merge表挂载分表CREATE TABLE USER(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50))  ENGINE=MERGE UNION=(user_1,user_2) INSERT_METHOD=LAST;</code></pre><ul><li><strong>ENGINE=MERGE</strong> 指明merge表使用MERGE引擎</li><li><strong>UNION=(user_1,user_2)</strong> 指明merge表挂载了哪些表</li></ul><pre><code>#该sql用于移除user_2的挂载ALTER TABLE USER ENGINE=MERGE UNION=(user_1) INSERT_METHOD=LAST </code></pre><ul><li><strong>INSERT_METHOD=LAST</strong> 指明输入插入的方式，0表示不允许数据插入，<strong>FIRST</strong>将会插入UNION的第一个分表中，<strong>LAST</strong>将会插入UNION的最后一个分表中</li><li>如上sql所示，merger表和其他的分表结构必须保持一致，包括同样的索引。</li><li>一个merge表不能在整个表上维持unique约束，若merge存在重复主键，按主键查询，获取一条记录便会停止。后续重复主键的数据将无法插入，即只保证挂载之后主键的唯一性。</li><li>若分表存在自增主键，merge表新数据的插入自增将会从分表中最大的主键开始自增。即user_1最大自增主键为10，user_2为20，则merge表数据的主键将会从21开始。</li></ul><p><strong>推荐：利用merge存储引擎分表，可以先有一张merge表，且只挂载一个分表，当分表的数据到达一定的数量级之后，再建立新的分表进行挂载，数据将会插入到新分表中</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql深入之分区</title>
      <link href="/2019/08/27/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%8C%BA/"/>
      <url>/2019/08/27/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>  日常开发中经常会遇到数据库的一些大表，即单表数据存储可能是百万级甚至千万级并且字段非常多，由于表数据的庞大，会导致在数据检索和变更方面的效率很低，如果SQL复杂，级联表众多，其运行性能会变的非常糟糕。使得数据库在高并发情况下成为系统的性能瓶颈。一定程度的分区分表，甚至在分布式情况下的分库等，能有效提升数据库的效率，但凡事均有度，分区分表过多，会造成内存占用升高，以及主从之间数据的一致性问题等等，怎样分区分表，分多少合适，还是要基于现实的业务情况进行选择处理。</p><h3 id="2-分区"><a href="#2-分区" class="headerlink" title="2.分区"></a>2.分区</h3><p>  分区允许通过设置需要的规则在文件系统中分布存储单个表的各个部分。实际上就是表的不同部分作为单独的表存储在不同的位置，Mysql5.1引入的，是一种简单的<strong>水平拆分</strong>，在建表时加上分区参数，对应用是透明的，无需代码的修改。分区本质上是将数据底层的存储块变多，在数据库层面依旧是一张表。</p><p>  目前的mysql8.0中，唯一支持分区的存储引擎是InnoDB和NDB。分区不能与不支持分区的存储引擎一起使用，这些引擎包括MyISAM、MERGE、CSV和FEDERATED存储引擎。</p><p>  分区可以分为两种：<strong>水平分区</strong>和<strong>垂直分区</strong></p><ul><li>水平分区，通常是对表的行进行分区，将不同的行数据进行切割，但表中定义的列在每个数据集中都能找到，只是根据规则将不同的行数据存储在不同的存储块中。</li><li>垂直分区，通过对表的垂直划分来减少目标表的宽度，使得特定的列被划分到特定的分区，每个分区都包含了该列所对应的所有的行</li></ul><p><strong>分区的本质是单表数据在物理层存储的改变，目前mysql还不支持垂直分区，网上大多数将垂直分区和垂直分表混为一谈。</strong></p><p>  <strong>水平分区的四大类型</strong></p><ul><li>范围分区（Range）</li><li>列表分区（List）</li><li>哈希分区（Hash）</li><li>Key分区<h5 id="2-1-Range分区"><a href="#2-1-Range分区" class="headerlink" title="2.1 Range分区"></a>2.1 Range分区</h5>   把一个连续的区间进行划分，把多行分配给分区，常见的字段为自增的主键ID,或者是时间等，基于分区的列最好是整型。</li></ul><pre><code>CREATE TABLE `sql_range` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY RANGE (id)(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN (30),    PARTITION p4 VALUES LESS THAN (40),    PARTITION p5 VALUES LESS THAN (MAXVALUE))-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- range添加新分区alter table &lt;table&gt; add partition(partition p4 values less than MAXVALUE);-- range重新分区ALTER TABLE user REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES LESS THAN MAXVALUE);</code></pre><p><strong><em>注意</em></strong>：</p><ul><li>按照时间范围分区时，转换函数最好使用UNIX_TIMESTAMP 而不是TIMESTAMP</li><li>对于null值，Range分区会将其作为最小分区值存储<h5 id="2-2-List分区"><a href="#2-2-List分区" class="headerlink" title="2.2 List分区"></a>2.2 List分区</h5>  类似于Range分区，但区别在于List分区是一个枚举值列表的集合，而非区间，建议分区为非null列，否则插入null，而集合中不包含，则会报错。另外，List分区只支持整型。</li></ul><pre><code>CREATE TABLE `sql_list` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY LIST (id)(    PARTITION p1 VALUES IN (1,3,5),    PARTITION p2 VALUES IN  ('a','b'))会报错：VALUES value for partition 'p2' must have type INT-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- list添加新分区alter table &lt;table&gt; add partition(partition p4 values in (25,26,28));-- list重新分区ALTER TABLE &lt;table&gt; REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES in (1,2,3,4,5));</code></pre><h5 id="2-3-Hash分区"><a href="#2-3-Hash分区" class="headerlink" title="2.3 Hash分区"></a>2.3 Hash分区</h5><p>  对于一些表，是没有连续的字段或者集合性质的可以用来明显分区的特征字段，但表数据又非常庞大，为了将这些数据分散存储，mysql提供了hash分区，基于给定的分区个数，将数据分配到不同分区，但只针对于整数hash，非整数类型数据需要表达式转换，复杂表达式可能造成性能问题。</p><p>hash分区可以细分为：<strong><em>hash</em></strong>分区和<strong><em>线性hash</em></strong>分区，语法区别在于 partition by linear hash.</p><ul><li>Hash分区，是通过MOD函数取模的方式可以让数据非常平均的分布在每一分区，但由于分区在创建时已经固定，新增和收缩分区，数据的迁移比较大。</li><li>线性Hash分区，优点在于增加，删除，合并和拆分分区变的快捷，有利于处理大量的数据的表，缺点在于数据分布可能不太均匀。</li></ul><p>  hash分区示例代码如下：</p><pre><code>CREATE TABLE `sql_hash` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY HASH (id)PARTITIONS 4;//不指定PARTITIONS 4子句时，默认分区为1-- hash重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-4-Key分区"><a href="#2-4-Key分区" class="headerlink" title="2.4 Key分区"></a>2.4 Key分区</h5><p>  key分区类似于Hash分区，但区别在于以下四点：</p><ul><li><p>KEY分区允许多列，Hash只允许一列。</p></li><li><p>如果有主键或唯一键，key分区可不指定，默认是主键或唯一键。如果没有必须显示指定。</p></li><li><p>KEY分区必须基于列，而不是基于列的表达式</p></li><li><p>Hash的算法是MOD函数，而Key是MD5</p></li></ul><pre><code>CREATE TABLE `sql_key` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY KEY (id)PARTITIONS 4;    -- key重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-5-子分区"><a href="#2-5-子分区" class="headerlink" title="2.5 子分区"></a>2.5 子分区</h5><p>  子分区是对分区表中的每个分区再进行分割，又称复合分区，支持对range和list进行子分区，子分区可以采用hash分区或者key分区。复合分区用于保存大量的数据记录。<br>  示例代码如下：</p><pre><code>CREATE TABLE custom(    id INT,    NAME VARCHAR(20))PARTITION BY RANGE(id)SUBPARTITION BY HASH(id) SUBPARTITIONS 2(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN MAXVALUE)# 指明了子分区名CREATE TABLE seller(    id INT,    NAME VARCHAR(50)) PARTITION BY RANGE(id)SUBPARTITION BY HASH(id)(    PARTITION p1 VALUES LESS THAN (10)(SUBPARTITION s1, SUBPARTITION s2, SUBPARTITION s3),    PARTITION p2 VALUES LESS THAN (20)(SUBPARTITION s4, SUBPARTITION s5, SUBPARTITION s6),    PARTITION p3 VALUES LESS THAN MAXVALUE(SUBPARTITION s7, SUBPARTITION s8, SUBPARTITION s9))--子分区添加新分区，系统自动为子分区命名alter table &lt;table&gt; add partition(partition p3 values less than MAXVALUE);</code></pre><h3 id="3-分区表"><a href="#3-分区表" class="headerlink" title="3.分区表"></a>3.分区表</h3><h5 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h5><p>  普通表进行分区之后就被称为分区表，分区表是由多个相关的底层表（存储块）来实现的，这些底层表也是由句柄对象表示，所以我们可以直接访问各个分区，管理分区的各个底层表和普通表对于存储引擎来说是一样的，分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储角度来看没有区别，存储引擎无需知道该表是普通表还是分区表。</p><p><img src="/2019/08/27/MySql深入之分区/1566879182129.png" alt></p><h5 id="3-2-操作分析"><a href="#3-2-操作分析" class="headerlink" title="3.2 操作分析"></a>3.2 操作分析</h5><ul><li>select：查询分区表时，分区层先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</li><li>insert：写入分区表时，分区层先打开并锁住所有的底层表，确定哪个分区接受这条记录，再将记录写入对应的底层</li><li>delete: 删除数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，并进行记录删除</li><li>uodate: 更新数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，取出更新，再确定数据该放到哪个分区，对底层表进行写操作，并删除原分区表的旧数据。</li></ul><p><strong>注意</strong>：如果存储引擎能够自己实现行级锁，如Innodb，则会在分区层释放对应的表锁，这个加锁和解锁的过程与普通Innodb上的查询类似。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><h5 id="4-1-分区的注意事项"><a href="#4-1-分区的注意事项" class="headerlink" title="4.1 分区的注意事项"></a>4.1 分区的注意事项</h5><ul><li><p>primary key  和unique key必须包含在分区key的一部分，否则在创建primary key 和unique index时会报错</p></li><li><p>范围分区添加分区只能在最大值后面追加分区</p></li><li><p>所有分区的engine必须一样</p></li><li><p>范围分区字段：integer，数值表达式，日期列，日期函数表达式（如year(), to_days(), to_seconds(), unix_timestamp()）</p></li><li><p>分区字段尽量避免null值，null值对于range分区，会放置到最左边的分区，对于list分区，必须在集合中加入null，对于key和hash分区，都会将null返回为0</p></li><li><p>一个表最多只能有1024个分区</p></li><li><p>分区表无法使用外键约束</p><h5 id="4-2-分区的优点"><a href="#4-2-分区的优点" class="headerlink" title="4.2 分区的优点"></a>4.2 分区的优点</h5></li><li><p>只获取表的热点数据，其他都是历史数据</p></li><li><p>分区表更容易进行维护，可以针对单个分区删除数据，也可以新增分区进行数据的插入，还可以对一个独立的分区进行优化、检查和修复等操作</p></li><li><p>部分查询能够从查询条件确定只落到少数分区上，速度比较快</p></li><li><p>分区表的数据可以分布到不同的物理设备上，从而高效利用多个硬件设备</p></li><li><p>可以使用分区表避免某些特殊瓶颈，如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</p></li><li><p>可以备份和恢复单个分区</p></li><li><p>优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时，涉及聚合函数是，可以在分区上进行处理，最终只需要汇总所有分区的得到的结果</p><h5 id="4-3-分区与分表的关系"><a href="#4-3-分区与分表的关系" class="headerlink" title="4.3 分区与分表的关系"></a>4.3 分区与分表的关系</h5></li><li><p>都能提高mysql的性能，在高并发状态下有一个良好的表现</p></li><li><p>分表和分区不矛盾，可以相互配合，对于需要大量访问，并且数据比较多的表，可以采用分区加分表的方式，访问量不大，但数据很多的表，可以仅采用分区的方式。</p></li><li><p>分表稍微复杂，需要手动创建子表，读写时需要计算子表名。</p></li><li><p>表分区相对于分表，操作方便，不需要创建子表</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/26/hello-world/"/>
      <url>/2019/08/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
