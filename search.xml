<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>架构设计：ActiveMQ学习(二)</title>
      <link href="/2019/09/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AActiveMQ%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/09/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AActiveMQ%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  上文已经学习了ActiveMQ的存储分为两种：持久化和非持久化，其中持久化的介质可以是<strong>磁盘文件系统</strong>，也可以是其<strong>内置数据库</strong>，或者外部的<strong>关系型数据库</strong>。</p><h1 id="2-持久化存储"><a href="#2-持久化存储" class="headerlink" title="2.持久化存储"></a>2.持久化存储</h1><ul><li>发布订阅模式下，没有订阅者时，消息也要进行先存储再标记，但不一定进入物理磁盘。</li><li>事务没有提交的情况下，消息依旧会被服务端持久化，但没有进入到具体的队列之中。</li><li>服务端持久化消息的行为，可以设置为异步，持久化完成会告知服务端。</li><li>持久化数据的删除，只有在消息被通知已经被消费时，才会被移除。<h2 id="2-1-配置介绍"><a href="#2-1-配置介绍" class="headerlink" title="2.1 配置介绍"></a>2.1 配置介绍</h2>  ActiveMQ每一个服务节点都是一个独立的进程。<table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td>systemUsage</td><td>表示进程级别的容量设置</td></tr><tr><td>memoryUsage</td><td>子标记设置节点的“可用内存限制”，内存容量供所有队列使用</td></tr><tr><td>storeUsage</td><td>标记节点的用于存储“持久化消息”的“可用磁盘空间”，采用数据库存储方案，该参数无作用</td></tr><tr><td>tempUsage</td><td>设置“temp store”的可用磁盘空间限制</td></tr></tbody></table></li></ul><h1 id="3-存储方案"><a href="#3-存储方案" class="headerlink" title="3.存储方案"></a>3.存储方案</h1><h2 id="3-1-KahaDB"><a href="#3-1-KahaDB" class="headerlink" title="3.1 KahaDB"></a>3.1 KahaDB</h2><h3 id="3-1-1-基本结构"><a href="#3-1-1-基本结构" class="headerlink" title="3.1.1 基本结构"></a>3.1.1 基本结构</h3><p>emsp;emsp;KahaDB基于文件系统，支持事务，是目前ActiveMQ默认的持久化存储方案。<br>基本元素：</p><ul><li><p>Metadata Cache：用于在内存中检索消息的存储位置</p></li><li><p>Data log：记录消息内容，默认大小为32M，当其内部所有消息被成功消费后，该文件会在Metadata Cache中被标记为删除，在下一个checkpoint周期进行删除操作。Data log文件采用顺序写的方式操作，为保证物理上的连接，文件需要进行区域预占。</p></li><li><p>Metadata Store：在磁盘上检索消息存储位置。内存中没有被处理的消息索引会以一定周期，同步到Metadata Store中。</p></li><li><p>redo文件：用于系统异常关闭后恢复Btree结构</p><h3 id="3-1-2-配置KahaDB"><a href="#3-1-2-配置KahaDB" class="headerlink" title="3.1.2 配置KahaDB"></a>3.1.2 配置KahaDB</h3><p>  ActiveMQ会默认启动KahaDB。</p><pre><code>&lt;broker xmlns="http://activemq.apache.org/schema/core"  brokerName="localhost" dataDirectory="${activemq.data}"&gt;  ......  &lt;persistenceAdapter&gt;      &lt;kahaDB directory="${activemq.data}/kahadb" journalMaxFileLength="64mb" indexWriteBatchSize="500"/&gt;  &lt;/persistenceAdapter&gt;  ......&lt;/broker&gt;</code></pre></li><li><p>journalMaxFileLength：表示设置后的信息文件大小</p></li><li><p>indexWriteBatchSize：表示Metadata Cache 和 Metadata Store进行checkpoint同步的上限</p></li></ul><h2 id="3-2-LevelDB"><a href="#3-2-LevelDB" class="headerlink" title="3.2 LevelDB"></a>3.2 LevelDB</h2><h3 id="3-2-1-基本结构"><a href="#3-2-1-基本结构" class="headerlink" title="3.2.1 基本结构"></a>3.2.1 基本结构</h3><p>  核心的设计算法是<strong>跳跃表</strong>，核心操作策略是对磁盘上的数据日志结构进行归并（LSM）。</p><p>  结构元素如下：<br>|名称|简介|<br>|–|–|<br>|Log 文件|新的消息进入时，直接写log文件目的是系统异常时能够进行数据的恢复，采用预占磁盘空间的形式顺序写入，可设置为异步，有丢失数据风险|<br>|MemTable/Immutable|新的消息进入时，会写入MemTable，内部数据组织结构就是跳跃表。当内部数据大于一定参数值时，会被标记为Immutable，开启一个新的MemTable,Imuutable的“删除”数据会被剔除，其余可能压缩写入到.sst文件中|<br>|SStable|位于硬盘，后缀为.sst，默认大小为2M,因其按照数据的key排序随机写，固无需预占磁盘空间<br>SSTable文件也分层次，每层为上层的十倍，某曾达到最大值时，选取一个文件做Compact操作<br>读写SSTable的最小单元是Block，大小为4KB，最后的Index Block指明每SSTable一个Data Block的起始位置<br>LevelDB的内存区域，存在Block Cache区域，存储众多的Index Block|<br>|Manifest|该文件记录sst文件的关键信息，包括：某个.sst文件属于哪一个Level，最小key值是多少，最大key值是多少等|</p><h3 id="3-2-2-配置LevelDB"><a href="#3-2-2-配置LevelDB" class="headerlink" title="3.2.2 配置LevelDB"></a>3.2.2 配置LevelDB</h3><pre><code>&lt;persistenceAdapter&gt;    &lt;levelDB directory="${activemq.data}/levelDB" logSize="52428800" sync="false"/&gt;&lt;/persistenceAdapter&gt;</code></pre><ul><li>directory：LevelDB的结构文件所放置的目录位置</li><li>logSize：默认大小为100M，采用预占用磁盘，即一旦消息进入，就会有100MB被预先占用。</li><li>sync：异步写log，异步在内存区域向Memtable写入位置索引。<h2 id="3-3-关系型数据库"><a href="#3-3-关系型数据库" class="headerlink" title="3.3 关系型数据库"></a>3.3 关系型数据库</h2>  ActiveMQ支持使用关系型数据库进行持久化存储–通过JDBC实现数据库的连接。<br>mysql数据库配置如下：</li></ul><pre><code>&lt;broker&gt;     &lt;persistenceAdapter&gt;        &lt;jdbcPersistenceAdapter dataSource="#mysql_datasource" createTablesOnStartup="true"/&gt;    &lt;/persistenceAdapter&gt;&lt;/broker&gt;&lt;bean id="mysql_datasource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;  &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;  &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/activemqdb?relaxAutoCommit=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8"/&gt;  &lt;property name="user" value="root"/&gt;  &lt;property name="password" value="123456"/&gt;  &lt;property name="minPoolSize" value="10"/&gt;  &lt;property name="maxPoolSize" value="30"/&gt;  &lt;property name="initialPoolSize" value="10"/&gt;&lt;/bean&gt;</code></pre><p><strong>备注：</strong>使用关系型数据库，需要将相关jar包放置到安装路径下的./lib目录下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计：ActiveMQ学习(一)</title>
      <link href="/2019/09/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AActiveMQ%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/09/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AActiveMQ%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  ActiveMQ是Apache软件基金会的开源产品，支持AMQP协议、MQTT协议、Openwire协议和Stomp协议等多种消息协议,并且支持JMS API接口规范。</p><h1 id="2-基本参数"><a href="#2-基本参数" class="headerlink" title="2. 基本参数"></a>2. 基本参数</h1><table><thead><tr><th>参数名称</th><th>参数介绍</th></tr></thead><tbody><tr><td>stop</td><td>停止当前ActiveMQ节点的运行</td></tr><tr><td>restart</td><td>重启当前的ActiveMQ节点</td></tr><tr><td>status</td><td>仅展示当前节点是处于运行还是停止</td></tr><tr><td>console</td><td>使用控制台启动ActiveMQ节点</td></tr><tr><td>dump</td><td>采用console启动ActiveMQ,使用dump参数，可获取当前线程的快照</td></tr></tbody></table><h1 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3.工作机制"></a>3.工作机制</h1><p>  ActiveMQ有两种不同的模式队列：<strong>Topic订阅-发布模式，Queue负载均衡模式。</strong></p><table><thead><tr><th>比较内容</th><th>Topic</th><th>Queue</th></tr></thead><tbody><tr><td>工作模式</td><td>“订阅-发布”模式，如果有多个订阅者，消息会被复制多份进行发送，若没有订阅者，消息将会被丢弃</td><td>“负载均衡”模式，如果有多个消费者，消息只会发送给其中的一个，并且要求ack进行消息的确认，如果没有消费者，消息将会被保存，直到有消费者连接订阅</td></tr><tr><td>持久化</td><td>不会</td><td>数据默认在MQ服务器上以文件形式进行保存，可以配置为DB存储</td></tr><tr><td>传递完整性</td><td>没有订阅者，消息将被丢弃</td><td>没有订阅者，消息被存储</td></tr><tr><td>效率</td><td>处理性能会伴随订阅者数量的增加而降低，并且也要考虑使用的协议性能差异</td><td>仅有一个消费者进行信息的接受，性能不随消费者数量的变化而影响，但也受协议影响</td></tr></tbody></table><h1 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h1><p>  ActiveMQ的优化可以考虑从多个次层入手，如<strong>代码级性能、规则性能、网络性能和集群方案</strong>。</p><h2 id="4-1-网络性能优化"><a href="#4-1-网络性能优化" class="headerlink" title="4.1 网络性能优化"></a>4.1 网络性能优化</h2><p>  ActiveMQ的网络信息传递方式默认是基于网络模型的BIO方式，为提高单点性能，可以为单个节点配置更高效的网络IO模型。<br>  ActiveMQ支持的协议如下：</p><ul><li><strong>AMQP</strong></li><li><strong>MQTT</strong></li><li><strong>OpenWire</strong></li><li><strong>REST</strong></li><li><strong>Stomp</strong></li><li><strong>XMPP</strong></li></ul><p><strong>不同的协议需要设置不同的网络监听端口</strong>，详见./conf/conf/activemq.xml文件。<br><strong>ActiveMQ中默认的消息协议是openwire</strong><br>在5.13.0+版本后，OpenWire，Stomp，AMQP，MQTT四种协议的端口监听进行了合并，使用auto关键字进行表示。ActiveMQ将会监听这一个端口的消息状态，匹配合适的协议格式,优化使得连接管理变的简洁，但没有提升单节点的处理性能。</p><pre><code>&lt;transportConnectors&gt;    &lt;transportConnector name="auto" uri="auto://0.0.0.0:61617?maximumConnections=1000" /&gt;&lt;/transportConnectors&gt;</code></pre><p>端口默认使用BIO网络IO模型，为提高单节点吞吐量，可以指定网络模型为nio：</p><pre><code>&lt;transportConnectors&gt;      &lt;transportConnector name="nio" uri="nio://0.0.0.0:61618?maximumConnections=1000"/&gt;  &lt;/transportConnectors&gt;</code></pre><p>让某一端口支持NIO和协议：</p><pre><code>&lt;transportConnector name="stomp+nio" uri="stomp+nio://0.0.0.0:61613?transport.transformer=jms"/&gt;// 表示这个端口使用NIO模型支持Stomp协议</code></pre><p>让某一端口支持NIO网络和多协议：</p><pre><code>&lt;transportConnector name="auto+nio" uri="auto+nio://0.0.0.0:61608?maximumConnections=1000" /&gt;</code></pre><p>每一种协议都有一些特定的参数，各协议也包含共用的参数，具体详见官方文档<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ官网</a></p><h2 id="4-2-处理规则和优化"><a href="#4-2-处理规则和优化" class="headerlink" title="4.2 处理规则和优化"></a>4.2 处理规则和优化</h2><h3 id="4-2-1-JMS规范概念"><a href="#4-2-1-JMS规范概念" class="headerlink" title="4.2.1 JMS规范概念"></a>4.2.1 JMS规范概念</h3><p>   ActiveMQ是JMS规范的完整实现，故其调度与存储等原理与JMS中的概念原理相关。JMS的相关概念如下表：</p><ul><li>订阅发布与负载均衡模式<br>详见ActiveMQ的工作机制。</li><li>持久化消息和非持久化</li></ul><table><thead><tr><th>差异</th><th>持久化（PERSISTENT）</th><th>非持久化（NON_PERSISTENT）</th></tr></thead><tbody><tr><td>存储位置</td><td>不受JMS服务端异常状态的影响，服务端会持久化保存消息，直到被处理</td><td>只存储在JMS服务节点的内存区域</td></tr><tr><td>持久化方案</td><td>KahaDB、AMQ和关系型数据库</td><td>无</td></tr><tr><td>宕机</td><td>数据保存</td><td>数据丢失</td></tr><tr><td>策略</td><td>无</td><td>内存区域不足时，采用辅助方案进行转存（ActiveMQ使用临时存储区域）</td></tr></tbody></table><ul><li>持续订阅和非持续订阅<br>是针对<strong>“订阅-发布”</strong>模式的细分处理策略<ul><li>持续订阅（Durable-subscribers）被标记的用户获取某条消息和它曾经下线没有任何关系，Topic会保存该消息，直到订阅者上线，该消息被正确处理为止。</li><li>非持久化订阅（Non-Durable-subscribers）Topic不再为下线的订阅者保留消息，发送给在线的消费者之后就可以标记为“处理完成”。</li></ul></li></ul><h3 id="4-2-2-生产者与消费者优化"><a href="#4-2-2-生产者与消费者优化" class="headerlink" title="4.2.2 生产者与消费者优化"></a>4.2.2 生产者与消费者优化</h3><h4 id="4-2-2-1-生产者（producer）"><a href="#4-2-2-1-生产者（producer）" class="headerlink" title="4.2.2.1 生产者（producer）"></a>4.2.2.1 生产者（producer）</h4><p>  生产者发送消息支持<strong>同步发送</strong>和<strong>异步发送</strong>。在消息产生堆积的情况下，补不能一味只追求发送效率。<br>  处理消息堆积的基本原则是：</p><ul><li><strong>持久化状态</strong>：无论如何消息总会被持久化存储，再视情况进行发送。完成消息的存储后，服务节点<strong>会</strong>向生产者发送回执确认消息。</li><li><strong>非持久化状态</strong>：在内存中产生消息堆积后，会进行消息的转储到Temp store区域。完成消息的存储后，服务节点<strong>不会</strong>向生产者发送回执确认消息。<br>以上两种，如果区域也产生堆积，则会通知生产者开启Slow Producer机制。</li></ul><h5 id="4-2-2-1-1-生产者消息发送"><a href="#4-2-2-1-1-生产者消息发送" class="headerlink" title="4.2.2.1.1 生产者消息发送"></a>4.2.2.1.1 生产者消息发送</h5><p>   生产者默认发送的消息是<strong>持久化类型</strong>，非持久化消息需要明确指明，并且非持久的消息发送默认方式为<strong>异步方式</strong>，即消息存储之后默认不会发送回执消息给生产者。</p><p><strong>注意</strong>：异步模式下，在生产者发送一定量的消息后，也需要等待服务端的消息回执,否则会导致消息堆积，需要进行相关配置，仅限异步模式下，是必须配置的。</p><pre><code>    //以下语句设置消息发送者在累计发送102400byte大小的消息后（可能是一条消息也可能是多条消息    connectionFactory.setProducerWindowSize(102400);</code></pre><p>使用以下配置可以异步条件下每次消息的存储都返回回执信息：</p><pre><code>//会降低消息发送的效率    connectionFactory.setAlwaysSyncSend(true);</code></pre><p>在发送持久化消息时，也可以设置为异步方式。</p><pre><code>//发送持久化消息时设置的异步    connectionFactory.setUseAsyncSend(true);    //因此异步模式下也要设置回执窗口    connectionFactory.setProducerWindowSize(102400);</code></pre><p><strong>小结：</strong></p><table><thead><tr><th>比较</th><th>持久化（系统默认）</th><th>非持久化</th></tr></thead><tbody><tr><td>默认方式</td><td>同步发送</td><td>异步发送</td></tr><tr><td>改为同步</td><td>每次进行消息回执<br>connectionFactory.setAlwaysSyncSend(true);</td><td></td></tr><tr><td>改为异步</td><td>connectionFactory.setUseAsyncSend(true);<br>设置回执窗口<br>connectionFactory.setProducerWindowSize(102400);</td><td>并非改为同步<br>异步模式下需要设置回执connectionFactory.setProducerWindowSize(102400);</td></tr></tbody></table><h5 id="4-2-1-1-2-生产者事务"><a href="#4-2-1-1-2-生产者事务" class="headerlink" title="4.2.1.1.2 生产者事务"></a>4.2.1.1.2 生产者事务</h5><p>  事务由消息发送者发起，会在连接会话中设置一个Transaction ID,之后可以在事务中发送多条消息。事务未提交之前，消息已经被服务端所接受，但不会进入队列（发现有Transaction ID），消息会被先放置在“transaction store”中，该区域存在“redo”日志，用于事务的回滚。事务在被提交之后，服务端根据自身的规则（持久化还是非持久化）进行消息的入队操作（无论订阅-发布模式还是负载均衡模式）。</p><h5 id="4-2-1-1-3-生产者策略"><a href="#4-2-1-1-3-生产者策略" class="headerlink" title="4.2.1.1.3 生产者策略"></a>4.2.1.1.3 生产者策略</h5><p>  ProducerFlowControl 生产控制流，当发生消息堆积时，生产者收到服务端的回执消息，服务端会让生成者进入<strong>等待状态</strong>或者直接<strong>抛出JMSException</strong>异常。<br>  关闭订阅-发布的生产控制流</p><pre><code> &lt;policyEntry topic="&gt;" producerFlowControl="false"/&gt;</code></pre><p>  启用负载均衡的生产控制流</p><pre><code>&lt;policyEntry queue="&gt;" producerFlowControl="true" memoryLimit="200mb"&gt;</code></pre><p>memoryLimit 表示每个Queue信息的最大内存存储限制，指最多使用200MB的内存区域，非消息总和。</p><h4 id="4-2-2-2-消费者（consumer）"><a href="#4-2-2-2-消费者（consumer）" class="headerlink" title="4.2.2.2 消费者（consumer）"></a>4.2.2.2 消费者（consumer）</h4><p>  相比较于生产者，消费者的性能会更加影响ActiveMQ系统的整体性能。</p><h5 id="4-2-2-2-1-消费者消息接收"><a href="#4-2-2-2-1-消费者消息接收" class="headerlink" title="4.2.2.2.1 消费者消息接收"></a>4.2.2.2.1 消费者消息接收</h5><p>  默认情况下，ActiveMQ服务端采用异步的方式向消费者推送消息，即服务端不会一直等待消费者响应，消费者完成消息处理之后，主动发送状态到服务端。<br>  将推送设置为同步：</p><pre><code>connectionFactory.setDispatchAsync(false);</code></pre><p>  服务端推送消息给消费者，存在推送数量限制，即“预期数量”PrefetchSize。ActiveMQ的默认策略是一旦有新的消息，就主动按照设置的规则推送给当前活动的消费者。<br>   针对不同的工作机制，不同的存储方案，服务端有不同的预期数量设置：</p><table><thead><tr><th></th><th>Queue</th><th>Topic</th></tr></thead><tbody><tr><td>持久化</td><td>1000</td><td>100</td></tr><tr><td>非持久化</td><td>1000</td><td>32766</td></tr></tbody></table><ul><li>通过ActiveMQPrefetchPolicy变更预取数量</li></ul><pre><code>// 预取策略对象ActiveMQPrefetchPolicy prefetchPolicy = connectionFactory.getPrefetchPolicy();// 设置Queue的预取数量为50prefetchPolicy.setQueuePrefetch(50);connectionFactory.setPrefetchPolicy(prefetchPolicy);</code></pre><ul><li>更改Properties属性变更预取数量<pre><code>Properties props = new Properties();props.setProperty("prefetchPolicy.queuePrefetch", "1000");props.setProperty("prefetchPolicy.topicPrefetch", "1000");//设置属性connectionFactory.setProperties(props);</code></pre><h5 id="4-2-2-2-2-消费者事务"><a href="#4-2-2-2-2-消费者事务" class="headerlink" title="4.2.2.2.2 消费者事务"></a>4.2.2.2.2 消费者事务</h5>  消费者采用事务告知服务器一组消息是否处理成功，要么全部处理成功，要么失败全部进行回滚。<br>  调用回滚时，回滚之前的数据将会被重新进行发送，并且在同一个会话之中。消息的重发计数器（redeliveryCounter）属性将会加1.</li></ul><h5 id="4-2-2-2-3-死信队列"><a href="#4-2-2-2-3-死信队列" class="headerlink" title="4.2.2.2.3 死信队列"></a>4.2.2.2.3 死信队列</h5><p>  一条消息失败，会进行回滚重发，一旦重发次数达到一定的策略值（默认为6次），该消息将会被加入到死信队列。</p><ul><li>非持久化策略下，消息超过重发上限，将会被删除</li><li>默认情况下持久化策略下，消息会加入到死信队列<br>  设置非持久化也加入到死信队列：</li></ul><pre><code>&lt;policyEntry queue="&gt;"&gt;      &lt;deadLetterStrategy&gt;          &lt;sharedDeadLetterStrategy processNonPersistent="true" /&gt;      &lt;/deadLetterStrategy&gt;  &lt;/policyEntry&gt;</code></pre><p>  修改默认的重发次数：</p><pre><code>RedeliveryPolicy redeliveryPolicy = connectionFactory.getRedeliveryPolicy();// 设置最大重发次数redeliveryPolicy.setMaximumRedeliveries(3);</code></pre><p>  触发重发的三种机制：</p><table><thead><tr><th>描述</th><th>重发计数器的作用域</th></tr></thead><tbody><tr><td>在消费者连接会话中调用回滚</td><td>本次连接会话</td></tr><tr><td>在消费者连接会话中，commit之前，连接终止</td><td>整个ActiveMQ系统范围</td></tr><tr><td>在发送ACK告知服务器之前，连接终止</td><td>整个ActiveMQ系统范围</td></tr></tbody></table><h5 id="4-2-2-2-4-消费者acknowledge策略"><a href="#4-2-2-2-4-消费者acknowledge策略" class="headerlink" title="4.2.2.2.4 消费者acknowledge策略"></a>4.2.2.2.4 消费者acknowledge策略</h5><p>  消费者端通知服务器的两种方式：<strong>事务</strong>和<strong>acknowledge</strong><br>  acknowledge模式的四种方式：</p><table><thead><tr><th>参数</th><th>简介</th></tr></thead><tbody><tr><td>AUTO_ACKNOWLEDGE</td><td>连接会话会自动认为消费者端对消息的处理时成功的，无论是服务端主动推送还是消费者端主动拉取，但消费端不一定是逐条进行ACK</td></tr><tr><td>CLIENT_ACKNOWLEDGE</td><td>同上场景，但必须要进行ACK确认，否则认为消息没有处理成功</td></tr><tr><td>DUPS_OK_ACKNOWLEDGE</td><td>批量确认方式，消费端依据策略间隔发送ack，表示一批消息处理完成</td></tr><tr><td>INDIVIDUAL_ACKNOWLEDGE</td><td>单独确认方式，消费者端逐条发送ack确认消息，性能较差</td></tr></tbody></table><p><strong>备注</strong>：</p><ul><li>推荐使用AUTO_ACKNOWLEDGE + optimizeACK，该优化选项只有在AUTO_ACKNOWLEDGE的模式下生效，目的在于“延迟确认”，当消息的数量达到策略值，通过ack告知服务端，这批消息处理完成。<strong>数量阈值为：prefetch*0.65, 时间阈值为：&gt; optimizeAcknowledgeTimeOut</strong></li><li>DUPS_OK_ACKNOWLEDGE 在<strong>负载均衡模式</strong>下和AUTO_ACKNOWLEDGE是一致的。</li><li>AUTO_ACKNOWLEDGE 下 如果prefetchSize = 1,也会进行逐条确认</li><li>如果是<strong>发布-订阅模式</strong>，阈值&gt;= prefetch*0.5时，都会进行批量确认。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计：AMQP协议</title>
      <link href="/2019/08/30/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AAMQP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/30/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AAMQP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  AMQP协议的全称是：Advanced Message Queuing Protocol（高级消息队列协议）。目前AMQP协议的版本为 Version 1.0，是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><h1 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2. 协议结构"></a>2. 协议结构</h1><p>  AMQP协议结构如下：</p><p><img src="/2019/08/30/架构设计：AMQP协议学习/AMQP1.PNG" alt=""></p><ul><li>由上图可以看出，AMQP结构的构成分为六块<ul><li><strong>Message</strong>：消息体</li><li><strong>Producer</strong>：生产者</li><li><strong>Consumer</strong>：消费者</li><li><strong>Virtual Host</strong>：虚拟节点</li><li><strong>Exchange</strong>：交换机</li><li><strong>Queue</strong>：队列<ul><li>AMQP的客户端由<strong>Producer</strong>和<strong>Consumer</strong>组成，服务端Broker则是由Virtual Host，Exchange和Queue组成。</li></ul></li></ul></li><li><strong>Message</strong>的传递需要客户端（Producer和Consumer）创建连接到Broker的连接Connection，之后由客户端在Connection之上建立channel通道连接到Virtual host或者Queue上。Connection支持多个Channel的建立，消息的发送与接受只有在channel上才能进行。</li><li><strong>Exchange</strong>作为协议中的交换机，可以和多个Queue以及Exchange进行绑定，消息会根据Exchange上的路由规则进行发送传播。Exchange要至少和一个Queue或者Exchange绑定关系，并且设置好Queue和Exchange的Routing（路由规则），Exchange根据路由规则发送消息到符合路由规则的Queue或Exchange中，路由规则可以和Message中的Routing key属性配合使用。Exchange的路由规则包含三种：<strong>Direct、Fanout、Topic</strong></li><li><strong>Queue</strong>对于消息的处理，没有channel连接到Queue时，消息将会被存储，知道channel被创建，如果channel已经创建，消息按顺序发送给channel</li><li><strong>Consumer</strong>在收到消息后，需要手动（可以设置自动发送和无需发送）发送一条ACK回应消息给对应的Queue，Queue接收到后，会将该消息移除掉，在channel断开之前Queue若未能收到消息，则该消息会被发送给其他的channel。发送NACK，消息会发送给其他channel，不论当前channel是否已经断开。<h1 id="3-消息格式"><a href="#3-消息格式" class="headerlink" title="3.消息格式"></a>3.消息格式</h1>  作为一种网络通讯协议，AMQP工作在七层/五层网路模型的应用层。其消息真正的内容主要在PAYLOAD区域，即交付区，非PAYLOAD区，在网络协议的应用层说明Channel的工作状态。<br>PAULOAD区域共七个数据区域：<table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>header</td><td>记录AMQP消息在“支持AMQP的中间件”中的交互状态，如消息在节点间被交互的总次数，优先级，TTL值等信息</td></tr><tr><td>delivery-annotations</td><td>在header部分只能传递规范的、标准的、经过ISO/IEC组织定义过的属性。所以对应这里用来记录“非标”的header信息</td></tr><tr><td>message-annotations</td><td>用于存储一些自定义的辅助属性，主要用于消息的转换</td></tr><tr><td>properties</td><td>AMQP消息的正文内容是从properties到application-data部分，properties记录了消息正文中标准的，规范的属性，例如消息ID，分组ID,发送者ID等</td></tr><tr><td>application-properties</td><td>主要记录和应用有关的数据，该协议的实现产品需要用这部分数据决定其处理逻辑，例如消息的Routing是什么，是否进行持久化等</td></tr><tr><td>application-data</td><td>使用二进制格式描述的AMQP消息的用户部分内容，即发送的真实内容</td></tr><tr><td>footer</td><td>一般用来存储辅助内容，如消息的哈希值，HMAC，签名或加密细节</td></tr></tbody></table></li></ul><h1 id="3-Exchange路由规则"><a href="#3-Exchange路由规则" class="headerlink" title="3. Exchange路由规则"></a>3. Exchange路由规则</h1><table><thead><tr><th>规则命称</th><th>区别</th></tr></thead><tbody><tr><td>Direct路由</td><td>该模式下Exchange将使用消息中所携带的Routing key 和Queue中的Routing key进行比较，如果匹配，该消息进入该队列</td></tr><tr><td>Fanout</td><td>Exchange接受消息后，会将消息赋值多份，发送到自己绑定的Exchange和Queue中，不需要Routing key</td></tr><tr><td>Topic路由</td><td>Exchange将支持‘#’和’*‘通配符进行Routing key的匹配查找</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计：Stomp协议</title>
      <link href="/2019/08/28/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AStomp%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/28/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9AStomp%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  消息从发送到接受的方式有两种：一种称为<strong>即时消息通讯</strong>，即一端发送之后，另一端能够立即接受 ，具体实现就是RPC。另一种称为<strong>延迟消息通讯</strong>，即消息发出后，进入中间容器进行存储，到达一定条件之后，再发送给接受者，中间的容器称为<strong>消息队列</strong>。<br>  <strong>Stomp协议</strong>，英文全名<strong><em>Streaming Text Orientated Message Protocol</em></strong>，中文名称为 ‘流文本定向消息协议’。是一种以纯文本为载体的协议，前身是TTMP协议，专为消息中间件设计。<br>  <strong>Stomp协议属于延迟消息通讯</strong><br>  目前的版本为V1.1和V1.2</p><h3 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2.协议结构"></a>2.协议结构</h3><p>  标准的协议包括：<strong>命令/关键信息，头信息，文本内容</strong></p><pre><code>CONNECT    //命令accept-version:1.2  //版本号（头信息）param1:value1param2:value2this is stomp    //文本内容</code></pre><p>  Stomp协议由两个角色组成：<strong>客户端(Client)</strong>和<strong>消息代理(Broker)</strong></p><p><img src="/2019/08/28/架构设计：Stomp协议学习/1566985233886.png" alt=""></p><p>  <strong>消息代理（Broker）</strong>只负责接受和存储客户端发送的消息，依据客户端要求的路径进行转发，对消息内容不做任何处理，只负责客户端连接和订阅</p><h3 id="3-交互流程及命令"><a href="#3-交互流程及命令" class="headerlink" title="3. 交互流程及命令"></a>3. 交互流程及命令</h3><p>   交互流程大致如下图：<br><img src="/2019/08/28/架构设计：Stomp协议学习/1566986429790.png" alt=""></p><ul><li><strong>CONNECT/STOMP</strong>：客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</li><li><strong>CONNECTED</strong>：代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</li><li><strong>SEND</strong>：客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</li><li><strong>BEGIN</strong>：Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</li><li><strong>COMMIT</strong>：提交事务。使得事务中的一条或多条消息进入Stomp代理队列</li><li><strong>ABORT</strong>：取消/终止当前还未COMMIT的事务。</li><li><strong>SUBSCRIBE</strong>：订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</li><li><strong>UNSUBSCRIBE</strong>：取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</li><li><strong>ACK</strong>：若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</li><li><strong>NACK</strong>：若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</li><li><strong>DISCONNECT</strong>：断开客户端和消息代理之间的连接</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong>CONNECT/STOMP</strong></td><td>客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</td></tr><tr><td><strong>CONNECTED</strong></td><td>代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</td></tr><tr><td><strong>SEND</strong></td><td>客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</td></tr><tr><td><strong>BEGIN</strong></td><td>Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</td></tr><tr><td><strong>COMMIT</strong></td><td>提交事务。使得事务中的一条或多条消息进入Stomp代理队列</td></tr><tr><td><strong>ABORT</strong></td><td>取消/终止当前还未COMMIT的事务</td></tr><tr><td><strong>SUBSCRIBE</strong></td><td>订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</td></tr><tr><td><strong>UNSUBSCRIBE</strong></td><td>取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</td></tr><tr><td><strong>ACK</strong></td><td>若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</td></tr><tr><td><strong>NACK</strong></td><td>若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</td></tr><tr><td><strong>DISCONNECT</strong></td><td>断开客户端和消息代理之间的连接</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql深入之分库</title>
      <link href="/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%BA%93/"/>
      <url>/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  大多数的数据库设计往往是一台主库负责数据的写入，多台从库同步主库数据仅提供读数据，但随着业务的增长，主库的写压力会与日俱增，这时往往通过分库+分布式的架构来缓解来自业务数据增长带来的压力，但同时也会引发数据的一致性和事务等诸多问题。</p><h3 id="2-分库"><a href="#2-分库" class="headerlink" title="2.分库"></a>2.分库</h3><p>  数据库的拆分同样也可以分为两种<strong>垂直拆分</strong>和<strong>水平拆分</strong><br>  <strong>垂直拆分</strong>是分库的首选，其分库方式较为简单，因其的依据在于业务的整体架构，可以将独立不相关的业务模块的表迁移到不同的库中，要求数据的增长速度比较平稳。<br>  <strong>水平拆分</strong>复杂度较高，往往会涉及<strong>分表</strong>。<br>  拆分思路：</p><ul><li>按算法对应<br>  将数据的主键按照固定的算法进行分类，放置到不同的数据库中，实现较为方便，但扩展性较差，后续节点收缩或算法变动会造成很大的数据集迁移。</li><li>按索引映射表对应<br>  即建立数据主键与所在数据库的关系表，每次数据请求先去该表查取，再到具体的数据库获取数据，优势在于伸缩性，新的数据进来，只需要放入合适的库中，在关系表上添加对应的记录便可。缺点在于会增加数据库的访问次数。<h3 id="3-分库面临的问题"><a href="#3-分库面临的问题" class="headerlink" title="3.分库面临的问题"></a>3.分库面临的问题</h3></li><li>不能跨库关联查询<br>  当关联数据分布在不同的数据库中或者获取级联数据时不能进行join操作，解决思路要么数据两边均存储一份（全局表），采用空间换时间，要么只能代码层查询之后再进行聚合，牺牲部分性能</li><li>不能保证数据的一致性<br>  跨库的数据没有外键约束，也没有事务保证。</li><li>所有查询必须提供数据库线索<br>  分库之后的数据可能存在于不同库中，每次数据的操作都需要先定位库的位置。</li><li>自增ID<br>  有时跨库数据可能依赖于数据主键，采取自增主键可能导致不同库的数据录入时主键信息不一致，可以采取第三方表数据生成自增主键为标准，作为相关数据的主键，保证自增的一致性。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理CGLIB</title>
      <link href="/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----CGLIB/"/>
      <url>/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----CGLIB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  CGLIB（Code Generator Library）是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。<br>  CGLIB的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。</p><h2 id="2-CGLIB-实例代码："><a href="#2-CGLIB-实例代码：" class="headerlink" title="2.CGLIB 实例代码："></a>2.CGLIB 实例代码：</h2><pre><code>//被代理类public class User {    public String getUserName(){        System.out.println("this is Tom");        return "Tom";    }}//实现接口public class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println("------beforeExecute");        Object object = methodProxy.invokeSuper(o, objects);        System.out.println("------afterExecute");        return object;    }}//测试类public class CglibTest {    public static void main(String[] args) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(User.class);        enhancer.setCallback(new MyMethodInterceptor());        User userProxy = (User)enhancer.create();        userProxy.getUserName();    }}//结果------beforeExecutethis is Tom------afterExecute</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理JDK</title>
      <link href="/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2019/08/28/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-----JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  学习动态代理，可以先了解一下设计模式中的代理模式。<br>  <a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">设计模式–代理模式</a></p><h2 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2.JDK动态代理"></a>2.JDK动态代理</h2><p>  JDK生成类的过程中比较高效，其基于java内部的拦截器和反射机制实现的，应用的前提是目标类要基于统一的接口</p><h4 id="2-1-使用JDK动态代理的五大步骤："><a href="#2-1-使用JDK动态代理的五大步骤：" class="headerlink" title="2.1 使用JDK动态代理的五大步骤："></a>2.1 使用JDK动态代理的五大步骤：</h4><ul><li>实现InvocationHandler接口，重写自己的invoke方法。</li><li>通过Prxoy.getProxyClass获得代理类的Class</li><li>通过ProxyClazz.getConstructor获得代理类的构造函数</li><li>通过代理类的构造函数，将实现的InvocationHandler实例作为参数进行传递，获得代理类</li><li>代理类调用具体的函数方法</li></ul><p><strong><em>代码如下</em></strong></p><pre><code>//被代理类接口public interface UserService {    String getName();}//被代理类实现类public class UserServiceImpl implements UserService{    @Override    public String getName() {        System.out.println("this is Jerry");        return "Jerry";    }}//InvocationJHandler的实现类public class MyInvocationHandler implements InvocationHandler {    private Object target;    public MyInvocationHandler(){    }    public MyInvocationHandler(Object target) {        super();        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            System.out.println("beforeExecute---" + method.getName());            Object result = method.invoke(target, args);            System.out.println("afterExecute---" + method.getName());            return result;    }}//测试类public class MainTest {    public static void main(String[] args) throws Exception {        //1.获取代理类的class        Class clazz = Proxy.getProxyClass(UserService.class.getClassLoader(), UserService.class);        //2.获取代理类的构造函数        Constructor constructor = clazz.getConstructor(InvocationHandler.class);        //3.通过构造函数，拿到代理对象        UserService userService  = (UserService) constructor.newInstance(new MyInvocationHandler(new UserServiceImpl()));        //4.代理对象调用方法        userService.getName();        //Proxy 提供了静态方法，可以一步获得代理类的执行结果，以上的几步可以整合为一个方法        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(                UserService.class.getClassLoader(),                new Class[]{UserService.class},                new MyInvocationHandler(new UserServiceImpl())        );        userServiceProxy.getName();    }}//执行结果beforeExecute---getNamethis is JerryafterExecute---getNamebeforeExecute---getNamethis is JerryafterExecute---getName</code></pre><h4 id="2-2-补充整理："><a href="#2-2-补充整理：" class="headerlink" title="2.2 补充整理："></a>2.2 补充整理：</h4><p>  在动态代理中，InvocationHandler是核心，每一个代理实例都具有一个关联的调用处理程序，当代理对象生成后，还最后由InvocationHandler的invoke()方法调用目标方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql深入之分表</title>
      <link href="/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E8%A1%A8/"/>
      <url>/2019/08/28/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  mysql中存在一种机制是表锁定（myisam存储引擎）和行锁定（innodb存储引擎），对于一行数据或一张表，同时只能有一条sql进行操作，其他针对该行或该表的执行sql需要进行排队，在高并发情况下，请求执行的sql如果出现骤增，整个系统的性能将会卡在sql的执行效率上。对一些数据庞大的表，可以采取分表策略，将执行的sql进行均匀分布，减少sql等候执行队列的长度，提高数据库的吞吐量。</p><h3 id="2-分表"><a href="#2-分表" class="headerlink" title="2.分表"></a>2.分表</h3><p> 分表依据不同的业务情况可以分为两种切分方式：<strong>垂直切分</strong>和<strong>水平切分</strong>。</p><h5 id="2-1-垂直切分"><a href="#2-1-垂直切分" class="headerlink" title="2.1 垂直切分"></a>2.1 垂直切分</h5><p> 垂直切分的场景是，表中属性很多，但是基本上是核心的几个属性的操作频率很高，其他的属性平时不怎么需要获取到。</p><ul><li>将长度较短，访问频率高的属性可以放到一个表中，暂且称为主表。</li><li>将长度较短，访问频率低的属性放到一个表中，暂且称为扩展表。</li><li>也可以将经常一起访问的属性，放置到同一表中，具体视业务而定。</li></ul><p> 数据库有自身的内存buffer，会将磁盘上的数据load到内存buffer中，其单位是以row为单位的，在内存有限的情况下，缓存越短的row，就能缓存更多的数据，提高缓存命中率，减少磁盘访问，有效提高操作效率。</p><p><strong>缺点：</strong></p><ul><li>会造成一定量的冗余列</li><li>查询所有数据需要进行join操作，如果进行了分库，表在不同库或服务器，将会增加访问数据库次数。<h5 id="2-2-水平切分"><a href="#2-2-水平切分" class="headerlink" title="2.2 水平切分"></a>2.2 水平切分</h5> 水平切分场景是，单表的数据量很大，执行多条sql会造成排队较长，整体的执行效率降低。这时需要将表中行数据按照一定的规则进行进行划分，创建多个子表，<strong>分表不同于分区，mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对应三个文件，.MYD数据文件，。MYI索引文件，。FRM表结构文件</strong>。这样就能保证sql的执行是在不同的表中，读取的时候从各自的表中进行读取，降低了单表的sql执行的排队长度。</li></ul><p><strong>缺点：</strong></p><ul><li>当分配规则确定后，打破这条规则很麻烦，可能会导致相同的数据，因为规则不同而出现在不同的表中。</li><li>同库不同表数据需要进行union操作</li><li>不同库不同表将会增加数据库访问次数</li></ul><p><strong>利用merge存储引擎分表</strong><br> 把已有的大数据量的表进行切分的确非常困难，可能涉及到要修改代码中大量的sql，利用merge存储引擎分表将会在数据库层面进行表的切分，而对外程序的中依旧是该主表，不需要代码中sql的修改，但仅限于MyISAM存储引擎，采用InnoDB引擎的表不适用。<br> 具体代码如下：</p><pre><code># 分表1CREATE TABLE user_1(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50)) ENGINE=MYISAM#分表2CREATE TABLE user_2(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50)) ENGINE=MYISAM# merge表挂载分表CREATE TABLE USER(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50))  ENGINE=MERGE UNION=(user_1,user_2) INSERT_METHOD=LAST;</code></pre><ul><li><strong>ENGINE=MERGE</strong> 指明merge表使用MERGE引擎</li><li><strong>UNION=(user_1,user_2)</strong> 指明merge表挂载了哪些表</li></ul><pre><code>#该sql用于移除user_2的挂载ALTER TABLE USER ENGINE=MERGE UNION=(user_1) INSERT_METHOD=LAST </code></pre><ul><li><strong>INSERT_METHOD=LAST</strong> 指明输入插入的方式，0表示不允许数据插入，<strong>FIRST</strong>将会插入UNION的第一个分表中，<strong>LAST</strong>将会插入UNION的最后一个分表中</li><li>如上sql所示，merger表和其他的分表结构必须保持一致，包括同样的索引。</li><li>一个merge表不能在整个表上维持unique约束，若merge存在重复主键，按主键查询，获取一条记录便会停止。后续重复主键的数据将无法插入，即只保证挂载之后主键的唯一性。</li><li>若分表存在自增主键，merge表新数据的插入自增将会从分表中最大的主键开始自增。即user_1最大自增主键为10，user_2为20，则merge表数据的主键将会从21开始。</li></ul><p><strong>推荐：利用merge存储引擎分表，可以先有一张merge表，且只挂载一个分表，当分表的数据到达一定的数量级之后，再建立新的分表进行挂载，数据将会插入到新分表中</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql深入之分区</title>
      <link href="/2019/08/27/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%8C%BA/"/>
      <url>/2019/08/27/MySql%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>  日常开发中经常会遇到数据库的一些大表，即单表数据存储可能是百万级甚至千万级并且字段非常多，由于表数据的庞大，会导致在数据检索和变更方面的效率很低，如果SQL复杂，级联表众多，其运行性能会变的非常糟糕。使得数据库在高并发情况下成为系统的性能瓶颈。一定程度的分区分表，甚至在分布式情况下的分库等，能有效提升数据库的效率，但凡事均有度，分区分表过多，会造成内存占用升高，以及主从之间数据的一致性问题等等，怎样分区分表，分多少合适，还是要基于现实的业务情况进行选择处理。</p><h3 id="2-分区"><a href="#2-分区" class="headerlink" title="2.分区"></a>2.分区</h3><p>  分区允许通过设置需要的规则在文件系统中分布存储单个表的各个部分。实际上就是表的不同部分作为单独的表存储在不同的位置，Mysql5.1引入的，是一种简单的<strong>水平拆分</strong>，在建表时加上分区参数，对应用是透明的，无需代码的修改。分区本质上是将数据底层的存储块变多，在数据库层面依旧是一张表。</p><p>  目前的mysql8.0中，唯一支持分区的存储引擎是InnoDB和NDB。分区不能与不支持分区的存储引擎一起使用，这些引擎包括MyISAM、MERGE、CSV和FEDERATED存储引擎。</p><p>  分区可以分为两种：<strong>水平分区</strong>和<strong>垂直分区</strong></p><ul><li>水平分区，通常是对表的行进行分区，将不同的行数据进行切割，但表中定义的列在每个数据集中都能找到，只是根据规则将不同的行数据存储在不同的存储块中。</li><li>垂直分区，通过对表的垂直划分来减少目标表的宽度，使得特定的列被划分到特定的分区，每个分区都包含了该列所对应的所有的行</li></ul><p><strong>分区的本质是单表数据在物理层存储的改变，目前mysql还不支持垂直分区，网上大多数将垂直分区和垂直分表混为一谈。</strong></p><p>  <strong>水平分区的四大类型</strong></p><ul><li>范围分区（Range）</li><li>列表分区（List）</li><li>哈希分区（Hash）</li><li>Key分区<h5 id="2-1-Range分区"><a href="#2-1-Range分区" class="headerlink" title="2.1 Range分区"></a>2.1 Range分区</h5>   把一个连续的区间进行划分，把多行分配给分区，常见的字段为自增的主键ID,或者是时间等，基于分区的列最好是整型。</li></ul><pre><code>CREATE TABLE `sql_range` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY RANGE (id)(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN (30),    PARTITION p4 VALUES LESS THAN (40),    PARTITION p5 VALUES LESS THAN (MAXVALUE))-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- range添加新分区alter table &lt;table&gt; add partition(partition p4 values less than MAXVALUE);-- range重新分区ALTER TABLE user REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES LESS THAN MAXVALUE);</code></pre><p><strong><em>注意</em></strong>：</p><ul><li>按照时间范围分区时，转换函数最好使用UNIX_TIMESTAMP 而不是TIMESTAMP</li><li>对于null值，Range分区会将其作为最小分区值存储<h5 id="2-2-List分区"><a href="#2-2-List分区" class="headerlink" title="2.2 List分区"></a>2.2 List分区</h5>  类似于Range分区，但区别在于List分区是一个枚举值列表的集合，而非区间，建议分区为非null列，否则插入null，而集合中不包含，则会报错。另外，List分区只支持整型。</li></ul><pre><code>CREATE TABLE `sql_list` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY LIST (id)(    PARTITION p1 VALUES IN (1,3,5),    PARTITION p2 VALUES IN  ('a','b'))会报错：VALUES value for partition 'p2' must have type INT-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- list添加新分区alter table &lt;table&gt; add partition(partition p4 values in (25,26,28));-- list重新分区ALTER TABLE &lt;table&gt; REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES in (1,2,3,4,5));</code></pre><h5 id="2-3-Hash分区"><a href="#2-3-Hash分区" class="headerlink" title="2.3 Hash分区"></a>2.3 Hash分区</h5><p>  对于一些表，是没有连续的字段或者集合性质的可以用来明显分区的特征字段，但表数据又非常庞大，为了将这些数据分散存储，mysql提供了hash分区，基于给定的分区个数，将数据分配到不同分区，但只针对于整数hash，非整数类型数据需要表达式转换，复杂表达式可能造成性能问题。</p><p>hash分区可以细分为：<strong><em>hash</em></strong>分区和<strong><em>线性hash</em></strong>分区，语法区别在于 partition by linear hash.</p><ul><li>Hash分区，是通过MOD函数取模的方式可以让数据非常平均的分布在每一分区，但由于分区在创建时已经固定，新增和收缩分区，数据的迁移比较大。</li><li>线性Hash分区，优点在于增加，删除，合并和拆分分区变的快捷，有利于处理大量的数据的表，缺点在于数据分布可能不太均匀。</li></ul><p>  hash分区示例代码如下：</p><pre><code>CREATE TABLE `sql_hash` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY HASH (id)PARTITIONS 4;//不指定PARTITIONS 4子句时，默认分区为1-- hash重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-4-Key分区"><a href="#2-4-Key分区" class="headerlink" title="2.4 Key分区"></a>2.4 Key分区</h5><p>  key分区类似于Hash分区，但区别在于以下四点：</p><ul><li><p>KEY分区允许多列，Hash只允许一列。</p></li><li><p>如果有主键或唯一键，key分区可不指定，默认是主键或唯一键。如果没有必须显示指定。</p></li><li><p>KEY分区必须基于列，而不是基于列的表达式</p></li><li><p>Hash的算法是MOD函数，而Key是MD5</p></li></ul><pre><code>CREATE TABLE `sql_key` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY KEY (id)PARTITIONS 4;    -- key重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-5-子分区"><a href="#2-5-子分区" class="headerlink" title="2.5 子分区"></a>2.5 子分区</h5><p>  子分区是对分区表中的每个分区再进行分割，又称复合分区，支持对range和list进行子分区，子分区可以采用hash分区或者key分区。复合分区用于保存大量的数据记录。<br>  示例代码如下：</p><pre><code>CREATE TABLE custom(    id INT,    NAME VARCHAR(20))PARTITION BY RANGE(id)SUBPARTITION BY HASH(id) SUBPARTITIONS 2(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN MAXVALUE)# 指明了子分区名CREATE TABLE seller(    id INT,    NAME VARCHAR(50)) PARTITION BY RANGE(id)SUBPARTITION BY HASH(id)(    PARTITION p1 VALUES LESS THAN (10)(SUBPARTITION s1, SUBPARTITION s2, SUBPARTITION s3),    PARTITION p2 VALUES LESS THAN (20)(SUBPARTITION s4, SUBPARTITION s5, SUBPARTITION s6),    PARTITION p3 VALUES LESS THAN MAXVALUE(SUBPARTITION s7, SUBPARTITION s8, SUBPARTITION s9))--子分区添加新分区，系统自动为子分区命名alter table &lt;table&gt; add partition(partition p3 values less than MAXVALUE);</code></pre><h3 id="3-分区表"><a href="#3-分区表" class="headerlink" title="3.分区表"></a>3.分区表</h3><h5 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h5><p>  普通表进行分区之后就被称为分区表，分区表是由多个相关的底层表（存储块）来实现的，这些底层表也是由句柄对象表示，所以我们可以直接访问各个分区，管理分区的各个底层表和普通表对于存储引擎来说是一样的，分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储角度来看没有区别，存储引擎无需知道该表是普通表还是分区表。</p><p><img src="/2019/08/27/MySql深入之分区/1566879182129.png" alt=""></p><h5 id="3-2-操作分析"><a href="#3-2-操作分析" class="headerlink" title="3.2 操作分析"></a>3.2 操作分析</h5><ul><li>select：查询分区表时，分区层先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</li><li>insert：写入分区表时，分区层先打开并锁住所有的底层表，确定哪个分区接受这条记录，再将记录写入对应的底层</li><li>delete: 删除数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，并进行记录删除</li><li>uodate: 更新数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，取出更新，再确定数据该放到哪个分区，对底层表进行写操作，并删除原分区表的旧数据。</li></ul><p><strong>注意</strong>：如果存储引擎能够自己实现行级锁，如Innodb，则会在分区层释放对应的表锁，这个加锁和解锁的过程与普通Innodb上的查询类似。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><h5 id="4-1-分区的注意事项"><a href="#4-1-分区的注意事项" class="headerlink" title="4.1 分区的注意事项"></a>4.1 分区的注意事项</h5><ul><li><p>primary key  和unique key必须包含在分区key的一部分，否则在创建primary key 和unique index时会报错</p></li><li><p>范围分区添加分区只能在最大值后面追加分区</p></li><li><p>所有分区的engine必须一样</p></li><li><p>范围分区字段：integer，数值表达式，日期列，日期函数表达式（如year(), to_days(), to_seconds(), unix_timestamp()）</p></li><li><p>分区字段尽量避免null值，null值对于range分区，会放置到最左边的分区，对于list分区，必须在集合中加入null，对于key和hash分区，都会将null返回为0</p></li><li><p>一个表最多只能有1024个分区</p></li><li><p>分区表无法使用外键约束</p><h5 id="4-2-分区的优点"><a href="#4-2-分区的优点" class="headerlink" title="4.2 分区的优点"></a>4.2 分区的优点</h5></li><li><p>只获取表的热点数据，其他都是历史数据</p></li><li><p>分区表更容易进行维护，可以针对单个分区删除数据，也可以新增分区进行数据的插入，还可以对一个独立的分区进行优化、检查和修复等操作</p></li><li><p>部分查询能够从查询条件确定只落到少数分区上，速度比较快</p></li><li><p>分区表的数据可以分布到不同的物理设备上，从而高效利用多个硬件设备</p></li><li><p>可以使用分区表避免某些特殊瓶颈，如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</p></li><li><p>可以备份和恢复单个分区</p></li><li><p>优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时，涉及聚合函数是，可以在分区上进行处理，最终只需要汇总所有分区的得到的结果</p><h5 id="4-3-分区与分表的关系"><a href="#4-3-分区与分表的关系" class="headerlink" title="4.3 分区与分表的关系"></a>4.3 分区与分表的关系</h5></li><li><p>都能提高mysql的性能，在高并发状态下有一个良好的表现</p></li><li><p>分表和分区不矛盾，可以相互配合，对于需要大量访问，并且数据比较多的表，可以采用分区加分表的方式，访问量不大，但数据很多的表，可以仅采用分区的方式。</p></li><li><p>分表稍微复杂，需要手动创建子表，读写时需要计算子表名。</p></li><li><p>表分区相对于分表，操作方便，不需要创建子表</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/26/hello-world/"/>
      <url>/2019/08/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
