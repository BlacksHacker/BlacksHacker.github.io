<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AIO BIO NIO 笔记整理</title>
      <link href="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/"/>
      <url>/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        本篇文章主要用来记录在开发过程中涉及的IO的一些概念和代码思路，以及对于BIO，NIO，AIO的区分和理解 ，了解如何更好的优化代码。</p><h3 id="2-I-O介绍"><a href="#2-I-O介绍" class="headerlink" title="2.I/O介绍"></a>2.I/O介绍</h3><h5 id="2-1-什么是IO"><a href="#2-1-什么是IO" class="headerlink" title="2.1 什么是IO?"></a>2.1 什么是IO?</h5><p>​        IO的全称是Input/Output的缩写，我们平时大多用的关于一些文件的上传下载，基本都是使用IO下的BIO,BIO是相对于NIO来说的，BIO是Java最早推出的，是BlockingIO的缩写，即阻塞IO.</p><h5 id="2-2-异步-VS-同步"><a href="#2-2-异步-VS-同步" class="headerlink" title="2.2 异步 VS 同步"></a>2.2 异步 VS 同步</h5><table><thead><tr><th>异步</th><th>同步</th></tr></thead><tbody><tr><td>如果A任务依赖B任务，但A任务完成就认为完成了，而不用担心B任务是否完成，以及整体是否真正完成，不可靠的任务序列。</td><td>如果A任务的完成需要依赖B任务，那么它会等，直到B任务完成，A才回去完成任务。B失败，A也会失败，基本步调一致。</td></tr></tbody></table><h5 id="2-3-阻塞-VS-非阻塞"><a href="#2-3-阻塞-VS-非阻塞" class="headerlink" title="2.3 阻塞 VS 非阻塞"></a>2.3 阻塞 VS 非阻塞</h5><table><thead><tr><th>阻塞</th><th>非阻塞</th></tr></thead><tbody><tr><td>CPU会停下来等待一个慢操作的完成，完成之后，CPU才接着完成其他的事。</td><td>在慢操作执行的过程中，CPU并不会等待，而是切换线程去做其他的事情，能提高CPU的利用率，也会导致系统的线程切换成本增加</td></tr></tbody></table><h5 id="2-4-BIO-AIO-NIO的区别？"><a href="#2-4-BIO-AIO-NIO的区别？" class="headerlink" title="2.4 BIO AIO NIO的区别？"></a>2.4 BIO AIO NIO的区别？</h5><table><thead><tr><th>差异类型</th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>名称</td><td>BlockingIO(同步阻塞IO)</td><td>non-BlockingIO（同步非阻塞IO）</td><td>Asynchronous-non-blocking-IO(异步非阻塞IO)</td></tr><tr><td>JDK引入版本</td><td>1.1</td><td>1.4</td><td>1.7</td></tr><tr><td>模型机制</td><td>流模型</td><td>缓冲区模型，单线轮询事件机制</td><td>基于事件和回调机制</td></tr><tr><td>优点</td><td>代码简单、直观</td><td>可以构件多路复用，更接近操作系统底层数据操作方式，在长连接下，数据不多时提升性能很有效</td><td>适用于复杂的分布式环境中，传输数据量不大，但非常频繁的下，性能能达到最高</td></tr><tr><td>缺点</td><td>IO效率和扩展性很低</td><td>会增加CPU的消耗，考虑IO性能能否补偿CPU消耗</td><td>编码较为复杂</td></tr><tr><td>简介</td><td>是最常见的用法，调用是线性顺序，所以大多数时间处于空闲状态，Java的线程是重量级的，所以每次创建线程会造成很高的资源消耗，尤其阻塞在高并发状态下，性能更加明显不足。</td><td>将阻塞改为非阻塞，采用单线程轮询事件机制，通过定位channel来决定做什么，仅仅select阶段会阻塞，避免并发时，线程切换带来的问题</td><td>采用事件和回调机制，反向通知型处理</td></tr></tbody></table><h5 id="2-5-IO的使用"><a href="#2-5-IO的使用" class="headerlink" title="2.5 IO的使用"></a>2.5 IO的使用</h5><p>传统的IO基本可以分为4种：</p><ul><li>InputStream、OuputStream 基于子节操作的IO</li><li>Writer、Reader基于字符操作的IO</li><li>File 基于磁盘的操作IO</li><li>Socket基于网络操作的IO</li></ul><h6 id="2-5-1-InputStream的使用"><a href="#2-5-1-InputStream的使用" class="headerlink" title="2.5.1 InputStream的使用"></a>2.5.1 InputStream的使用</h6><p>​        接口继承关系如下：</p><p><img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227143422595.png" alt="image-20191227143422595"></p><p>​        使用示例：</p><pre><code>InputStream inputStream = new FileInputStream("test.txt");byte[] bytes = new byte[inputStream.available()];inputStream.read(bytes);String str = new String(bytes, "utf-8");System.out.println(str);inputStream.close();</code></pre><h6 id="2-5-2-OuputStream的使用"><a href="#2-5-2-OuputStream的使用" class="headerlink" title="2.5.2 OuputStream的使用"></a>2.5.2 OuputStream的使用</h6><p>​        接口继承关系如下：</p><p>​                    <img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227143843547.png" alt="image-20191227143843547"></p><p>​    使用示例：</p><pre><code>OutputStream outputStream = new FileOutputStream("test.txt",true); outputStream.write("你好，世界".getBytes("utf-8"));outputStream.close();</code></pre><h6 id="2-5-3-Writer-使用"><a href="#2-5-3-Writer-使用" class="headerlink" title="2.5.3 Writer 使用"></a>2.5.3 Writer 使用</h6><p>​        接口继承关系如下：</p><p>​        <img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227144214989.png" alt="image-20191227144214989"></p><p>​        使用示例：</p><pre><code>Writer writer = new FileWriter("test.txt",true); writer.write("hello world");writer.close();//采用nio的方式Files.write(Paths.get(filePath), Content.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);</code></pre><h6 id="2-5-4-Reader-的使用"><a href="#2-5-4-Reader-的使用" class="headerlink" title="2.5.4 Reader 的使用"></a>2.5.4 Reader 的使用</h6><p>​        类的继承关系如下：</p><p>​        <img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227145109053.png" alt="image-20191227145109053"> </p><p>​            使用用例：</p><pre><code>Reader reader = new FileReader(filePath);BufferedReader bufferedReader = new BufferedReader(reader);StringBuffer bf = new StringBuffer();String str;while ((str = bufferedReader.readLine()) != null) {    bf.append(str + "\n");}bufferedReader.close();reader.close();System.out.println(bf.toString());//采用nio的方式byte[] data = Files.readAllBytes(Paths.get(filePath));System.out.println(new String(data, StandardCharsets.UTF_8));</code></pre><h3 id="3-实现Socket"><a href="#3-实现Socket" class="headerlink" title="3. 实现Socket"></a>3. 实现Socket</h3><h5 id="3-1-BIO实现Socket"><a href="#3-1-BIO实现Socket" class="headerlink" title="3.1 BIO实现Socket"></a>3.1 BIO实现Socket</h5><p>​        传统方式实现Socket,每次建立传输连接时，都会创建线程，并发条件下，线程数的激增将会成为瓶颈。</p><pre><code>int port = 8080; //端口号// Socket 服务器端（简单的发送信息）Thread sThread = new Thread(new Runnable() {    @Override    public void run() {        try {            ServerSocket serverSocket = new ServerSocket(port);            while (true) {                // 等待连接                Socket socket = serverSocket.accept();                Thread sHandlerThread = new Thread(new Runnable() {                    @Override                    public void run() {                        try (PrintWriter printWriter = new PrintWriter(socket.getOutputStream())) {                            printWriter.println("hello world！");                            printWriter.flush();                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                });                sHandlerThread.start();            }        } catch (IOException e) {            e.printStackTrace();        }    }});sThread.start();// Socket 客户端（接收信息并打印）try (Socket cSocket = new Socket(InetAddress.getLocalHost(), port)) {    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(cSocket.getInputStream()));    bufferedReader.lines().forEach(s -&gt; System.out.println("客户端：" + s));} catch (UnknownHostException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}</code></pre><h5 id="3-2-NIO实现Socket"><a href="#3-2-NIO实现Socket" class="headerlink" title="3.2 NIO实现Socket"></a>3.2 NIO实现Socket</h5><p>​        NIO利用单线程轮询事件的机制，通过定位就绪的Channel来决定做什么，仅仅select阶段是阻塞的。避免并发情况下，线程的频繁切换问题。</p><pre><code>//创建线程池ThreadPoolExecutor threadPool = new ThreadPoolExecutor(4, 4,        60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());threadPool.execute(new Runnable() {    @Override    public void run() {        //获取选择器 和 通道        try (Selector selector = Selector.open();             ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();) {             //通道绑定地址            serverSocketChannel.bind(new InetSocketAddress(InetAddress.getLocalHost(), port));            serverSocketChannel.configureBlocking(false);            //将通道注册到选择器中            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);            while (true) {                selector.select(); // 阻塞等待就绪的Channel，当有Channel发生接入请求时，会被唤醒                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                while (iterator.hasNext()) {                    SelectionKey key = iterator.next();                    try (SocketChannel channel = ((ServerSocketChannel) key.channel()).accept()) {                        channel.write(Charset.defaultCharset().encode("你好，世界"));                    }                    iterator.remove();                }            }        } catch (IOException e) {            e.printStackTrace();        }    }});// Socket 客户端（接收信息并打印）try (Socket cSocket = new Socket(InetAddress.getLocalHost(), port)) {    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(cSocket.getInputStream()));    bufferedReader.lines().forEach(s -&gt; System.out.println("NIO 客户端：" + s));} catch (IOException e) {    e.printStackTrace();}</code></pre><h5 id="3-3-AIO实现Socket"><a href="#3-3-AIO实现Socket" class="headerlink" title="3.3 AIO实现Socket"></a>3.3 AIO实现Socket</h5><pre><code>// AIO线程复用版Thread sThread = new Thread(new Runnable() {    @Override    public void run() {        AsynchronousChannelGroup group = null;        try {            group = AsynchronousChannelGroup.withThreadPool(Executors.newFixedThreadPool(4));            AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group).bind(new InetSocketAddress(InetAddress.getLocalHost(), port));            server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() {                @Override                public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) {                    server.accept(null, this); // 接收下一个请求                    try {                        Future&lt;Integer&gt; f = result.write(Charset.defaultCharset().encode("你好，世界"));                        f.get();                        System.out.println("服务端发送时间：" + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));                        result.close();                    } catch (InterruptedException | ExecutionException | IOException e) {                        e.printStackTrace();                    }                }                @Override                public void failed(Throwable exc, AsynchronousServerSocketChannel attachment) {                }            });            group.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);        } catch (IOException | InterruptedException e) {            e.printStackTrace();        }    }});sThread.start();// Socket 客户端AsynchronousSocketChannel client = AsynchronousSocketChannel.open();Future&lt;Void&gt; future = client.connect(new InetSocketAddress(InetAddress.getLocalHost(), port));future.get();ByteBuffer buffer = ByteBuffer.allocate(100);client.read(buffer, null, new CompletionHandler&lt;Integer, Void&gt;() {    @Override    public void completed(Integer result, Void attachment) {        System.out.println("客户端打印：" + new String(buffer.array()));    }    @Override    public void failed(Throwable exc, Void attachment) {        exc.printStackTrace();        try {            client.close();        } catch (IOException e) {            e.printStackTrace();        }    }});Thread.sleep(10 * 1000);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于前后端分离的API设计思路整理（三）</title>
      <link href="/2019/10/13/ji-yu-qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-san/"/>
      <url>/2019/10/13/ji-yu-qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-san/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        上一篇主要记录了接口处理具体的实现类的架构设计，其中使用到了模板模式的设计模式，本篇重点记录一下基于注解的关于接口请求参数的验证机制和基于Spring 的类启动加载机制，为以后开发做好知识储备。</p><h3 id="2-注解接口验证"><a href="#2-注解接口验证" class="headerlink" title="2. 注解接口验证"></a>2. 注解接口验证</h3><p>​        该方法的入参依次是，<strong>具体接口实现类的Class，输入参数，入参的Class</strong>。</p><p>​        原理是通过接口实现类的class文件,拿到对应要解析的方法，将其上的注解进行解析，并与入参进行对比，保证入参和注解标记内容的规范一致性。</p><pre><code>protected void validApi(Class&lt;?&gt; apiClass, JSONObject paramObj, Class&lt;?&gt;... classes) throws NoSuchMethodException, SecurityException {        // 获取目标类        Boolean isAuth = false;        if (apiClass != null) {        //AuthAction注解的作用是进行url权限验证            AuthAction action = apiClass.getAnnotation(AuthAction.class);            if (null != action &amp;&amp; StringUtils.isNotBlank(action.name())) {                String actionName = action.name();                // 判断用户角色是否拥有接口权限                if (AuthActionChecker.check(actionName)) {                    isAuth = true;                }            } else {                isAuth = true;            }            if (!isAuth) {                throw new PermissionDeniedException();            }            // 判断参数是否合法，拿到具体接口实现类的“myDoservice”方法            Method method = apiClass.getMethod("myDoService", classes);            if (method != null) {                //拿到Input注解                Input input = method.getAnnotation(Input.class);                if (input != null) {                    Param[] params = input.value();                    if (params != null &amp;&amp; params.length &gt; 0) {                        for (Param p : params) {                            // 判断是否必填，即isRequired的值为true，但参数中没有则抛出异常                            if (p.isRequired() &amp;&amp; !paramObj.containsKey(p.name())) {                                throw new ParamNotExistsException("参数：“" + p.name() + "”不能为空");                            }                            // 参数类型校验                            Object paramValue = paramObj.get(p.name());                            // xss过滤                            if (p.xss() &amp;&amp; paramObj.containsKey(p.name())) {                                encodeHtml(paramObj, p.name());                            }                            // 判断长度                            if (p.length() &gt; 0 &amp;&amp; paramValue != null &amp;&amp; paramValue instanceof String) {                                if (paramValue.toString().length() &gt; p.length()) {                                    throw new ParamValueTooLongException(p.name(), paramValue.toString().length(), p.length());                                }                            }                            if (paramValue != null &amp;&amp; !ApiParamFactory.getAuthInstance(p.type()).validate(paramValue, p.rule())) {                                throw new ParamIrregularException("参数“" + p.name() + "”不符合格式要求");                            }                        }                    }                }            }        }    }</code></pre><h3 id="3-SpringBean加载"><a href="#3-SpringBean加载" class="headerlink" title="3.  SpringBean加载"></a>3.  SpringBean加载</h3><p>​        在项目启动时，会扫描拿到指定接口的所有实现类，存储在内存中。其原理是在项目启动时拿到上下文，在上下文中拿到指定接口的实现类，将其存储在List或者Map中。</p><pre><code>//实现ApplicationListener&lt;ContextRefreshedEvent&gt; 接口，实现 onApplicationEvent 方法@RootComponentpublic class ApiComponentFactory implements ApplicationListener&lt;ContextRefreshedEvent&gt; {    @Override    public void onApplicationEvent(ContextRefreshedEvent event) {        //拿到启动上下文        ApplicationContext context = event.getApplicationContext();        //获取指定接口的BeanMap        Map&lt;String, ApiComponent&gt; myMap = context.getBeansOfType(ApiComponent.class);        for (Map.Entry&lt;String, ApiComponent&gt; entry : myMap.entrySet()) {            //拿到具体的实现类，作相应的处理            ApiComponent component = entry.getValue();            if (component.getId() != null) {            }        }    }        }</code></pre><p>​        可将其存储到Map中，通过工厂模式，后期的获取只需要根据主键ID去获取响应的实体Bean。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于前后端分离的API设计思路整理（二）</title>
      <link href="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/"/>
      <url>/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        前一篇主要介绍了接口的顶层分派器的设计思路，但本质上业务逻辑的处理还是要由底层的接口具体实现类来进行处理，这篇主要记录一下具体接口实现类的架构体系。</p><h3 id="2-接口实现类架构"><a href="#2-接口实现类架构" class="headerlink" title="2. 接口实现类架构"></a>2. 接口实现类架构</h3><ul><li><p>接口继承与实现关系</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p><ul><li><p><strong>ApiComponent（interface）</strong>作为最顶层的接口定义了具体接口所要实现的方法</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/%E9%A1%B6%E5%B1%82%E6%8E%A5%E5%8F%A3.png" alt=""></p></li><li><p><strong>MyAPiComponent（interface）</strong>继承了接口<strong>ApiComponent</strong>,扩展了方法,其目的是为了保证基类<strong>ApiComponentBase</strong>内部方法的干净。</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/MyApiComponent.png" alt=""></p></li><li><p><strong>ApiValidateAndHelpBase</strong>类的作用主要包括提供 <strong>登陆权限验证</strong>，<strong>接口入参格式验证</strong>等功能。</p></li><li><p><strong>ApiComponentBase（abstract）</strong> 是所有接口类的基类，继承了<strong>ApiValidateAndHelpBase</strong>实现了<strong>ApiComponent 和 MyApiComponent</strong>的部分方法：</p><ul><li><strong>doService()</strong>  在该方法的主要目的在具体的接口实现类(<strong>myDoService</strong>)的上一层做一些公共的操作和处理</li><li><strong>getId()</strong> 返回具体实现类的类路径作为唯一主键ID</li><li><strong>help()</strong> 通过调用功能类(<strong>ApiValidateAndHelpBase</strong>)的方法  返回对应具体实现类的注解帮助</li></ul></li><li><p><strong>ProjectSaveApi</strong> 对应具体的接口业务处理层，内部方法结构如下：</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt=""></p><p><strong>getToken()</strong>是用来设置接口实现类的唯一主键路径</p><p><strong>myDoService()</strong>用于进行业务处理 </p><p><strong>总结</strong>： <strong>整套接口的架构使用了设计模式–模板模式，通过子类父调的方式实现了对公共层的抽取和处理。</strong></p></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于前后端分离的API设计思路整理（一）</title>
      <link href="/2019/10/01/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-yi/"/>
      <url>/2019/10/01/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        年初公司开始启动新的项目开发，决定新项目不再采用旧的传统的MVC一体系模式，要做到前后端分离。以往的后端接口都是以一个controller类为单位进行集成，即对应不同接口的处理方式都是该controller类的方法，现将处理方法统一抽出，作为单独的类，为前端提供数据接口。</p><p>​        涉及的知识点：</p><ul><li><p><strong>接口转发器的架构设计（接口请求分配）</strong></p></li><li><p><strong>接口参数的校验设计（采用注解，解析校验）</strong></p></li><li><p><strong>接口参数类型的架构设计（支持JSON, IO流等横向扩展）</strong></p></li></ul><h3 id="2-接口转发器架构设计"><a href="#2-接口转发器架构设计" class="headerlink" title="2. 接口转发器架构设计"></a>2. 接口转发器架构设计</h3><ul><li><strong>核心转发器</strong>（ApiDispatcher）</li></ul><p><img src="/2019/10/01/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-yi/image-20191225114538526.png" alt=""></p><p>​        该类的作用是接受前端的接口请求，然后进行中转处理。</p><p>​        目前所支持的接口访问类型包括四种，<strong>Post,Get, PostStream, PostBinary</strong>，其中<strong>PostStream</strong> 和<strong>PostBinary</strong>的作用是通过接口进行文件类型数据的传输。</p><ul><li>以最常用的<strong>Post</strong>类型为例，该方法用于接收post类型的普通接口请求，解析请求中的接口token和参数，以便分配给具体的接口处理类：</li></ul><pre><code>@RequestMapping(value = "/rest/**",            method = RequestMethod.POST)            //接口传递的参数是以JSONObject    public void dispatcherForPost(@RequestBody    String jsonStr, HttpServletRequest request, HttpServletResponse response) throws Exception {    //获取接口前缀的定义规则，即 api/rest/**（依赖于spring-webmvc）        String pattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);        //根据接口请求规则获取接口的token值，即pattern之后的接口请求路径        String token = new AntPathMatcher().extractPathWithinPattern(pattern, request.getServletPath());        //获取参数值        JSONObject paramObj = null;        if (StringUtils.isNotBlank(jsonStr)) {            try {                paramObj = JSONObject.parseObject(jsonStr);            } catch (Exception e) {                throw new Exception("参数不是json格式,错误信息为：" + e.getMessage());            }        } else {            paramObj = new JSONObject();        }        Enumeration&lt;String&gt; paraNames = request.getParameterNames();        while (paraNames.hasMoreElements()) {            String p = paraNames.nextElement();            String[] vs = request.getParameterValues(p);            if (vs.length &gt; 1) {                paramObj.put(p, vs);            } else {                paramObj.put(p, request.getParameter(p));            }        }        JSONObject returnObj = new JSONObject();        try {            //调用转发方法，上层的代码目的是提取参数，以及token            doIt(request, response, token, ApiVo.Type.OBJECT, paramObj, returnObj, "doservice");        } catch (ApiRuntimeException ex) {            response.setStatus(500);            returnObj.put("Error", ex.getErrorCode());            returnObj.put("Status", "ERROR");            returnObj.put("Message", ex.getMessage());        } catch (Exception ex) {            response.setStatus(500);            returnObj.put("Error", 500);            returnObj.put("Status", "ERROR");            returnObj.put("Message", ExceptionUtils.getStackTrace(ex));            logger.error(ex.getMessage(), ex);        }        if (!response.isCommitted()) {            response.setContentType(Config.RESPONSE_TYPE_JSON);            response.getWriter().print(returnObj);        }    }</code></pre><ul><li>doIt方法的目的在于根据接口token调用对应的接口处理类，并将处理结果进行统一封装，接口对象实体以及对应Vo对象，会在项目启动时扫描进Map中进行存储，三种不同的接口类型对应三种不同的基类。</li></ul><pre><code>private void doIt(HttpServletRequest request, HttpServletResponse response, String token, ApiVo.Type apiType, JSONObject paramObj, JSONObject returnObj, String action) throws Exception {        //项目启动时，会预先将所有接口类实体和其信息Vo扫描进Map中，再通过token在工厂中进行获取        ApiVo interfaceVo = ApiComponentFactory.getApiByToken(token);        if (interfaceVo == null) {            //从表中获取接口类对应Vo            interfaceVo = apiService.getApiByToken(token);            if (interfaceVo == null || !interfaceVo.getIsActive().equals(1)) {                throw new ApiNotFoundException("token为“" + token + "”的接口不存在或已被禁用");            }        }        if (apiType.equals(ApiVo.Type.OBJECT)) {            //获取接口类实体对象            ApiComponent restComponent = ApiComponentFactory.getInstance(interfaceVo.getComponentId());            if (restComponent != null) {                if (action.equals("doservice")) {                    Long starttime = System.currentTimeMillis();                    //调用实体类的doService方法进行参数的处理                    Object returnV = restComponent.doService(interfaceVo, paramObj);                    //封装最终返回值                    Long endtime = System.currentTimeMillis();                    returnObj.put("TimeCost", endtime - starttime);                    returnObj.put("Return", returnV);                    returnObj.put("Status", "OK");                } else {                    //返回接口的帮助文档                    returnObj.putAll(restComponent.help());                }            } else {                throw new ComponentNotFoundException("接口组件:" + restComponent.getId() + "不存在");            }            //采用流类型的处理方式        } else if (apiType.equals(ApiVo.Type.STREAM)) {            JsonStreamApiComponent restComponent = ApiComponentFactory.getStreamInstance(interfaceVo.getComponentId());            if (restComponent != null) {                if (action.equals("doservice")) {                    Object returnV = restComponent.doService(interfaceVo, paramObj, new JSONReader(new InputStreamReader(request.getInputStream(), "utf-8")));                    returnObj.put("Return", returnV);                    returnObj.put("Status", "OK");                } else {                    returnObj.putAll(restComponent.help());                }            } else {                throw new ComponentNotFoundException("接口组件:" + restComponent.getId() + "不存在");            }            //采用二进制类型的处理方式        } else if (apiType.equals(ApiVo.Type.BINARY)) {            BinaryStreamApiComponent restComponent = ApiComponentFactory.getBinaryInstance(interfaceVo.getComponentId());            if (restComponent != null) {                if (action.equals("doservice")) {                    Object returnV = restComponent.doService(interfaceVo, paramObj, request, response);                    returnObj.put("Return", returnV);                    returnObj.put("Status", "OK");                } else {                    returnObj.putAll(restComponent.help());                }            } else {                throw new ComponentNotFoundException("接口组件:" + restComponent.getId() + "不存在");            }        }    }</code></pre><ul><li><p>restHelp方法的目的在于返回接口类的接口帮助说明</p><pre><code>@RequestMapping(value = "/help/rest/**",            method = RequestMethod.GET)    public void resthelp(HttpServletRequest request, HttpServletResponse response) throws IOException {        String pattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);        String token = new AntPathMatcher().extractPathWithinPattern(pattern, request.getServletPath());        JSONObject returnObj = new JSONObject();        try {        //标明是“help”类型请求            doIt(request, response, token, ApiVo.Type.OBJECT, null, returnObj, "help");        } catch (ApiRuntimeException ex) {            response.setStatus(500);            returnObj.put("ErrorCode", ex.getErrorCode());            returnObj.put("Status", "ERROR");            returnObj.put("Message", ex.getMessage());        } catch (Exception ex) {            logger.error(ex.getMessage(), ex);            response.setStatus(500);            returnObj.put("ErrorCode", 500);            returnObj.put("Status", "ERROR");            returnObj.put("Message", ExceptionUtils.getStackFrames(ex));        }        response.setContentType(Config.RESPONSE_TYPE_JSON);        response.getWriter().print(returnObj.toJSONString());    }</code></pre></li></ul><ul><li><p>总结整理：</p><p>​    这一层算是作为所有的请求接口的分配器（dispatcher），通过截取接口请求，拿到请求的唯一token值，根据token拿到具体的接口处理器，对参数进行处理，返回的结果再进行统一包装作为最终结果 进行返回。通过增加方法的方式，支持多种不同数据类型接口的处理。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程：Java并发编程实战学习（二）</title>
      <link href="/2019/09/21/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-er/"/>
      <url>/2019/09/21/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-er/</url>
      
        <content type="html"><![CDATA[<h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h3><p>​        一句话，一个状态值具有可见性，那么当一个线程修改这个状态值之后，其他线程要立刻看到，并且如果要取的话，肯定是取的最新的值（当然属性a确保自己被A线程修改之后，B立马能看到，但是如果A还没去修改，B就去看，依旧会有问题，但a属性确实是“可见性”的，B能提前看，说明不是原子性，有点绕，但线程安全就是<strong>原子性+可见性</strong>）。</p><p>​        A修改属性，B去看的时候，A还没进行同步，导致B看到是旧数据，造成这种现象的问题的本质是“重排序”。</p><h5 id="1-1-失效数据"><a href="#1-1-失效数据" class="headerlink" title="1.1 失效数据"></a>1.1 失效数据</h5><p>​        提前看了，看到了假数据，这就是失效数据。</p><h5 id="1-2-非原子的64位操作"><a href="#1-2-非原子的64位操作" class="headerlink" title="1.2 非原子的64位操作"></a>1.2 非原子的64位操作</h5><p>​            <strong>JVM内存模型要求，变量的读取操作和写入都必须是原子操作</strong>。但非volatile 的long 和double会分为两次，即不能保证原子性，所以不安全，触发加锁或者使用volatile声明，或者使用原子属性AtomicLong类型。</p><h5 id="1-3-加锁与可见性"><a href="#1-3-加锁与可见性" class="headerlink" title="1.3 加锁与可见性"></a>1.3 加锁与可见性</h5><p>​        加锁 = 可见性 + 原子性 = 线程安全 = synchronized</p><p>​        <strong>原话就是</strong>：<em>加锁的含义不仅仅局限于互斥行内，还包括内存可见性，为了确保所有的线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步</em>。</p><p>​        翻译一下就是：执行的时候相关变量要全部修改到位（原子性），并且要让其他的线程都要看到（可见性）。</p><h5 id="1-4-volatile"><a href="#1-4-volatile" class="headerlink" title="1.4 volatile"></a>1.4 volatile</h5><p>​        volatile = 可见性</p><h3 id="2-发布与逸出"><a href="#2-发布与逸出" class="headerlink" title="2. 发布与逸出"></a>2. 发布与逸出</h3><p>​        <strong>发布</strong>：发布一个对象，指的是整个对象可以在当前作用域之外的代码使用。</p><pre><code>public class Publish{    public static List&lt;String&gt; pubList;    public void initialize(){        pubList = new ArrayList();    }}    //pubList 的作用域是initialize方法,但是作为静态属性它已经发布了。</code></pre><p>​        <strong>逸出</strong>：同样发布一个对象，但是对象还没创建好（或者该对象内部的其他对象没创建好）就发布了，即可以被调用了，比较复杂的是隐式使用this逸出。(个人认为逸出是发布中的一个问题点，不是同级或互斥关系)</p><pre><code>public class ThisEscape{    public ThisEscape(EventSource source){        source.registerListener(            new EventListener(){                public void onEvent(Event e){                    doSomething(e);   //逸出的原因是source调用了注册方法，这里隐式的调                                        //用了this。doSomething                }            });        }    }    public void doSomething(Event e){        ....    }}</code></pre><p>所以，切记 <strong>不要在构造过程中使用this引用逸出</strong>。</p><p>正确的写法：</p><pre><code>public class SafeListener{    private final EventListener listener;    private SafeListener(){        listener = new EventListener(){            public void onEvent(Event e){                doSomething(e);            }        }    }    public static SafeListener newInstance(EventSource source){        SafeListener safe = new SafeListener();        source.registerListener(safe.listener); //创建好对象之后才进行注册        return safe;    }}</code></pre><h3 id="3-线程封闭"><a href="#3-线程封闭" class="headerlink" title="3.线程封闭"></a>3.线程封闭</h3><h5 id="3-1-Ad-hoc线程封闭"><a href="#3-1-Ad-hoc线程封闭" class="headerlink" title="3.1 Ad-hoc线程封闭"></a>3.1 Ad-hoc线程封闭</h5><p>​        Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。</p><p>​        当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程程子系统。</p><p>​        由于Ad-hoc线程封闭技术的脆弱性，因此程序中尽量少用它。</p><p>​        我承认，确实不理解这是个什么玩意。。。</p><h5 id="3-2-栈封闭"><a href="#3-2-栈封闭" class="headerlink" title="3.2 栈封闭"></a>3.2 栈封闭</h5><p>​        局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。直译就是，局部变量是属于栈的，一个线程有自己的栈，所以就是线程安全的。</p><p>​        维持对象引用的栈封闭性时，要确保被引用的对象不会逸出（即确保方法内部定义的对象不会在该方法外部被使用，比如被返回，或者加入公共集合属性中等都算逸出）。</p><h5 id="3-3-ThreadLocal-类"><a href="#3-3-ThreadLocal-类" class="headerlink" title="3.3 ThreadLocal 类"></a>3.3 ThreadLocal 类</h5><p>​        ThreadLocal使得线程中的某个值能与保存值的对象关联起来。提供了getter setter方法为每个使用该变量的线程都存有一份独立的副本。保证get总是返回set的最新值。</p><p>​        当某个频繁执行的操作需要一个临时对象时，如缓冲区，又想避免每次执行都重新分配该临时对象，就可以使用该技术。ThreadLocal内部的实现，特定于线程的值保存在Thread对象中，线程终止会被回收。缺点是，降低代码的可重用性，并会在类之间引入隐含的耦合性。</p><h3 id="4-不变性"><a href="#4-不变性" class="headerlink" title="4. 不变性"></a>4. 不变性</h3><p>​        满足同步需求的另一种方法是使用不可变对象，即在被创建之后就不能被修改，并且不可变对象一定是线程安全的。</p><p>​        当满足以下条件时，对象才是不可变的。</p><ul><li><p>对象创建以后其状态就不能修改</p></li><li><p>对象的所有域都是final类型</p></li><li><p>对象是正确创建的，即创建期间没有this引用逸出</p><p>即使对象的所有域均为final 也不一定是不可变的，final类型的域中可以保存可变对象的引用,但只要保证可变对象只有在被初始化的时候才能被修改即可。</p><h5 id="4-1-Final域"><a href="#4-1-Final域" class="headerlink" title="4.1 Final域"></a>4.1 Final域</h5><p>​    将于声明为final类型，等于告诉维护人员这些域是不会变的。</p><h5 id="4-2-使用Volatile类型发布不可变对象"><a href="#4-2-使用Volatile类型发布不可变对象" class="headerlink" title="4.2 使用Volatile类型发布不可变对象"></a>4.2 使用Volatile类型发布不可变对象</h5><pre><code>     对于访问和更新多个相关变量时出现的竞争条件问题，可以将这些**变量封装到一个不可变对象中**。如果是一个可变对象，需要**用锁来保证原子性**。都要使用volatile字段来声明对象，**保证可见性。**</code></pre></li></ul><h3 id="5-安全发布"><a href="#5-安全发布" class="headerlink" title="5. 安全发布"></a>5. 安全发布</h3><p>​                任何线程都可以在<strong>不需要额外同步的情况下安全的访问不可变对象</strong>，即使在发布这些对象时没有使用同步。延伸一下，就是对象的域如果是<strong>非对象类型的final域</strong>，也是可以安全访问的，但是final域的引用所指的对象时依旧<strong>需要同步</strong>。</p><p>​                <strong>可变对象必须通过安全的方式发布，即发布和使用该对象的线程都必须使用同步。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> java </tag>
            
            <tag> Java并发编程实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程：Java并发编程实战学习（一）</title>
      <link href="/2019/09/15/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-yi/"/>
      <url>/2019/09/15/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  本篇博客是根据《Java并发编程实战》的第二章<strong>线程安全性</strong>进行的学习总结。<br>  结构思维导图如下：</p><p><img src="/2019/09/15/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-yi/1567741434309.png" alt="1567741434309"></p><h3 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h3><p>  作者认为，线程的安全与否的核心是“正确性”，即，<strong>当多个线程访问某个类，这个类始终能表现出正确的行为，那么称这个类就是线程安全的。</strong></p><p>​        对于一个线程安全的类，自己的内部已经是线程安全的，所以当外部多线程来调用时，依旧是安全的。即使调用的这个动作没有采用线程安全的方式。</p><p>​        <strong>无状态的对象一定是线程安全的</strong>。这句话的意思是对象不会涉及公共数据的变更与读取时候，即内部只有对数据进行加工的方法，没有任何属性。那么多个线程的访问，本质上是在各自的实例上进行数据处理，互相不会影响其他线程操作的正确性。</p><pre><code>//该类只是将参数数据进行处理，不涉及自身任何属性（字段）public class DoUtil{    public void doing(String message){        System.out.print(message);    }}</code></pre><h3 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2.原子性"></a>2.原子性</h3><p>​        提到原子性也有必要提及一下并发的三个概念：</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><p><img src="https://img-blog.csdnimg.cn/20190806182211114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxkb25fX0xlZQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​        解释一下：</p><p>​        <strong>原子性</strong>，指的是一系列动作是不可分割，这一系列操作中，只能有当前线程独立去进行，其他线程不能参与，要么由一个线程全部执行搞定，要么全不做，类似于<strong>事务</strong>。像++a 这种操作实质是是三个动作，取值，加1，赋值。所以并不具备原子性。</p><h5 id="2-1-竞态条件"><a href="#2-1-竞态条件" class="headerlink" title="2.1 竞态条件"></a>2.1 竞态条件</h5><p>​        竞态条件是指在多线程场景下，<strong>代码的正确性依赖于多个线程的交替执行时序时</strong>，便会发生竞态条件，最常见的场景就是<strong>“先检查后执行（Check-Then-Act）”</strong>.<strong>即先以观察到的数据为依据，然后再去做别的计算，但在观察数据完毕到准备计算这段时间内，所观察的数据已经发生了改变，也就是意为着之前的参考数据是无效的，如果根据无效数据计算，则会出现问题*。</strong></p><h5 id="2-2-延迟初始化的竞态条件"><a href="#2-2-延迟初始化的竞态条件" class="headerlink" title="2.2 延迟初始化的竞态条件"></a>2.2 延迟初始化的竞态条件</h5><p>​        使用“先检查后执行”的一种常见情况就是延迟初始化，比如不安全的单例模式：</p><pre><code>public class SingleTest{    private SingleTest = null;    public SingleTest getInstance(){        if(singTest == null){            singleTest = new SingleTest();        }        return singleTest;    }}//A线程进来判断没有对象,正准备new的时候，B也进来，发现没有，也会new，导致出现两个对象。</code></pre><h5 id="2-3-复合操作"><a href="#2-3-复合操作" class="headerlink" title="2.3 复合操作"></a>2.3 复合操作</h5><p>​        思路很简单，一系列动作不是原子性的，那就加锁，保证其原子性。并且提及到java自带的一些已经实现原子性的变量（java.util.concurrent.atomic）,其内部本质上还是使用<strong>voliate保证可见性，使用CAS算法保证原子性</strong>，这样原子性+可见性 就是实现了变量的线程安全。</p><p>​        单个状态变量时，使用原子变量可以保证安全，但是多个变量时不是由0到1 那么简单，。</p><h3 id="3-加锁机制"><a href="#3-加锁机制" class="headerlink" title="3. 加锁机制"></a>3. 加锁机制</h3><p>​        <strong>要保持状态的一致性，就需要在单个原子操作上保证更新所有的相关变量</strong>，翻译过来，就是接了个盘就得全部干完，并且一个子都不能少。</p><h5 id="3-1-内置锁"><a href="#3-1-内置锁" class="headerlink" title="3.1 内置锁"></a>3.1 内置锁</h5><p>​        内置锁就是所谓java的Synchronized关键字，是一种互斥锁，即锁住后只能单线程进入，其他线程阻塞。加锁位置和作用详见我的CSDN博客<a href="https://blog.csdn.net/Sheldon__Lee/article/details/100015597" target="_blank" rel="noopener">并发系列（五）Synchronized 和volatile</a></p><h5 id="3-2重入锁"><a href="#3-2重入锁" class="headerlink" title="3.2重入锁"></a>3.2重入锁</h5><p>​        重入的一种实现方法就是，为每一个锁关联一个计数器和线程持有者，0表示该锁没有被持有，线程持有之后为1，同一个线程再获取该锁，变为2，依次递增，退出时又递减，0时，锁将被释放。</p><p>​        重入的颗粒度是线程，不是调用，即线程可以持有一个锁好几次。</p><pre><code>public class father(){    public synchronized void do(){    }}public class son extends father{    public synchronized void do(){        super.do();    }}//如果锁不支持重入，线程在son已经拿到了锁，要进入father的do（）方法，又需要锁，但锁已经用来进son了，那么就会出现进入son后等father的锁进入father，而father在等son的锁释放，陷入死锁。</code></pre><h1 id="4-用锁来保护状态"><a href="#4-用锁来保护状态" class="headerlink" title="4. 用锁来保护状态"></a>4. 用锁来保护状态</h1><p>​        用锁很重要，但记得用的是同一把锁哦！</p><h1 id="5-活跃性和性能"><a href="#5-活跃性和性能" class="headerlink" title="5. 活跃性和性能"></a>5. 活跃性和性能</h1><p>​        简单性就是编写代码简单不考虑太多，直接在外层加个大锁，不管该锁不该锁，反正锁了代码不会错。并发性就是代码要有效率，开销低，所以两者是要进行平衡，在保证代码”正确性”的情况下，尽可能的做到并发性。这个就算吃个人编码技能经验了，慢慢来呗，先写对，再优化。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> java </tag>
            
            <tag> Java并发编程实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：对象模型</title>
      <link href="/2019/09/08/git-dui-xiang-mo-xing/"/>
      <url>/2019/09/08/git-dui-xiang-mo-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-SHA"><a href="#1-SHA" class="headerlink" title="1. SHA"></a>1. SHA</h3><p>​        所有表示项目历史信息的文件，都是由40个字符的“对象名”来索引的,每一个对象名都是对对象内容做SHA1哈希计算得来的。</p><pre><code>6ff87c4664981e4397625791c8ea3bbb5f2279a3</code></pre><p>优势：</p><ul><li>只比较对象名，可快速判断对象是否相同</li><li>可以通过检查对象内容的SHA1的哈希值和“对象名”是否相同，来判断对象内容是否正确。</li></ul><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2.  对象"></a>2.  对象</h3><p>​        对象由三部分构成：</p><ul><li>类型<ul><li><strong>blob：</strong>存储文件数据，表示一个文件</li><li><strong>tree：</strong>类似目录，存储子目录（tree）和文件（blob）</li><li><strong>commit：</strong>只指向一个“tree”，标记项目某一个特定时间点的状态。</li><li><strong>tag：</strong>用来标记一个提交（commit）</li></ul></li><li>大小</li><li>内容</li></ul><h5 id="2-1-Blob对象"><a href="#2-1-Blob对象" class="headerlink" title="2.1 Blob对象"></a>2.1 Blob对象</h5><p>​            <img src="/2019/09/08/git-dui-xiang-mo-xing/object-blob.png" alt=""></p><ul><li><p>一个blob就是一块二进制数据，没有指向任何东西和任何其他属性，甚至没有文件名。</p></li><li><p>如果两个文件在同一个目录树中有相同的数据内容，它们将会共享同一个blob对象，与其对应的所在路径、文件名是否被更改完全没有关系。</p></li></ul><h5 id="2-2-Tree对象"><a href="#2-2-Tree对象" class="headerlink" title="2.2 Tree对象"></a>2.2 Tree对象</h5><p>​        一个tree对象拥有一串指向blob对象或是其他tree 对象的指针，一般表示内容之间的目录层次关系。</p><p>​        <img src="/2019/09/08/git-dui-xiang-mo-xing/object-tree.png" alt=""></p><p>​        tree对象的名称同样也是通过SHA1哈希值来命名的，当其两个tree对象的内容完全相同时，名称才会一样。</p><p>​        一个tree对象包括一串条目，条目包括：</p><ul><li>mode</li><li>对象类型</li><li>SHA1值</li><li>名字</li></ul><h5 id="2-3-Commit对象"><a href="#2-3-Commit对象" class="headerlink" title="2.3 Commit对象"></a>2.3 Commit对象</h5><p>​        commit对象指向一个tree对象，并且带有相关的描述信息。</p><p>​        <img src="/2019/09/08/git-dui-xiang-mo-xing/object-commit.png" alt=""></p><p>​        commit的组成部分：</p><ul><li><p><strong>tree</strong> ：tree对象的SHA1签名，代表着目录在某一时间点的内容</p></li><li><p><strong>parent：</strong>父对象，合并的提交可能会不止一个父对象，如果没有父对象，则称为“根提交”，代表项目的最初一个版本，每个项目至少一个根提交。</p></li><li><p><strong>author:</strong>本次修改的修改人，以及日期</p></li><li><p><strong>commiter：</strong>实际创建提交的人</p></li><li><p><strong>注释：</strong>用来描述此次提交</p><p>​        <strong>一个提交本身并没有任何信息来说明其做了哪些修改，所有的修改都是通过与父提交的内容比较得出的。</strong></p><p>​        <strong>一般用git commit来创建一个提交，这个提交的父对象一般是当前分支，同时把存储在当前索引（index）的内容全部提交。</strong></p><h5 id="2-4-标签对象"><a href="#2-4-标签对象" class="headerlink" title="2.4 标签对象"></a>2.4 标签对象</h5><p>​        一个标签对象包括一个对象名，对象类型，标签名，标签创建人的名字。</p><p>​    <img src="/2019/09/08/git-dui-xiang-mo-xing/object-tag.png" alt=""></p></li></ul><h3 id="3-对象模型"><a href="#3-对象模型" class="headerlink" title="3. 对象模型"></a>3. 对象模型</h3><p>​        项目的层次结构如下：</p><pre><code>$&gt;tree.|-- README`-- lib    |-- inc    |   `-- tricks.rb    `-- mylib.rb2 directories, 3 files</code></pre><p>​        在Git中的存储层次如下：</p><p><img src="/2019/09/08/git-dui-xiang-mo-xing/image/objects-example.png" alt=""></p><h3 id="4-Git目录"><a href="#4-Git目录" class="headerlink" title="4. Git目录"></a>4. Git目录</h3><pre><code>$&gt;tree -L 1.|-- HEAD         # 这个git项目当前处在哪个分支里|-- config       # 项目的配置信息，git config命令会改动它|-- description  # 项目的描述信息|-- hooks/       # 系统默认钩子脚本目录|-- index        # 索引文件|-- logs/        # 各个refs的历史信息|-- objects/     # Git本地仓库的所有对象 (commits, trees, blobs, tags)`-- refs/        # 标识你项目里的每个分支指向了哪个提交(commit)。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo：集群容错模式-负载均衡模式</title>
      <link href="/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/"/>
      <url>/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        Dubbo本身是一个开源的分布式服务框架，我们可以很容易的用来构建分布式服务，并根据实际业务场景选择合适的集群容错模式。</p><h3 id="2-Dubbo服务集群容错"><a href="#2-Dubbo服务集群容错" class="headerlink" title="2. Dubbo服务集群容错"></a>2. Dubbo服务集群容错</h3><p>采用集群容错模式的意义在于，当服务消费方发起调用申请之后，针对不同的错误情况，要有一套合理的配置架构来应对。</p><h5 id="2-1-Dubbo架构组件"><a href="#2-1-Dubbo架构组件" class="headerlink" title="2.1 Dubbo架构组件"></a>2.1 Dubbo架构组件</h5><p>Dubbo的架构组件图如下：</p><p><img src="/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/137084-20180507104753924-755727985.png" alt="img"></p><p>各组件关系如下：</p><ul><li>Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址以及Service接口信息。</li><li>Directory代表多个Invoker,可以将其看成List,但其值是动态变化的，比如注册中心的推送变更。</li><li>Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，但内部包含了容错逻辑。</li><li>Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等。</li><li>LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。</li></ul><h5 id="2-2-Dubbo支持的集群模式"><a href="#2-2-Dubbo支持的集群模式" class="headerlink" title="2.2 Dubbo支持的集群模式"></a>2.2 Dubbo支持的集群模式</h5><p>​    <strong>Dubbo 支持6中集群模式</strong></p><ul><li><p><strong><em>Failover Cluster</em></strong>模式</p><p>配置为failover,容错集群默认的选择，调用失败时，会自动切换，重新尝试调用其他节点上的可用服务，适用于一些幂等性操作，每次调用的副作用是相同的。</p><pre><code>&lt;dubbo:service interface="org.shirdrn.dubbo.api.ChatRoomOnlineUserCounterService" version="1.0.0"     cluster="failover" retries="2" timeout="100" ref="chatRoomOnlineUserCounterService" protocol="dubbo" &gt;     &lt;dubbo:method name="queryRoomUserCount" timeout="80" retries="2" /&gt;&lt;/dubbo:service&gt;</code></pre><ul><li>retries : 重试次数</li><li>timeout：服务级别调用超时时间</li><li>如果该服务中有其他方法，没有显示配置，则会继承服务级别的配置</li></ul></li><li><p><strong><em>Failfast Cluster</em></strong>模式</p><p>配置为failfast，称为快速失败模式，调用只执行一次，失败立即报错。适用于非幂等性操作，每次调用的副作用是不同的。</p></li><li><p><strong><em>Failsafe Cluster</em></strong>模式</p><p>配置为failsafe，失败安全模式，如果调用失败，则直接忽略失败的调用，而是要记录下失败的调用到日志文件，以便后续审计。</p></li><li><p><strong><em>Failback Cluster</em></strong>模式</p><p>配置为failback，失败自动恢复，后台记录失败请求，定时重发，常用于消息通知。</p></li><li><p><strong><em>Forking Cluster</em></strong>模式</p><p>配置为forking，并行调用多个服务器，只要一个成功即返回。常用于实时性要求较高的操作，但需要浪费更多资源。</p></li><li><p><strong><em>Broadcast Cluster</em></strong>模式</p><p>配置为broadcast，广播调用所有提供者，逐个调用，任意一台报错则错，常用于通知所有提供者更新缓存或日志等。</p></li><li><p><strong><em>定制化集群容错模式可以通过扩展Cluster接口实现</em></strong></p></li></ul><h5 id="2-3-Dubbo服务负载均衡"><a href="#2-3-Dubbo服务负载均衡" class="headerlink" title="2.3 Dubbo服务负载均衡"></a>2.3 Dubbo服务负载均衡</h5><p>​    <strong>Dubbo支持4种负载均衡策略</strong></p><ul><li><p><strong>Random LoadBalance:</strong>随机策略，配置值为random，可以设置权重。利于充分利用服务器资源，高配调大，低配调小。</p></li><li><p><strong>RoundRobin LoadBalance:</strong>轮询策略，配置值为roundrobin</p></li><li><p><strong>LeastActive LoadBalance:</strong>配置值为leastactive，根据请求调用的次数计数，处理请求更慢的节点会受到更少的请求。</p></li><li><p><strong>ConsistentHash LoadBalance:</strong>一致性Hash策略。相同调用参数的请求会发送到同一个服务提供的节点上，如果某个节点发生故障无法提供服务，则会基于一致性Hash算法映射到虚拟节点上。</p><pre><code>&lt;dubbo:service interface="org.shirdrn.dubbo.api.ChatRoomOnlineUserCounterService" version="1.0.0"     cluster="failover" retries="2" timeout="100" loadbalance="random"     ref="chatRoomOnlineUserCounterService" protocol="dubbo" &gt;     &lt;dubbo:method name="queryRoomUserCount" timeout="80" retries="2" loadbalance="leastactive" /&gt;&lt;/dubbo:service&gt;</code></pre><p><strong>loadbalance也存在继承关系，即子类策略会覆盖父级策略。自定义的策略要实现LoadBalance接口。</strong></p><h5 id="2-4-Dubbo服务管理和监控"><a href="#2-4-Dubbo服务管理和监控" class="headerlink" title="2.4 Dubbo服务管理和监控"></a>2.4 Dubbo服务管理和监控</h5><ul><li><p>Dubbo服务管理中心</p></li><li><p>Dubbo监控中心</p><p>​    </p></li></ul></li></ul><p><img src="/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/137084-20180507104907461-623468070.png" alt="img"></p><p>管理中心和监控中心都可以通过安装的方式部署在tomcat上，这样就可以通过管理中心和监控中心来查看对应的详细情况。管理中心和注册中心是两个概念，管理中心可以调整提供者和消费者的状态以及其他设置，注册中心则用来提供注册，保证提供者的可见性，以及后续动态扩展的维护管理。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo：服务治理（入门篇）</title>
      <link href="/2019/08/31/dubbo-fu-wu-zhi-li/"/>
      <url>/2019/08/31/dubbo-fu-wu-zhi-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        <strong>Dubbo</strong>是阿里巴巴开源的一个高性能优秀的服务框架，采用非常简单的模型，将服务的提供方和消费方抽象为两个角色，可实现软负载均衡，并且还可选性的支持监控中心和调用管理中心，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和Spring框架无缝集成。</p><p>​        <strong>RPC</strong>（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p><p>​        相对于<strong>Http请求</strong>，良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。</p><h3 id="2-产生背景"><a href="#2-产生背景" class="headerlink" title="2. 产生背景"></a>2. 产生背景</h3><p><img src="/2019/08/31/dubbo-fu-wu-zhi-li/dubbo-architecture-1577678816466.png" alt=""></p><h5 id="2-1-架构演变"><a href="#2-1-架构演变" class="headerlink" title="2.1 架构演变"></a>2.1 架构演变</h5><p>​        随着互联网的发展，系统的架构也应业务需求和技术在不停的演变。</p><ul><li><p>单一应用架构（ORM）</p><ul><li>小网站，流量小，所有功能集中部署，节省节点和成本</li><li>数据访问框架（ORM）简化增删改查工作</li></ul></li><li><p>垂直应用架构（MVC）</p><ul><li>访问量增大时，将应用拆分为不相干的几个应用，以提升效率</li><li>Web框架加速前端页面开发</li></ul></li><li><p>分布式服务架构（RPC）</p><ul><li>垂直应用增多时，应用交互不可避免，将核心业务抽出，作为独立的服务，使前端更快速的响应需求变更</li><li>分布式服务框架（RPC）提高业务复用及整合</li></ul></li><li><p>流动计算架构</p><ul><li>服务增多时，容量评估和小服务资源浪费出现，需要调度中心基于访问压力实时管理集群容量，提高集群利用率。</li><li>资源调度和治理中心（SOA）提高机器利用率</li></ul></li></ul><h5 id="2-2-解决问题"><a href="#2-2-解决问题" class="headerlink" title="2.2 解决问题"></a>2.2 解决问题</h5><p><img src="/2019/08/31/dubbo-fu-wu-zhi-li/dubbo.png" alt="dubbo"></p><ul><li><p>服务增多，URL配置管理难度增加，F5硬件负载均衡器的单点压力增大</p><p>​    解决方案：</p><ul><li>配置服务注册中心，动态注册和发现服务，使服务位置透明</li><li>在消费方提供服务地址列表，实现负载均衡，降低F5硬件负载器的依赖，减少成本。</li></ul></li><li><p>服务间依赖关系错综复杂</p></li><li><p>服务调用的激增，无法正确预知服务容量，规划硬件配置</p><p>​    解决方案：</p><ul><li>配置服务监控，实时获取服务调用数据，合理规划硬件配置信息</li></ul></li></ul><h3 id="3-Dubbo"><a href="#3-Dubbo" class="headerlink" title="3. Dubbo"></a>3. Dubbo</h3><h5 id="3-1-架构"><a href="#3-1-架构" class="headerlink" title="3.1 架构"></a>3.1 架构</h5><p><img src="/2019/08/31/dubbo-fu-wu-zhi-li/1573544852818.png" alt="1573544852818"></p><p>架构特点：**</p><ul><li>基于透明接口的RPC</li><li>智能负载平衡</li><li>自动服务注册和发现</li><li>高扩展性</li><li>运行时流量路由</li><li>可视化服务治理</li><li><strong>远程通讯“：</strong>提供多种基于长连接的NIO框架抽象封装框架，包括多线程模型，序列化，以及请求-响应模式的信息交换方式。</li><li><strong>集群容错：</strong>提供基于接口方法的透明远程过程调用，包括多协议支持，软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>自动发现：</strong>基于注册中心目录服务，使服务消费方能动态查找服务提供方，使地址透明。</li><li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有API侵入。</li><li>软负载及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册和发现，不需写死服务提供方地址，注册中心基于接口查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><p><strong>节点介绍：</strong></p><ul><li><strong>Provider</strong> 暴露服务的服务提供方</li><li><strong>Consumer</strong> 调用远程服务的服务消费方</li><li><strong>Registry</strong>  服务注册与发现的注册中心 </li><li><strong>Monitor</strong> 统计服务的调用次数和调用时间的监控中心</li><li><strong>Container</strong>  服务运行容器</li></ul><p><strong>调用逻辑说明</strong>：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选一台进行调用。</li><li>服务消费者和服务提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p><strong>注册中心：</strong></p><p>​        注册中心用来进行服务的注册和进行负载均衡，dubbo提供了集中实现注册中心的方式：</p><ul><li>Multicast 注册中心</li><li><strong>Zookeeper 注册中心 （官方推荐）</strong></li><li>Redis 注册中心</li><li>Simple 注册中心</li></ul><h5 id="3-2-dubbo的简单使用（整合Spring）"><a href="#3-2-dubbo的简单使用（整合Spring）" class="headerlink" title="3.2 dubbo的简单使用（整合Spring）"></a>3.2 dubbo的简单使用（整合Spring）</h5><ol><li><p>导入POM文件</p><pre><code>&lt;properties&gt;    &lt;dubbo.version&gt;2.7.4.1&lt;/dubbo.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;        &lt;artifactId&gt;dubbo&lt;/artifactId&gt;        &lt;version&gt;${dubbo.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;        &lt;version&gt;${dubbo.version}&lt;/version&gt;        &lt;type&gt;pom&lt;/type&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>这里使用了zookeeper注册中心。</p></li><li><p>定义服务层接口</p><pre><code>//service接口public interface GreetingService {    String sayHi(String name);}//对应实现类public class GreetingsServiceImpl implements GreetingsService {    @Override    public String sayHi(String name) {        return "hi, " + name;    }}</code></pre></li><li><p>服务容器加载服务提供者</p><pre><code>public class Application {    private static String zookeeperHost = System.getProperty("zookeeper.address", "127.0.0.1");    public static void main(String[] args) throws Exception {        ServiceConfig&lt;GreetingsService&gt; service = new ServiceConfig&lt;&gt;();        service.setApplication(new ApplicationConfig("first-dubbo-provider"));        service.setRegistry(new RegistryConfig("zookeeper://" + zookeeperHost + ":2181"));        service.setInterface(GreetingsService.class);        service.setRef(new GreetingsServiceImpl());        service.export();        System.out.println("dubbo service started");        new CountDownLatch(1).await();    }}</code></pre></li><li><p>从服务容器中获取服务</p></li></ol><pre><code>    public class Application {    private static String zookeeperHost = System.getProperty("zookeeper.address", "127.0.0.1");    public static void main(String[] args) {        ReferenceConfig&lt;GreetingsService&gt; reference = new ReferenceConfig&lt;&gt;();        reference.setApplication(new ApplicationConfig("first-dubbo-consumer"));        reference.setRegistry(new RegistryConfig("zookeeper://" + zookeeperHost + ":2181"));        reference.setInterface(GreetingsService.class);        GreetingsService service = reference.get();        String message = service.sayHi("dubbo");        System.out.println(message);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper：分布式管理</title>
      <link href="/2019/08/24/zookeeper-fen-bu-shi-guan-li/"/>
      <url>/2019/08/24/zookeeper-fen-bu-shi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>  随着公司业务的不断增长，单机模式已经不足以处理当下的业务量，所以不得不采用多台服务器构成集群，来处理激增的业务量。集群在一定程度上能够分解单个服务器的处理压力，打破单机的性能瓶颈，提高系统服务的可用性。但分布式集群往往存在一些问题：</p><ul><li>不同于单机下，多个进程或线程在日志信息的保证下能够安全的处理同一资源，多台服务器处理属于不同的物理机,如何能够保证事务安全性，即比如如何保证多台服务器对于一个文件的写操作。</li><li>多台服务器下，如果一台宕机，如何保证其他服务器能接受其任务，如果保证业务激增时进行服务器扩展，能在不重启的情况下进行业务数据的迁移。</li><li>如何保证任务的均匀分配，保证任务执行的效率，实现负载均衡。</li><li>程序运行依赖于配置文件，不同物理机如何实现像数据库地址，黑名单控制，服务地址列表等这些配置文件的共享，并且修改后能即时达到数据一致。</li></ul><h1 id="2-Zookeeper简介"><a href="#2-Zookeeper简介" class="headerlink" title="2.Zookeeper简介"></a>2.Zookeeper简介</h1><p>  Zookeeper是一个<strong>分布式协调服务</strong>。单机上的协调都是进程内的协调，在进行内进行协调可以使用语言，平台，操作系统等提供的同步机制，保证单机内部多线程访问同一资源时的同步，实现多线程的协调。但分布式集群环境下，程序可能在不同的机器，机器可能不在同一个机房，机房又在不同的地域分布，这时候需要类似Zookeeper这类分布式协调服务来进行对集群的协调。</p><h2 id="2-1-存储结构"><a href="#2-1-存储结构" class="headerlink" title="2.1 存储结构"></a>2.1 存储结构</h2><p><img src="/2019/08/24/zookeeper-fen-bu-shi-guan-li/1567479565493-1574416654648.png" alt=""><br>zookeeper的数据是按照<strong>树</strong>的结构进行存储的，节点分为四种类型：</p><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td>PERSISTENT-持久化节点</td><td>在创建该节点的客户端与zookeeper断开后，该节点也不会被删除</td></tr><tr><td>PERSISTENT-SEQUENTIAL-持久化顺序编号节点</td><td>在请求创建节点时，会根据parent-znode的zxid状态，为该节点编写全目录唯一的编号，即使客户端断开，该节点不会被删除</td></tr><tr><td>EPHEMERAL-临时znode节点</td><td>客户端断开后，节点会被删除掉</td></tr><tr><td>EPHEMERAL_SEQUENTIAL-临时顺序编号znode节点</td><td>在请求创建节点时，会根据parent-znode的zxid状态，为该节点编写全目录唯一的编号，客户端断开时，该节点会被删除</td></tr></tbody></table><h2 id="2-2-znode"><a href="#2-2-znode" class="headerlink" title="2.2 znode"></a>2.2 znode</h2><ul><li>每一个znode默认存储1MB的数据</li><li>登陆zookeeper，可以通过ls、create、delete、sync等命令去操作这些节点<br>znode结构</li></ul><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td>zxid</td><td>时间戳，每次修改znode都会产生新的zxid</td></tr><tr><td>version</td><td>对节点的每次修改都会使得节点的版本号加1</td></tr><tr><td>data</td><td>每一个znode默认能够存储1MB的数据，对data的修改会引起两种的变化</td></tr><tr><td>tick</td><td>租约协议的具体体现，如果当前节点是“临时节点”，在trick时间周期内没有收到新的客户端租约，则视为无效</td></tr></tbody></table><h1 id="2-3-选举FastLeaderElection"><a href="#2-3-选举FastLeaderElection" class="headerlink" title="2.3 选举FastLeaderElection"></a>2.3 选举FastLeaderElection</h1><h1 id="2-4-监听机制"><a href="#2-4-监听机制" class="headerlink" title="2.4 监听机制"></a>2.4 监听机制</h1><p>  zookeeper的主要目的是统一分布式系统中各个节点的工作状态，在资源冲突的情况下协调提供节点资源抢占，给每个节点提供了解集群所处状态的途径，这都依赖于zookeeper中的时间监听和通知机制。</p><h2 id="2-4-1事件和状态"><a href="#2-4-1事件和状态" class="headerlink" title="2.4.1事件和状态"></a>2.4.1事件和状态</h2><p>  <strong>事件和状态构成了zookeeper客户端连接描述的两个维度。</strong></p><ul><li>事件：指zookeeper监听某一个znode节点，一但触发，就执行该事件所绑定的事情。</li><li>状态：指zookeeper与所连接的服务器之间的状态。</li><li>zookeeper客户端与server连接的状态</li></ul><table><thead><tr><th>连接状态</th><th>状态含义</th></tr></thead><tbody><tr><td>KeeperState.Expired</td><td>客户端和服务器在ticktime的时间周期内，要进行发送心跳通知，这是租约协议的一个实现，客户端发送request，告知服务器上一个租约时间，服务器接受之后，告知客户端下一个续租时间，当客户端到达最后一个续租时间事，没有收到服务端发来的新租约时间，即认为自己下线，这个过期状态即为Expired状态</td></tr><tr><td>KeeperState.Disconnected</td><td>当客户端断开一个连接（租约期满或者客户端主动离开），这时客户端和服务器的状态就是Disconnected</td></tr><tr><td>KeeperState.SynConnected</td><td>一旦客户端和服务器的一个节点建立连接，并完成一次version、zxid的同步。该状态就是这个</td></tr><tr><td>KeeperState.AuthFailed</td><td>zookeeper客户端进行连接认证失败时，发生该状态</td></tr><tr><td><strong>备注：这些状态触发时，所记录的事件类型都是：EventType.Node.</strong></td><td></td></tr></tbody></table><p>-zookeeper中的事件，当zookeeper客户端监听某个znode节点时：<br>|zookeeper事件|含义|<br>|—|—|<br>|EventType.NodeCreated|当这个节点被创建时，事件触发|<br>|EventType.NodeChildrenChanged|当这个节点的直接子节点被创建、删除、子节点数据被变更时，触发该事件|<br>|EventType.NodeDataChange|当这个节点的数据发生变更时，该事件被触发|<br>|EventType.NodeDeleted|当这个节点被删除时，该事件被触发|<br>|EventType.None|当zookeeper的客户端连接状态发生变更时，即上述几个状态之间互相切换时|</p><h2 id="2-5-watcher机制"><a href="#2-5-watcher机制" class="headerlink" title="2.5 watcher机制"></a>2.5 watcher机制</h2><p>  zookeeper建立节点监听可采用的方法有：</p><ul><li>zk.getChilren(path,watch)</li><li>zk.exists(path, watch)</li><li>zk.getData(path,watch,stat)</li><li>zk.register(watcher)注册默认监听</li></ul><p>  <strong>以上的注册方式，都可以对Event.Type事件进行监听，如果注册多个监听器，则它们都会收到Event.Node事件。</strong></p><ul><li>注册方法与监听事件间的关系</li></ul><table><thead><tr><th>注册方式</th><th>NodeCreated</th><th>NodeChildrenChanged</th><th>NodeDataChanged</th><th>NodeDeleted</th></tr></thead><tbody><tr><td>zk.getChildren(“”,watcher)</td><td></td><td>可监控</td><td></td><td>可监控</td></tr><tr><td>zk.exists(“”,watcher)</td><td>可监控</td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getData(“”,watcher)</td><td>悖论</td><td></td><td>可监控</td><td>可监控</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><p>当一个watcher实例多次注册一个节点时，zkClient只通知一次，当多个不同watcher实例注册同一个节点时，zkClient会依次进行通知。</p></li><li><p>监控同一个节点的一个watcher实例，通过exist、getData等多种注册方式注册时，zkClient也只会通知一次。</p><h1 id="3-作用"><a href="#3-作用" class="headerlink" title="3. 作用"></a>3. 作用</h1></li><li><p><strong>配置管理</strong><br>  程序中往往存在众多的配置信息，众多服务器依赖于该配置文件，zookeeper的作用就是对这些配置文件进行集中管理，将配置文件提取放置一个地方，对其进行监听，当配置信息发生改变时，受zookeeper管理的服务器将会受到通知，然后服务器获取新的配置信息。zookeeper使用了Zab这种一致性协议来保证配置在集群中的一致性。</p></li><li><p><strong>命名服务</strong><br>  在集群和分布式环境下，zookeeper能够简化子项目之间的调用关系，不至于出现不知道哪个调哪个，可以集中精力去处理业务逻辑。在集群中，相同的一个服务有很多个提供者，当提供者启动时，其相关信息（接口，地址，端口等）会注册到zookeeper中，当消费者需要消费时，再依据负载均衡机制选择一个服务者提供服务。</p></li><li><p><strong>分布式锁</strong><br>  zookeeper可以用来协调多个分布式进程之间的活动，一件事情交给多个服务器进行处理时，就需要进行分布式的同步，某个时刻只让一个服务去干活，出现问题时，立马释放分布式锁，交由其他服务器进行处理。其处理策略一般被称为<strong>选举机制</strong>。</p></li><li><p><strong>集群管理</strong><br>  分布式集群中，处于各种原因，节点总是在变化，集群中的其他机器需要动态的感知当前集群中的状态。像在一个分布式存储系统中，存在一个中央控制节点负责存储的分配，其依赖于感知集群节点的变化。</p></li></ul><p>参考博客：<a href="https://blog.csdn.net/tang06211015/article/details/51850516" target="_blank" rel="noopener">Zookeeper场景分析及实例代码</a><br>    <a href="https://blog.csdn.net/yinwenjie/article/details/47361419" target="_blank" rel="noopener">  zookeeper单点和集群安装</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring：异步通知</title>
      <link href="/2019/08/16/spring-yi-bu-tong-zhi/"/>
      <url>/2019/08/16/spring-yi-bu-tong-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        公司最近给主模块搞一个系统通知的功能，要求设计并对接各大分模块的消息通知，要求是分模块业务执行过程中会触发消息插件，将消息推送到系统通知的消息存储区域，但是一旦业务执行失败，业务会进行回滚，但是消息已经发出去了，显然不合理。因此配合事务，最后采用Spring事务异步进行发送的方式搞定，即业务执行完毕之后事务提交，则进行消息的异步推送。</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>​            直接上代码：</p><pre><code>@Servicepublic class SystemRemindMessageHandler {    //采用log4j进行日志保存    static Logger logger = LoggerFactory.getLogger(SystemRemindMessageHandler.class);    //采用ThreadLocal为每个线程保存相关的 异步线程集合    private static final ThreadLocal&lt;List&lt;Runnable&gt;&gt; RUNNABLES = new ThreadLocal&lt;&gt;();    private static RealTimeRemindMapper realTimeRemindMapper;    private static RemindMapper remindMapper;    //Spring注入    @Autowired    public  void setRealTimeRemindMapper(RealTimeRemindMapper realTimeRemindMapper) {        SystemRemindMessageHandler.realTimeRemindMapper = realTimeRemindMapper;    }    //Spring注入    @Autowired    public  void setRemindMapper(RemindMapper remindMapper) {        SystemRemindMessageHandler.remindMapper = remindMapper;    }    //使用锁保证并行消息发送的安全性    public synchronized static void sendMessage(RemindMessageVo messageVo, String className){        //创建线程        SystemRemindMessageHandler.MessageRunner runner = new SystemRemindMessageHandler.MessageRunner(messageVo, className);        //如果当前不存在事务，则直接进行消息的保存        if (!TransactionSynchronizationManager.isSynchronizationActive()){            CommonThreadPool.execute(runner);            return;        }        //获取当前线程的异步线程集合        List&lt;Runnable&gt; runnables = RUNNABLES.get();        //如果没有当前线程的异步线程集合，则创建        if (runnables == null){            runnables = new ArrayList&lt;Runnable&gt;();            //创建好的集合加入ThreadLocal            RUNNABLES.set(runnables);            //设置事务触发的动作            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                //重写事务提交后的动作                @Override                public void afterCommit() {                    //拿到当前线程的异步线程集合，遍历全部执行，消息推送                    List&lt;Runnable&gt; runnables = RUNNABLES.get();                    for (int i = 0; i &lt; runnables.size(); i++){                        Runnable runnable = runnables.get(i);                        CommonThreadPool.execute(runnable);                    }                }                //重写完成方法，移除当前线程的异步线程集合                @Override                public void afterCompletion(int status){                    RUNNABLES.remove();                }            });        }        //如果当前线程存在异步线程集合，则加入        runnables.add(runner);    }    //静态内部类    static class MessageRunner implements Runnable{        private RemindMessageVo mess;        private String className;        public MessageRunner(RemindMessageVo _mess, String _className){            mess = _mess;            className = _className;        }        @Override        public void run() {            String oldName = Thread.currentThread().getName();            //修改线程名，以便于日志打印问题            Thread.currentThread().setName("SYSTEMREMIND-MESSAGEHANDLER-" + mess.getTitle());            try{                Long systemRemindId = remindMapper.getRemindIdByClassName(className);                if (systemRemindId != null &amp;&amp; systemRemindId !=0L){                    //此处进行省略，为消息发送业务代码                }else {                    throw new RuntimeException("找不到动态消息组件：" + className);                }            }catch (Exception ex){                logger.error(ex.getMessage(), ex);            }            finally {                //恢复线程名称                Thread.currentThread().setName(oldName);            }        }    }}</code></pre><p>参考博客：<a href="https://segmentfault.com/a/1190000004235193" target="_blank" rel="noopener">如何在数据库事务提交成功后进行异步操作</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
            <tag> 框架 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring：事务</title>
      <link href="/2019/08/10/spring-shi-wu/"/>
      <url>/2019/08/10/spring-shi-wu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据库知识点"><a href="#1-数据库知识点" class="headerlink" title="1. 数据库知识点"></a>1. 数据库知识点</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><ul><li>数据库管理系统一般采用重执行日志保证原子性，一致性和持久性</li><li>和java程序采用对象锁进行线程同步类似，数据库管理系统采用数据库锁机制保证事务的隔离性，多个事务修改数据，只有持有锁的事务才可以。</li></ul><h4 id="1-2-数据并发问题"><a href="#1-2-数据并发问题" class="headerlink" title="1.2 数据并发问题"></a>1.2 数据并发问题</h4><h4 id="1-2-1-读数据"><a href="#1-2-1-读数据" class="headerlink" title="1.2.1 读数据"></a>1.2.1 读数据</h4><table><thead><tr><th>类型</th><th>介绍</th></tr></thead><tbody><tr><td>脏读</td><td>A事务读取B事务未提交的更改数据，B事务选择回撤。</td></tr><tr><td>不可重复读</td><td>一个事务范围内，两次相同的查询，返回了不同的值，这是由于查询系统时，其他事务修改了行数据导致的，使用行级锁可以解决。</td></tr><tr><td>幻象读</td><td>两次读取之间，其他事务添加了一行数据，表级锁可以解决。</td></tr></tbody></table><p>​        <strong>幻读指读到新增的数据（数据是一行一行的新增），不可重复读指读到了已提交事务的更改数据（变更删除针对行数据的某些字段）</strong></p><h4 id="1-2-2-更新数据"><a href="#1-2-2-更新数据" class="headerlink" title="1.2.2 更新数据"></a>1.2.2 更新数据</h4><table><thead><tr><th>类型</th><th>介绍</th></tr></thead><tbody><tr><td>第一类丢失更新</td><td>A事务撤销时，将B事务提交的数据覆盖掉了。</td></tr><tr><td>第二类丢失更新</td><td>A事务提交时，将B事务提交的数据覆盖掉了。</td></tr></tbody></table><h4 id="1-3-数据库锁机制"><a href="#1-3-数据库锁机制" class="headerlink" title="1.3 数据库锁机制"></a>1.3 数据库锁机制</h4><p><img src="/2019/08/10/spring-shi-wu/Screenshot1520500121%5B1%5D.png" alt=""></p><table><thead><tr><th>标题</th><th>解释</th></tr></thead><tbody><tr><td>悲观锁</td><td>认为自身在修改数据时，一定会有人来修改，所以要加锁保证不被修改</td></tr><tr><td>乐观锁</td><td>一般指用户自己实现的一种锁机制，假定数据不会冲突，在数据提交更新的时候才会进行检测，如果发现冲突，就返回用户错误的信息。</td></tr><tr><td>表级锁</td><td>整个表加锁</td></tr><tr><td>页级锁</td><td>BerkeleyDB存储引擎，开销、加锁和粒度介于表锁和行锁之间，会出现死锁，并发度一般。</td></tr><tr><td>行级锁</td><td>整行数据加锁</td></tr><tr><td>共享锁</td><td>数据库<strong>查询</strong>一条数据时，数据库系统会对该行进行锁定，读操作中允许其他事务同时更新表中未锁定的行<br>    资源上放置共享锁，还能再放置共享锁和更新锁<br>    具有良好的并发性，被放置共享锁之后，还可以再放置共享锁和更新锁，并发性较好。</td></tr><tr><td>排他锁</td><td>当更新数据库数据时，系统会为变更资源添加独占锁，如果该资源被锁定，就无法再对其放置独占锁。<br>    独占锁不能与其他锁兼容，即只能放一个独占锁<br>    并发性最差，运行单事务访问，其他事务访问要等待。</td></tr><tr><td>更新锁</td><td>更新sql，会对资源先进行加共享锁，用于数据查询，之后进行数据更新时，共享锁升级为独占锁。<br>    两个事务都获取了同一数据资源的共享锁，然后升级为独占锁时，需要等待共享锁的解除，这就造成了死锁。<br>    更新锁和共享锁是兼容的额，资源可同时放更新锁和共享锁，但最多放置一把更新锁<br>    允许多个事务同时读锁定的资源，但不允许其他事物修改它。</td></tr><tr><td></td><td>意向锁的目的是保证表锁和行锁的共存<br>    当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁，如果需要的是某行的排他锁定，则申请一个意向排他锁。<br>   意向锁是表级别锁<br><a href="https://blog.csdn.net/zcl_love_wx/article/details/82015281" target="_blank" rel="noopener"><strong>一分钟深入Mysql的意向锁——《深究Mysql锁》</strong></a></td></tr></tbody></table><h4 id="1-4-数据库事务隔离机制"><a href="#1-4-数据库事务隔离机制" class="headerlink" title="1.4 数据库事务隔离机制"></a>1.4 数据库事务隔离机制</h4><ul><li>Read Uncommitted 读写均不使用锁，拥有最高的并发性和吞吐性</li><li>Read Committed 使用写锁，保证不会出现脏读，但会造成不可重复读，即读不加锁时，中间会有事务去改变读的数据（行级），造成两次读取不一致。</li><li>Repeatable Read 使用读锁和写锁，解决不可重复读的问题，但会有幻读（表级）。</li><li>Serializable 使用事务串形化调度，避免出现因为插入数据没法加锁导致的不一致的情况</li></ul><h3 id="2-Spring事务"><a href="#2-Spring事务" class="headerlink" title="2.Spring事务"></a>2.Spring事务</h3><h4 id="2-1-Spring对事务的支持"><a href="#2-1-Spring对事务的支持" class="headerlink" title="2.1 Spring对事务的支持"></a>2.1 Spring对事务的支持</h4><ul><li><p>Spring事务提供了事务模板类TransactionTemplate，通过该模板配合事务回调TransactionCallback指定具体的持久化操作就可以通过编程方式，实现事务管理。</p></li><li><p>面对单数据源情况下，Spring直接使用底层额数据源管理事务。</p></li><li><p>面对多数据源的应用时，Spring寻求JavaEE应用服务器的支持。通过引用应用服务器中的JNDI资源完成JTA事务。</p></li><li><p>Spring事务管理的优势在于，都采用相同事务管理模型，用户可以抛开事务管理的问题编写程序。</p></li></ul><h4 id="2-2-事务管理关键抽象"><a href="#2-2-事务管理关键抽象" class="headerlink" title="2.2 事务管理关键抽象"></a>2.2 事务管理关键抽象</h4><h5 id="2-2-1-PlatformTransactionManager"><a href="#2-2-1-PlatformTransactionManager" class="headerlink" title="2.2.1 PlatformTransactionManager"></a>2.2.1 PlatformTransactionManager</h5><ul><li><p>getTransaction(TransactionDefinition definition) 返回或者创建一个新事务，通过TransactionStatus描述事务的状态。</p></li><li><p>commit（TransactionStatus status）根据事务状态提交事务</p></li><li><p>rollback（TransactionStatus status） 将事务回滚，commit抛出异常时，rollback被隐式调用</p></li></ul><h5 id="2-2-2-TransactionDefinition"><a href="#2-2-2-TransactionDefinition" class="headerlink" title="2.2.2 TransactionDefinition"></a>2.2.2 TransactionDefinition</h5><p>​        用于描述事务的隔离机制，超时时间，是否为只读事务，传播规则等具体控制事务的事务属性，通过xml配置或者注解提供</p><ul><li><p>事务隔离级别</p><table><thead><tr><th>级别</th><th>解释</th></tr></thead><tbody><tr><td>ISOLOCATION_DEFAULT</td><td>数据库默认级别</td></tr><tr><td>ISOLOCATION_READ_UNCOMMITTED</td><td>允许读取未提交的读， 可能导致脏读，不可重复读，幻读</td></tr><tr><td>ISOLOCATION_READ_COMMITTED</td><td>允许读取已提交的读，可能导致不可重复读，幻读</td></tr><tr><td>ISOLOCATION_REPEATABLE_READ</td><td>不能更新另一个事务修改单尚未提交(回滚)的数据，可能引起幻读</td></tr><tr><td>ISOLOCATION_SERIALIZABLE</td><td>序列执行效率低</td></tr></tbody></table></li><li><p>传播级别</p><table><thead><tr><th>级别</th><th>解释</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>当前没有事务就新建，有事务就加入</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，没有就以非事务方式执行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前事务，没有就抛出异常</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，当前存在事务，就将其挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操纵，如果当前存在事务，就将当前事务挂起</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果存在事务，则抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>当前有事务，就嵌套事务内执行，若没有，则执行PROPAGATION_REQUIRED类似的操作</td></tr></tbody></table></li><li><p>事务超时</p><p>​    事务在超时前能运行多久，超过时间后，事务被回滚</p></li><li><p>只读状态</p><p>​    只读事务不修改任何数据</p><h5 id="2-2-3-TransactionStatus"><a href="#2-2-3-TransactionStatus" class="headerlink" title="2.2.3 TransactionStatus"></a>2.2.3 TransactionStatus</h5><p>​      代表一个事务的运行状态，事务管理器通过该接口获取事务运行器的状态信息，可以间接通过该接口回滚事务。</p><pre><code>           -  继承于SavepointManager接口</code></pre><ul><li>Object createSavePoint()</li><li>void rollbackToSavepoint(Object savepoint)  被回滚的保存点将会自动释放</li><li>void releaseSavepoint(Object savepoint) 事务提交后，将会自动释放保存点</li></ul></li><li><p>TransactionStatus扩展</p><ul><li>boolean hasSavepoint()  是否有保存点</li><li>Boolean isNewTransaction 当前事务是否为新事务</li><li>boolean isCompleted 当前事务是否已经提交/回滚</li><li>Boolean i是Rollback Only 是否识为rollback-only<ul><li>setRollbackOnly 将当前事务设置为rollback-only,该事务将只能进行回滚</li></ul></li></ul></li><li><p>底层资源不支持保存点时，会抛出Nested Transaction NotSupported Exception</p></li></ul><h4 id="2-3-配置事务（针对注解）"><a href="#2-3-配置事务（针对注解）" class="headerlink" title="2.3 配置事务（针对注解）"></a>2.3 配置事务（针对注解）</h4><h5 id="2-3-1-使用注解配置事务"><a href="#2-3-1-使用注解配置事务" class="headerlink" title="2.3.1 使用注解配置事务"></a>2.3.1 使用注解配置事务</h5><ul><li>可对需要事务增强的Bean接口，实现类，方法进行标注。</li><li>注解只提供元数据，不能完成事务切面织入功能</li><li>配置文件增加 <ul><li>&lt;tx:annotation-driven /&gt; 以织入事务管理切面</li><li>proxy-target-class:  Spring  将创建子类来代替业务类，即采用CGLib动态代理,动态字节码技术， false 则采用基于接口的代理，即jdk动态代理</li><li>order ： 除了事务切面外，如果加其他切面，该项用于控制织入顺序</li></ul></li></ul><h5 id="2-3-2-Transactional"><a href="#2-3-2-Transactional" class="headerlink" title="2.3.2 @Transactional"></a>2.3.2 @Transactional</h5><ul><li><p>默认属性</p><table><thead><tr><th>内容</th><th>设置</th></tr></thead><tbody><tr><td>事务传播行为</td><td>PROPAGATION_REQUIRED</td></tr><tr><td>事务的隔离机制</td><td>ISOLATION_DEFAULT</td></tr><tr><td>读写事务属性</td><td>读/写事务</td></tr><tr><td>超时时间</td><td>依赖底层事务系统的默认值</td></tr><tr><td>回滚设置</td><td>运行期异常引发回滚，检查型异常不会引发回滚</td></tr></tbody></table><ul><li>事务只有在发生未捕获的RuntimeException时才回滚</li><li>默认情况下aop只捕获RuntimeException的异常，但可以通过配置来捕获特定的异常并回滚<ul><li>通过 throw new RuntimeException() 抛出运行时异常</li><li>TransactionAspectSupport.currentTransactionStatus.setRollbackOnly(); 手动回滚</li><li>@Transactional（readyOnly = true, rollbaclFor = Exception.class）</li></ul></li></ul></li><li><p>属性说明</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>枚举方式提供事务传播行为</td></tr><tr><td>isolation</td><td>枚举方式，提供事务隔离机制</td></tr><tr><td>readOnly</td><td>事务读写性 boolean 类型</td></tr><tr><td>timeout</td><td>超时时间 int 秒</td></tr><tr><td>rollbackFor</td><td>一组异常类，遇到回滚，逗号隔开 Class&lt;? extends Throwable&gt;[]类型, 默认[]</td></tr><tr><td>rollbackForClassName</td><td>一组异常类。遇到回滚，类型为String[]</td></tr><tr><td>noRollbackForClassName</td><td>同上</td></tr><tr><td>noRollBackFor</td><td>同上</td></tr></tbody></table></li><li><p>位置说明</p><ul><li>基于JDK动态代理 ，可以将@Transactional放置在接口和具体类上，jdk动态代理的实现方式是基于接口实现的，大概流程是。<ul><li>为接口创建代理类的字节码文件</li><li>使用ClassLoader将字节码文件加载到JVM中</li><li>创建代理类实例对象，执行对象的目标方法。</li><li>使用的是反射技术</li></ul></li><li>基于CGLIB类代理，只能将@Transactional放置在具体类上，cglib可以直接代理类，使用的是字节码技术。</li><li>Spring默认用的是基于jdk动态代理。</li><li>注解不能被继承，如果采用CGLib类代理，即proxy-target-class 为true，如果事务注解加到接口上，业务类不会添加事务增强。</li></ul></li><li><p>除有public之外的方法，均不能被事务增强，包括 public static 也不能被增强</p></li><li><p>对于final static private 修饰的方法不能被子类覆盖，相应的无法实施AOP</p></li><li><p>这些不能被Spring事务增强的方法，并非不工作在事务中，只要被外部事务调用，由于Spring的传播机制，内部方法也可以工作在外部方法所启动的事务上下文中。</p></li><li><p>能被增强和不能被增强的唯一区别在于，是否可以主动启动一个新事务，前者可以，后者不能。 针对事务传播行为来说，两者是一样的。 即，如果这些方法被无事务上下文调用，则工作在无事务上下文中，否则，就工作在事务上下文中</p><h4 id="2-4-常见问题汇总"><a href="#2-4-常见问题汇总" class="headerlink" title="2.4 常见问题汇总"></a>2.4 常见问题汇总</h4><ol><li><p>在AOP增强过程中，一个类的两个方法A,B都通过AOP进行了增强，但当A调用B时，不会触发B的增强代码。</p><p><strong>原因</strong>：通过AOP进行增强时，所本质是基于动态代理技术，当外部调用方法A时，本质是代理对象进行调用，所以A方法会得到增强，当A调用B方法时，当前的对象并非代理对象，所以要重新获取代理对象。</p><pre><code>Object proxy = AopContent.currentProxy();//补充：获取当前的被代理类Class&lt;?&gt; targetClass = AopUtils.getTargetClass(proxy)</code></pre><p><strong>注意：</strong> 在Spring的配置文件中要进行一下设置，目的是可以通过AopContent拿到代理</p><pre><code>&lt;aop:aspectj-autoproxy expose-proxy="true"&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre></li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring：抽象类的依赖Bean注入</title>
      <link href="/2019/08/03/spring-chou-xiang-lei-de-yi-lai-bean-zhu-ru/"/>
      <url>/2019/08/03/spring-chou-xiang-lei-de-yi-lai-bean-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​            抽象类在Spring启动时并不会被实例化，固不能采用@Service等注解将其注入，保证其他依赖Bean的注入。所以要采用set方法注入依赖Bean中。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>public abstract class Test{    protected static FlowMapper flowMapper;    @Autowired    public void setFlowMapper(FlowMapper _flowMapper){        this.flowMapper = _flowMapper;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：并发类与接口概述</title>
      <link href="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/"/>
      <url>/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        学习和使用多线程的过程中，遇到很多的类和接口，以下将其进行梳理做概括性描述，方便后期回顾。</p><h3 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h3><h5 id="2-1-Thread"><a href="#2-1-Thread" class="headerlink" title="2.1 Thread"></a>2.1 Thread</h5><p>​        线程类，实现了Runnable接口， 常用于多个线程做多个任务，各做各的（通过static可以实现多个线程做一个任务）。</p><p>​        该类在jdk1.0的时候就已经存在，是创建线程的方式之一，它实现了Runnable接口。可以通过继承Thread类，重写run方法来创建一个线程，实现类调用start()方法便可以启动一个新的线程，同样它的构造方法也可以接受一个Runnable类型的参数创建一个线程。</p><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805144649941%5B1%5D.png" alt=""></p><h5 id="2-2-FutureTask"><a href="#2-2-FutureTask" class="headerlink" title="2.2 FutureTask"></a>2.2 FutureTask</h5><p>​        该类直接实现了RunnableFuture接口，间接实现了Runnble和Future接口。因为实现了Runnbale接口，因此其对象可以作为参数被传递给Thread类启动一个线程，作为Future的一个实现类，调用get()方法拿到线程的执行结果。<br>​        其构造函数可以接受一个Callable类型的参数。</p><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805153659851%5B1%5D.png" alt=""></p><h5 id="2-3-Executors"><a href="#2-3-Executors" class="headerlink" title="2.3 Executors"></a>2.3 Executors</h5><p>​        该类是一个工具类，通过静态方法可以获取到java自带的几种线程池。</p><h5 id="2-4-ExecutorCompletionService"><a href="#2-4-ExecutorCompletionService" class="headerlink" title="2.4 ExecutorCompletionService"></a>2.4 <strong>ExecutorCompletionService</strong></h5><p>​        该类是接口CompletionService的唯一实现类，总的来说，相对于ExecutorService，该类内部会有一个队列，每当任务提交时，该类会调用Executor进行执行，如果任务执行完毕，其结果future对象便会加入到该队列之中，确保该队列获取到的future对象都是已经完成的，以便于进行后续的工作。但是ExecutorServiece执行完毕的之后的Future有可能只是一个空的壳子，内部线程未执行完毕，这时调用get（）方法可能会阻塞，阻碍获取后续已经完成的Future的对象。</p><h3 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h3><h5 id="3-1-Runnable"><a href="#3-1-Runnable" class="headerlink" title="3.1 Runnable"></a>3.1 <strong>Runnable</strong></h5><p>​        该接口也是一个顶层接口，只有一个run方法,创建线程的方式之一就是实现该类，重写run方法，将实现类作为参数，传递给Thread的构造方法启动一个新的线程，同样在jdk1.0中就已经出现。</p><p>​    <strong>备注：通过继承Thread类型实现的多线程，大多是多个线程去做多件事情。而通过实现Runnale接口的多线程，一般是多个线程去做同一件事情，即将一个实现类交给多个线程去运行。</strong></p><h5 id="3-2-Callable"><a href="#3-2-Callable" class="headerlink" title="3.2 Callable"></a>3.2 <strong>Callable</strong></h5><p>​        该接口出现于jdk1.5，目的是作为Runnable的替换类，该类支持执行方法call()返回执行结果，而Runnable方法的run()的返回类型为void。</p><pre><code>V call() throws Exception;</code></pre><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805151420132.png" alt=""></p><h5 id="3-3-Future"><a href="#3-3-Future" class="headerlink" title="3.3 Future"></a>3.3 Future</h5><p>​        该接口同样出现在jdk1.5，配合与Callable使用，Callable的作用是产生结果，而Future的作用则是获取结果。并且该接口设计一种新的模式。</p><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805151901429%5B1%5D.png" alt=""></p><h5 id="3-4-Executor"><a href="#3-4-Executor" class="headerlink" title="3.4 Executor"></a>3.4 <strong>Executor</strong></h5><p>​        多线程的顶层接口，仅有一个方法，接受的是Runnable类型的参数，像ThreadPoolExecutor, ExecutorService 等都是继承或实现了该接口。</p><pre><code>void execute(Runnable command);</code></pre><h5 id="3-5-ExecutorService"><a href="#3-5-ExecutorService" class="headerlink" title="3.5 ExecutorService"></a>3.5 <strong>ExecutorService</strong></h5><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805154624625%5B1%5D.png" alt=""></p><p>​        该接口是对Executor接口的扩展，其submit()方法支持接受Callable类型参数，运行后的结果将会返回到Future中。</p><pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);//支持callable集合的传递，将会返回一个Future的list&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)        throws InterruptedException;&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException;&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                    long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;</code></pre><h5 id="3-6-CompletionService"><a href="#3-6-CompletionService" class="headerlink" title="3.6 CompletionService"></a>3.6 <strong>CompletionService</strong></h5><p>​        该接口仅有一个实现类，该接口作用类似于ExecutorService，但是不同于ExecutorServic</p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805155750310.png" style="zoom:150%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：安全队列</title>
      <link href="/2019/07/13/java-bing-fa-an-quan-dui-lie/"/>
      <url>/2019/07/13/java-bing-fa-an-quan-dui-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        多线程编程中很多地方都是用到了安全队列，故简单做一个总结概括，方便后面查阅。</p><p>​        队列这种数据结构不必做过多解释，安全队列的目的在于在多线程中存在消费者生产者模式，即多个生产者（生产者线程）生产东西，多个消费者（消费者线程）进行消费，这时需要一个中间空间去暂存，这时就需要考虑使用安全队列，保证其流程的安全性。</p><p>​        线程安全的类是指，类内共享的全局变量的访问必须保证是不收多线程形式的影响。</p><h3 id="2-阻塞算法"><a href="#2-阻塞算法" class="headerlink" title="2. 阻塞算法"></a>2. 阻塞算法</h3><h5 id="2-1-方法介绍"><a href="#2-1-方法介绍" class="headerlink" title="2.1 方法介绍"></a>2.1 方法介绍</h5><ul><li><p><strong>可能抛异常</strong>：不满足约束条件时抛异常，如队列满了继续加，会抛异常</p><ul><li>add(e)</li><li>remove()</li><li>element()</li></ul></li><li><p><strong>返回布尔值</strong>:不阻塞，不抛异常，满了继续加返回false</p><ul><li>offer(e)</li><li>poll()</li><li>peek()</li></ul></li><li><p><strong>阻塞方法：</strong> 不满足约束条件，会发生阻塞</p><ul><li>put()</li><li>take()</li></ul></li><li><p><strong>设定等待时间：</strong></p><ul><li>offer(e, timeout, unit)</li><li>poll(timeout, unit)</li></ul></li></ul><p><img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20191009173338129%5B1%5D.png" alt=""></p><h5 id="2-2-阻塞队列（BlockingQueue）"><a href="#2-2-阻塞队列（BlockingQueue）" class="headerlink" title="2.2 阻塞队列（BlockingQueue）"></a>2.2 阻塞队列（BlockingQueue）</h5><ul><li><p><strong>ArrayBlockingQueue</strong></p><p>​    <img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20190805172222378%5B1%5D.png" alt=""></p></li><li><p><strong>LinkedBlockingQueue</strong></p><p><img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20190805172336321%5B1%5D.png" alt=""></p><p>​    <strong>备注： 阻塞算法虽然使用了锁机制，但底层实质上还是CAS算法。</strong></p></li></ul><h5 id="2-3-非阻塞队列（ConcurrentLinkedQueue-）"><a href="#2-3-非阻塞队列（ConcurrentLinkedQueue-）" class="headerlink" title="2.3 非阻塞队列（ConcurrentLinkedQueue ）"></a>2.3 非阻塞队列（<strong>ConcurrentLinkedQueue</strong> ）</h5><p><img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20190805172704363.png" alt=""></p><h5 id="2-4-补充"><a href="#2-4-补充" class="headerlink" title="2.4 补充"></a>2.4 补充</h5><p>​        在消费者生产者模式下，有可能消费者不知道什么时候生产者会生产完毕，如果选择阻塞队列通过阻塞方法获取，如果队列中没有元素存在，可能消费者会被一直阻塞，进而无法下面的系列操作。之前查询获得一种解决办法，被称为“毒丸”策略。<br>​        在生产者生产结束后，可以加一个特殊的对象（“毒丸”）到队列中，当消费者获取到该对象时，表明队列中已经没有了对象，这时该消费者进行线程结束，并且将该对象加入到队列之中，等待其他消费者线程获取，这样就能依次关闭所有的消费者线程。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：CountDownLatch、CyclicBarrier、Semaphore实现分析</title>
      <link href="/2019/07/10/java-bing-fa-countdownlatch-cyclicbarrier-semaphore-shi-xian-fen-xi/"/>
      <url>/2019/07/10/java-bing-fa-countdownlatch-cyclicbarrier-semaphore-shi-xian-fen-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        最近在刷LeeCode多线程相关题目时，经常会遇到一些优质的解答使用了J.U.C包中的三个同步工具类配合。所以在此进行整理，方便日后开发中使用。</p><h3 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="2. CountDownLatch"></a>2. CountDownLatch</h3><p>​        示例代码如下：</p><pre><code>class Foo {    public Foo() {    }    public static void main(String[] args) {        Foo foo = new Foo();        try {            foo.execute();        } catch (Exception e) {            e.printStackTrace();        }    }    public void execute() throws Exception{        CountDownLatch countDownLatch = new CountDownLatch(3);        for (int i = 0; i &lt; 10; i++){            Thread t = new Thread(new TestRunner(countDownLatch));            t.setName(" 我是第 " + i +" 个");            t.start();        }        countDownLatch.await();        System.out.println("finished");    }    class TestRunner implements Runnable{        private CountDownLatch countDownLatch;        public TestRunner(CountDownLatch countDownLatch){            this.countDownLatch = countDownLatch;        }        @Override        public void run() {            try {                Thread.sleep(1000);                System.out.println(Thread.currentThread().getName() + " start execute");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                countDownLatch.countDown();            }        }    }}</code></pre><p>执行结果如下：</p><pre><code>我是第 0 个 start execute 我是第 9 个 start execute 我是第 8 个 start executefinished 我是第 7 个 start execute 我是第 6 个 start execute 我是第 4 个 start execute 我是第 5 个 start execute 我是第 3 个 start execute 我是第 2 个 start execute 我是第 1 个 start execute</code></pre><p>​        CountDownLatch是一个倒计时式的计数器，在初始化的时候可以通过构造参数指定所要统计的线程的数量，每当线程执行一次countDown()方法，计数器减一，当计数器的内部值变为0时，将会开始执行await()方法之后的代码，即允许指定数量的线程执行完毕之后才开始执行。</p><p>​        CountDownLatch基于AQS，是一个共享锁，await()使当前线程阻塞等待。</p><pre><code>// CountDownLatch aqs源码：‘’private static final class Sync                 extends AbstractQueuedSynchronizer {    Sync(int count) {        setState(count);    }    int getCount() {        return getState();    }    //加锁    protected int tryAcquireShared(int acquires) {        return (getState() == 0) ? 1 : -1;    }    //解锁    protected boolean tryReleaseShared(int releases) {        for (;;) {            int c = getState();            if (c == 0)                return false;            int nextc = c-1;            if (compareAndSetState(c, nextc))                return nextc == 0;        }    }}</code></pre><ul><li>await()调用tryAcquireShared(1)方法获取锁，根据共享锁的实现返回值小于0时线程会被阻塞等待，也就是只有当state==0,才会成功解锁。</li><li>countDown()调用tryReleaseShared(1)方法进行解锁，当state为0时，共享锁才算完全释放，会唤醒队列等待的线程。</li><li>CountDownLatch没有复位操作，当state的值为0时，再调用await()就不会阻塞线程了，所以CountDownLatch只能使用一次。</li></ul><h3 id="3-CyclicBarrier"><a href="#3-CyclicBarrier" class="headerlink" title="3. CyclicBarrier"></a>3. CyclicBarrier</h3><p>​        示例代码如下：</p><pre><code>class Foo {    public Foo() {    }    public static void main(String[] args) {        Foo foo = new Foo();        try {            foo.execute();        } catch (Exception e) {            e.printStackTrace();        }    }    public void execute() throws Exception{        CyclicBarrier barrier = new CyclicBarrier(3);        for (int i = 0; i &lt; 10; i++){            Thread t = new Thread(new TestRunner(barrier));            t.setName(" 我是第 " + i +" 个");            t.start();        }        System.out.println("finished");    }    class TestRunner implements Runnable{        private CyclicBarrier barrier;        public TestRunner(CyclicBarrier barrier){            this.barrier = barrier;        }        @Override        public void run() {            try {                System.out.println(Thread.currentThread().getName() + " start execute");                barrier.await();                System.out.println("我朋友他好了");            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p>输出结果如下：</p><pre><code>finished 我是第 0 个 start execute 我是第 1 个 start execute 我是第 2 个 start execute我朋友他好了我朋友他好了我朋友他好了 我是第 3 个 start execute 我是第 4 个 start execute 我是第 5 个 start execute我朋友他好了我朋友他好了我朋友他好了 我是第 6 个 start execute 我是第 7 个 start execute 我是第 8 个 start execute我朋友他好了我朋友他好了我朋友他好了 我是第 9 个 start execute</code></pre><p>​        CyclicBarrier是可循环的同步屏障，如上示例，构造函数赋值为3，所以每次屏障会拦截三个线程，待三个线程同时抵达屏障时，屏障被打破，线程执行后面逻辑代码。与此同时，循环截取后面的三个线程，依次循环。</p><p>​        CyclicBarrier使用一个重入锁实现。</p><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>​        示例代码如下：</p><pre><code>class Foo {    public Foo() {    }    public static void main(String[] args) {        Foo foo = new Foo();        try {            foo.execute();        } catch (Exception e) {            e.printStackTrace();        }    }    public void execute() throws Exception{        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i &lt; 10; i++){            Thread t = new Thread(new TestRunner(semaphore));            t.setName(" 我是第 " + i +" 个");            t.start();        }        System.out.println("finished");    }    class TestRunner implements Runnable{        private Semaphore semaphore;        public TestRunner(Semaphore _semaphore){            this.semaphore = _semaphore;        }        @Override        public void run() {            try {                semaphore.acquire();                System.out.println(Thread.currentThread().getName() + " start execute");                Thread.sleep(2000);                semaphore.release();            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p>执行结果如下：</p><pre><code>finished 我是第 0 个 start execute 我是第 1 个 start execute 我是第 2 个 start execute 我是第 3 个 start execute 我是第 4 个 start execute 我是第 5 个 start execute 我是第 7 个 start execute 我是第 8 个 start execute 我是第 6 个 start execute 我是第 9 个 start execute</code></pre><p>​        <strong>Semaphore</strong>是一个计数信号量，常用于限制可以访问某些资源线程数目。</p><p>​        以上示例代码，每个2s,打印三行数据，即第1,2,3线程，执行semaphore.acquire()先进来，然后置于睡眠状态，4进来时，semaphore并未执行release（）方法，故而会阻塞，接着1,2,3线程依次执行release(),4,5,6线程进入睡眠状态，依此循环，保证限制线程执行的数目为3条。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>CountDownLatch</strong>为计数器，设定初始值，当数值内所有线程执行完毕，才是执行接下来的逻辑。</li><li><strong>CyclicBarrier</strong>为屏障，设定初始值，当数值内所有线程到达指定位置，才进行屏障移除，但可重复。</li><li><strong>Semaphone</strong>为计数信号量，设定初始值，每次线程获取减一，释放加一，其他线程要执行，必须等待令牌释放，即固定了同时只能有指定值个线程在处理资源任务。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：Synchronized 和 volatile</title>
      <link href="/2019/07/07/java-bing-fa-synchronized-he-volatile/"/>
      <url>/2019/07/07/java-bing-fa-synchronized-he-volatile/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        <strong>synchronized</strong>作为Java的线程安全相关的关键字可以修饰的地方包括：代码块、对象、方法、类以及静态方法。</p><p>​        <strong>volatile</strong>则一般用来修饰属性。</p><h3 id="2-Synchronized"><a href="#2-Synchronized" class="headerlink" title="2. Synchronized"></a>2. Synchronized</h3><h5 id="2-1-代码块"><a href="#2-1-代码块" class="headerlink" title="2.1 代码块"></a>2.1 代码块</h5><ul><li>一个线程访问一个对象中的Synchronized（this）同步代码块时，其他试图访问该对象的线程将会被阻塞，例如，起两个thread，使用同一个Runnable对象实例，将会阻塞一个。</li><li>如果启动两个线程，两个Runnable实例，则因为锁对象不同，不会造成阻塞</li><li>当一个对象包含同步块代码和非同步快代码时，同步块代码会阻塞线程，但是非同步代码块将不会造成阻塞</li></ul><h5 id="2-2-对象加锁"><a href="#2-2-对象加锁" class="headerlink" title="2.2 对象加锁"></a>2.2 对象加锁</h5><ul><li><p>即Runnable对象将会接受一个对象参数进去，以此对象参数作为锁对象，可以保证线程对该对象参数的修改保证同步和阻塞</p></li><li><p>如果没有明确的锁对象，只想让一段代码同步，可以创建一个特殊的对象来当锁</p><p>private byte[] = new byte[0]    内部只要三行代码实现</p></li></ul><h5 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h5><ul><li>类似于代码块，但是范围作用域不一样</li><li>Synchronized不可被继承</li><li>父类加了同步锁，子类如果需要，要自行加同步锁</li><li>但子类调用父类方法，想当于加同步锁</li><li>定义接口不能使用synchronized关键字</li><li>构造方法不能使用synchronized，但是代码块可以</li></ul><h5 id="2-4-类"><a href="#2-4-类" class="headerlink" title="2.4 类"></a>2.4 类</h5><ul><li>修饰一个类，对于该类的所有对象而言都是同一把锁，类似于修饰一个静态方法，synchronized(Test.class)。</li></ul><h5 id="2-5-静态方法"><a href="#2-5-静态方法" class="headerlink" title="2.5 静态方法"></a>2.5 静态方法</h5><ul><li>因为静态方法属于类，所以加的同步锁将会对该类的所有对象而言，是同一把锁，前提是这些对象内部都调用了该静态方法。</li></ul><h3 id="3-Volatile"><a href="#3-Volatile" class="headerlink" title="3. Volatile"></a>3. Volatile</h3><ul><li>不能保证原子性，volatile提供的可见性，是说每一个线程访问使用volatile修饰的变量，都会直接从主存区中读到最新的值。</li><li>反之，线程修改后同步到主存的值，也要保证对其他线程的可见。</li><li>因为非原子性，不能保证线程安全，简单的一次性读写操作是允许的，但是 i++就不行，因为这是一次读加一次写。</li><li>可以用的场景：对一个变量，跟新其值的时候不依赖于当前的值。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><strong><em>两者的差异：</em></strong></p><ul><li>synchronized获得并释放监视器，如果两个线程使用一把对象锁，监视器能强制保证代码块同时只被一个线程执行</li><li>synchronized也会同步内存，在“主”内存区域会同步整个线程的内存</li><li>synchronize的步骤：<ul><li>线程请求获得见识this对象的对象锁</li><li>线程内存的数据被消除，从“主”内存区域中读取</li><li>代码块被执行</li><li>对于变量的任何改变，安全的写入到“主”内存区域中</li><li>线程释放监视this对象的对象锁</li></ul></li></ul><p><strong><em>补充：并发的三个概念</em></strong></p><ul><li><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就不会被执行。</li><li><strong>可见性</strong>：多线程修改一个变量，该变量的变化，对于其他的线程都是可见的。</li><li><strong>有序性</strong>：处理器为了提升程序运行效率，会进行指令重排序，单线程情况下可能两个结果不会相互影响，顺序调换不会导致出现问题，但是多线程情况下，调换顺序，可能导致程序运行失败。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：线程池</title>
      <link href="/2019/06/28/java-bing-fa-xian-cheng-chi/"/>
      <url>/2019/06/28/java-bing-fa-xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        线程池是由很多线程组成，来一个任务，取一个线程处理这个任务。</p><p>​        线程池的线程数目取决于两个参数：</p><ul><li><strong>核心池大小</strong><ul><li>当前线程小于核心池大小时，当任务来临，优先创建新的线程执行任务</li><li>如果当前线程达到了核心池的大小，则任务会被置到队列中，队列是存在上限的。</li></ul></li><li><strong>最大池大小</strong><ul><li>当队列达到上限时，若当前线程数小于最大线程数，则创建线程执行任务。</li><li>若当前线程已经达到了最大线程数，则考虑丢弃任务。</li></ul></li></ul><h3 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2.ThreadPoolExecutor"></a>2.ThreadPoolExecutor</h3><p>​        ThreadPoolExecutor的实现的顶层接口是Executor，自身继承了抽象类AbstractExecutorService,该抽象类实现了ExecutorService接口。</p><h5 id="2-1-构造函数参数"><a href="#2-1-构造函数参数" class="headerlink" title="2.1 构造函数参数"></a>2.1 构造函数参数</h5><table><thead><tr><th>参数</th><th>介绍</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心池大小，不会随线程池的创建而启动，直到有任务提交才开始启动线程。若一开始想创建所有核心线程需调用prestartAllCoreThreads方法</td></tr><tr><td>maximumPoolSize</td><td>最大池大小，当前核心池满，且队列阻塞，才会判断是否要产生新的线程</td></tr><tr><td>keepAliveTime</td><td>线程数大于核心时，多余的空闲线程最多存活时间</td></tr><tr><td>unit</td><td>keppAliveTime参数的时间单位</td></tr><tr><td>workQueue</td><td>线程数目超过核心池大小时，存放任务的队列</td></tr><tr><td>threadFactory</td><td>创建线程时使用的工厂</td></tr><tr><td>handler</td><td>队列阻塞，且线程池达到最大值所要采取的饱和策略</td></tr></tbody></table><ul><li><p><strong>workQueue</strong>包含三种类型：</p><ul><li>无界队列</li></ul><p><img src="/2019/06/28/java-bing-fa-xian-cheng-chi/1573457063835.png" alt="1573457063835"></p><ul><li><p>有界队列</p><p>​                <img src="/2019/06/28/java-bing-fa-xian-cheng-chi/1573457116805.png" alt="1573457116805"></p></li><li><p>同步移交</p><p>​    <img src="/2019/06/28/java-bing-fa-xian-cheng-chi/1573457206470.png" alt="1573457206470"></p></li></ul></li><li><p><strong>handler</strong>包括四种类型：</p><ul><li><em>终止（AbortPolicy)</em>：饱和时会抛出RejectedExecutionException。</li><li><em>抛弃（DiscardPolicy）</em>：不做任何处理，直接抛弃。</li><li><em>抛弃最旧（DiscardOldestPolicy）</em>：<ul><li>抛弃旧任务策略</li><li>优先队列，优先级最高的任务会被抛弃</li><li>普通队列，头元素将会被抛弃</li></ul></li><li><em>调用者运行(CallerRunsPolicy)</em>：不抛弃任务，也不抛异常，线程饱和之后，将由线程池的主线程自己来执行任务，这段是时间主线程无法提交新的任务，从而使其他线程有时间将正在处理的任务处理完成。</li></ul><p>​         <strong><em>ThreadPoolExecutor有四个构造器,区别在于是否采用了默认的处理策略和工厂，以下为Java自带的四种线程池所采用的默认策略的构造器。</em></strong></p><pre><code>//这个构造器采用了默认的工厂和处理器 public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             Executors.defaultThreadFactory(), defaultHandler);    }//这个构造器仅仅采用了默认的处理器public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             threadFactory, defaultHandler);    }//这个构造器仅仅采用了默认的工厂   public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              RejectedExecutionHandler handler) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             Executors.defaultThreadFactory(), handler);    }//标准构造器，一般创建线程池均采用该构造器 public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) {        if (corePoolSize &lt; 0 ||            maximumPoolSize &lt;= 0 ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; 0)            throw new IllegalArgumentException();        if (workQueue == null || threadFactory == null || handler == null)            throw new NullPointerException();        this.acc = System.getSecurityManager() == null ?                null :                AccessController.getContext();        this.corePoolSize = corePoolSize;        this.maximumPoolSize = maximumPoolSize;        this.workQueue = workQueue;        this.keepAliveTime = unit.toNanos(keepAliveTime);        this.threadFactory = threadFactory;        this.handler = handler;    }</code></pre><p>使用实例：</p><pre><code>BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;Runnable&gt;(1000, true);        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 10, 30, TimeUnit.SECONDS, workQueue, new ThreadFactory() {            @Override            public Thread newThread(Runnable r) {                Thread t = new Thread(r);                t.setName(threadName);                return t;            }        }, new ThreadPoolExecutor.AbortPolicy());</code></pre></li></ul><p>  <strong>其他的预留方法</strong>：</p><p>  ​        预留方法用以实现监控、日志等功能。</p><ul><li>beforeExecute(Thread t, Runnable r)</li><li>afterExecute(Thread t, Runnable r)</li><li>terminated()</li></ul><h5 id="2-2-线程池中线程的任务状态"><a href="#2-2-线程池中线程的任务状态" class="headerlink" title="2.2 线程池中线程的任务状态"></a>2.2 线程池中线程的任务状态</h5><table><thead><tr><th>状态</th><th>简介</th></tr></thead><tbody><tr><td>running</td><td>初始状态，接受新任务并且处理已经在队列中的任务，shutdown（）进入shutdown状态，shutdownNow()进入stop状态</td></tr><tr><td>shutdown</td><td>不接受新任务，但处理队列中的任务，shutdownNow()进入stop状态</td></tr><tr><td>stop</td><td>不接受新任务，不处理排队的任务，并中断正在进行的任务</td></tr><tr><td>tidying</td><td>所有任务已终止，workerCount为零，线程转换到状态tidying，回调terminate（）方法</td></tr><tr><td>terminated</td><td>终态，terminated（）执行完成</td></tr></tbody></table><h5 id="2-3-Java自带的四种线程池"><a href="#2-3-Java自带的四种线程池" class="headerlink" title="2.3 Java自带的四种线程池"></a>2.3 Java自带的四种线程池</h5><ul><li><strong>newCachedThreadPool</strong>：<ul><li>提供了无界线程池，可以进行自动线程回收</li><li>内部采用SynchronousQueue</li></ul></li></ul><pre><code>public static ExecutorService newCachedThreadPool() {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue&lt;Runnable&gt;());    }//需要指定工厂public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue&lt;Runnable&gt;(),                                      threadFactory);    }</code></pre><ul><li><strong>newFixedThreadPool</strong>:<ul><li>线程数量固定，使用无限大的队列</li><li>内部采用LinkedBlockingQueue</li></ul></li></ul><pre><code>//指定核心线程池大小和最大池大小public static ExecutorService newFixedThreadPool(int nThreads) {        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());}//指定核心线程池大小和最大池大小，以及工厂public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;(),                                      threadFactory);}</code></pre><ul><li><strong>newScheduleThreadPool</strong>:<ul><li>创建一个定长线程池，支持定时，以及周期性任务执行</li><li>内部采用 DelayedWorkQueue</li></ul></li></ul><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {        return new ScheduledThreadPoolExecutor(corePoolSize);}public static ScheduledExecutorService newScheduledThreadPool(            int corePoolSize, ThreadFactory threadFactory) {        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);}</code></pre><ul><li><strong>newSingleThreadExecutor</strong>：<ul><li>内部使用ScheduledThreadPoolExecutor（1）</li><li>使用装饰器模式，确保只有一个线程顺序执行任务，保证线程意外终止后会创建一个线程继续执行任务</li></ul></li></ul><pre><code>public static ExecutorService newSingleThreadExecutor() {        return new FinalizableDelegatedExecutorService            (new ThreadPoolExecutor(1, 1,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;()));    }public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {        return new FinalizableDelegatedExecutorService            (new ThreadPoolExecutor(1, 1,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;(),                                    threadFactory));    }  //可以看到该线程池的内部实质返回的是一个FinalizableDelegatedExecutorService的对象</code></pre><p>补充：</p><ul><li><p><strong>ScheduledThreadPoolExecutor</strong></p><p>​        这个线程池继承了ThreadPoolExecutor类，实现了ScheduledExecutorService接口, 其中该接口的作用和Timer/TimerTask类似，目的是解决那些需要任务重复执行的问题。而实现该接口之后，便可以进行周期性任务调度。</p></li></ul><pre><code>public class ScheduledThreadPoolExecutor        extends ThreadPoolExecutor        implements ScheduledExecutorService{}</code></pre><p><strong>注意：Java部分自带的线程池的实现方式采用了无界队列，即比如LinkedBlockingQueue没有设置大小，在部分场景下可能会造成一些严重问题，因此在使用线程池时，优先推荐自行对线程池的实现。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：锁</title>
      <link href="/2019/06/22/java-bing-fa-suo/"/>
      <url>/2019/06/22/java-bing-fa-suo/</url>
      
        <content type="html"><![CDATA[<h3 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1. 悲观锁和乐观锁"></a>1. 悲观锁和乐观锁</h3><h5 id="1-1-悲观锁"><a href="#1-1-悲观锁" class="headerlink" title="1.1 悲观锁"></a>1.1 悲观锁</h5><ul><li>线程会锁住同步资源</li><li>认为自身在修改数据时，一定会有人来修改，所以要加锁保证不会被修改。</li><li>synchronized和Lock的实现都是悲观锁</li><li>适合写操作多的场景，加锁保证写数据的正确性</li></ul><h5 id="2-1-乐观锁"><a href="#2-1-乐观锁" class="headerlink" title="2.1 乐观锁"></a>2.1 乐观锁</h5><ul><li>线程不会锁住同步资源</li><li>使用数据时，别的线程不会进行修改，在更新数据是需要判断是否有别的线程跟新了数据，如果发生了更新，则根据不同的实现方式执行不同的操作。如果为更新，将自己修改的数据重新写入。</li><li>使用无锁编程，最常用的就是CAS算法</li><li>Java原子类的递增就是通过CAS自旋实现的</li><li>适合读操作多的场景，不加锁提升读操作的性能</li></ul><h3 id="2-自旋锁和适应性自旋锁"><a href="#2-自旋锁和适应性自旋锁" class="headerlink" title="2. 自旋锁和适应性自旋锁"></a>2. 自旋锁和适应性自旋锁</h3><h5 id="2-1-自旋锁"><a href="#2-1-自旋锁" class="headerlink" title="2.1 自旋锁"></a>2.1 自旋锁</h5><ul><li><p>锁住同步资源，线程不会阻塞</p></li><li><p>自旋锁的目的在于，部分场景下，同步资源锁定的时间很短，线程挂起和恢复的代价可能很高，采用自旋锁，可以让线程自旋稍等一下，等到前面锁定同步资源的线程已经释放锁，线程就不必阻塞，直接获取资源，避免线程切换。</p></li><li><p>缺点：不能代替阻塞，如果锁被占用时间很长，自旋只会浪费处理器资源，所以自旋有一定的限度，默认10次，没有获取到锁，就挂起。</p></li><li><p>自旋锁的实现同样也是CAS</p></li><li><p>自旋锁只出现在轻量级锁中，重量级中不使用，线程会阻塞</p></li></ul><h5 id="2-2-适应性自旋锁"><a href="#2-2-适应性自旋锁" class="headerlink" title="2.2 适应性自旋锁"></a>2.2 适应性自旋锁</h5><ul><li><p>自旋时间和次数不再固定，由前一次所上的自旋时间和锁的拥有者的状态来决定</p></li><li><p>在一个锁对象上，自旋等待成功，并且持有锁的线程正在运行，虚拟机会认为自旋有可能再次成功，允许自旋等待更长时间</p></li><li><p>如果一个锁很少成功，后面的尝试可能会省掉自旋过程，直接阻塞线程，避免浪费处理器资源</p></li></ul><h3 id="3-无锁"><a href="#3-无锁" class="headerlink" title="3. 无锁"></a>3. 无锁</h3><ul><li>不锁住资源，多个线程只有一个能修改资源成功，其他线程会重试</li><li>没有对资源进行锁定，所有线程访问一个资源，只有一个会修改成功</li><li>特点在于，修改操作在循环内进行，不断尝试修改资源，没有冲突就改完退出，否则继续尝试，直至修改成功</li><li>CAS的应用就是无锁的实现</li></ul><h3 id="4-偏向锁"><a href="#4-偏向锁" class="headerlink" title="4. 偏向锁"></a>4. 偏向锁</h3><ul><li>同一个线程执行同步资源时自动获取资源</li><li>指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价</li><li>出现的原因在于，不存在多线竞争，锁总是由一个线程多次获得，目标就是在只有一个线程同步代码块时能够提升性能，尽量减少不必要的轻量级执行路径</li><li>只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放锁，撤销偏向锁之后，恢复到无锁或轻量级锁的状态</li><li>JDK6以后的JVM里是默认启动的，可以通过JVM参数进行关闭</li></ul><h3 id="5-轻量级锁和重量级锁"><a href="#5-轻量级锁和重量级锁" class="headerlink" title="5.轻量级锁和重量级锁"></a>5.轻量级锁和重量级锁</h3><h5 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5.1 轻量级锁"></a>5.1 轻量级锁</h5><ul><li>多个线程竞争同步资源时，没有获取资源的线程自旋等待释放锁</li><li>当锁是偏量级锁的时候，被另外的线程访问，偏向锁会自动升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能</li><li>若当前只有一个等待线程，则该线程通过自旋等待，但当自旋超过一定的次数，或一个线程在持有锁，一个在自旋，又来第三个访问者，轻量级锁自动升级为重量级的锁</li></ul><h5 id="5-2-重量级锁"><a href="#5-2-重量级锁" class="headerlink" title="5.2 重量级锁"></a>5.2 重量级锁</h5><ul><li>多个线程竞争同步资源时，没有获取资源的线程等待唤醒</li><li>将除了拥有锁的线程之外的线程都阻塞</li></ul><h3 id="6-公平锁和非公平锁"><a href="#6-公平锁和非公平锁" class="headerlink" title="6. 公平锁和非公平锁"></a>6. 公平锁和非公平锁</h3><h5 id="6-1-公平锁"><a href="#6-1-公平锁" class="headerlink" title="6.1 公平锁"></a>6.1 公平锁</h5><ul><li>多个线程按照申请锁的顺序来获取锁，线程直接进入队列排队，第一个线程才能获得锁</li><li>优点：等待锁的线程不会饿死</li><li>缺点：整体的吞吐效率相比非公平锁要低，等待队列中，除了第一个线程之外，所有的线程都会阻塞，CPU唤醒阻塞线程的开销要比非公平锁大</li></ul><h5 id="6-2-非公平锁"><a href="#6-2-非公平锁" class="headerlink" title="6.2 非公平锁"></a>6.2 非公平锁</h5><ul><li>先尝试插队，插队失败再排队</li><li>多个线程加锁时，直接获取锁，获取不到才到队列的队尾等待，若锁刚好可用，线程无需阻塞，可直接获取锁</li><li>所有非公平锁可能出现后申请锁的线程先获取锁的场景</li><li>优点：减少唤起线程的开销，整体的吞吐效率高，线程有几率不阻塞直接获取锁，CPU不必唤醒所有线程</li><li>缺点：等待队列中的线程可能会饿死，或等很久才会获取锁</li></ul><h3 id="7-可重入锁和不可重入锁"><a href="#7-可重入锁和不可重入锁" class="headerlink" title="7. 可重入锁和不可重入锁"></a>7. 可重入锁和不可重入锁</h3><h5 id="7-1-可重入锁"><a href="#7-1-可重入锁" class="headerlink" title="7.1 可重入锁"></a>7.1 可重入锁</h5><ul><li>一个线程中多个流程可以获取同一把锁。</li><li>又名递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响</li><li>ReentranLock和synchronized都是可重入锁</li><li>优点是，一定程度上避免死锁</li></ul><h5 id="7-2-不可重入锁"><a href="#7-2-不可重入锁" class="headerlink" title="7.2 不可重入锁"></a>7.2 不可重入锁</h5><ul><li>和重入锁相反</li></ul><h3 id="8-共享锁和排他锁"><a href="#8-共享锁和排他锁" class="headerlink" title="8. 共享锁和排他锁"></a>8. 共享锁和排他锁</h3><h5 id="8-1-共享锁"><a href="#8-1-共享锁" class="headerlink" title="8.1 共享锁"></a>8.1 共享锁</h5><ul><li>多线程能共享同一把锁</li><li>指该锁可被多个线程所持有，线程对数据加上锁之后，其他线程只能给数据加共享锁，不能加其他锁，获得共享锁的线程只能读数据，不能写数据</li></ul><h5 id="8-2-排他锁"><a href="#8-2-排他锁" class="headerlink" title="8.2 排他锁"></a>8.2 排他锁</h5><ul><li><p>多线程不能共享同一把锁</p></li><li><p>指该锁一次只能被一个线程所持有，线程对数据加上锁之后，其他线程不能再对A加任何类型的锁，获得排他锁的线程既能读又能修改数据</p></li></ul><p><strong>排他锁和共享锁也是通过AQS来实现的。</strong></p><h3 id="9-其他锁"><a href="#9-其他锁" class="headerlink" title="9. 其他锁"></a>9. 其他锁</h3><h5 id="9-1-读写锁"><a href="#9-1-读写锁" class="headerlink" title="9.1 读写锁"></a>9.1 读写锁</h5><ul><li>一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程</li><li>java中的读写锁通过ReentrantReadWriteLock实现</li></ul><h5 id="9-2-分段锁"><a href="#9-2-分段锁" class="headerlink" title="9.2 分段锁"></a>9.2 分段锁</h5><ul><li>ConcurrentHashMap采用了分段锁</li></ul><h5 id="9-3-互斥锁"><a href="#9-3-互斥锁" class="headerlink" title="9.3 互斥锁"></a>9.3 互斥锁</h5><ul><li>一次最多只能有一个线程持有的锁</li><li>jdk的synchronized</li><li>juc的Lock</li></ul><h5 id="9-4-闭锁"><a href="#9-4-闭锁" class="headerlink" title="9.4 闭锁"></a>9.4 闭锁</h5><ul><li>是一种同步工具类，可以延迟线程的进度直到到达终止条件</li><li>在闭锁到达结束条件之前，这扇门是一直关的，当到达结束条件之后，门打开允许所有线程通过，当闭锁达到结束状态之后，将不会再改变状态，门一直打开，确保其他活动的完成</li><li>CountDownLatch就是一种灵活的闭锁实现</li></ul><h5 id="9-5-死锁"><a href="#9-5-死锁" class="headerlink" title="9.5 死锁"></a>9.5 死锁</h5><ul><li><p>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去</p></li><li><p>死锁的四个条件：</p><ul><li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li><li><strong>请求与保持条件</strong>：一个进程因请求资源而被阻塞时，对已获得资源保持不放。</li><li><strong>不剥夺条件</strong>：进程已获得资源，在未使用完之前，不能强行剥夺。</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul></li><li><p>避免死锁的方法</p><ul><li>阻止循环等待条件，将系统中的所有资源设置标志位，排序，规定所有的进程申请资源必须以一定的顺序做操作来避免死锁</li></ul></li></ul><h5 id="9-6-活锁"><a href="#9-6-活锁" class="headerlink" title="9.6 活锁"></a>9.6 活锁</h5><ul><li>该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败</li><li>如果不能成功的处理某个消息，那么消息处理机制将会回滚整个事务，并将它重新放到队列的开头，因此处理器将会反复调用，并返回相同的结果。</li></ul><h3 id="10-其它概念"><a href="#10-其它概念" class="headerlink" title="10. 其它概念"></a>10. 其它概念</h3><h5 id="10-1-锁消除"><a href="#10-1-锁消除" class="headerlink" title="10.1 锁消除"></a>10.1 锁消除</h5><ul><li>锁消除的判断依据是源于逃逸分析的数据支持，如果在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那么就可以把他们当做栈上的数据对待，认为他们是线程私有的，同步加锁自然无需进行</li><li>比如StringBuffer的append（）方法连续多个出现在一个方法内</li></ul><h5 id="10-2-锁粗化"><a href="#10-2-锁粗化" class="headerlink" title="10.2 锁粗化"></a>10.2 锁粗化</h5><ul><li>如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中，那么即使没有线程竞争，频繁的进行互斥同步操作也导致不必要的性能损耗，所以可以将锁的同步范围扩展到整个操作序列的外部，这种行为称为锁粗化</li></ul><p><strong>锁的状态只能升级，不能降级：无锁 – 偏向锁 – 轻量级锁 – 重量级锁</strong></p><p><strong>偏向锁tongue对比Mark Word 解决加锁问题，避免CAS操作，而轻量级锁是通过CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能，重量级锁是将除了拥有锁的线程之外的线程都阻塞。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：深入解析CAS</title>
      <link href="/2019/06/16/java-bing-fa-shen-ru-jie-xi-cas/"/>
      <url>/2019/06/16/java-bing-fa-shen-ru-jie-xi-cas/</url>
      
        <content type="html"><![CDATA[<h3 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1. 悲观锁和乐观锁"></a>1. 悲观锁和乐观锁</h3><h4 id="1-1-悲观锁"><a href="#1-1-悲观锁" class="headerlink" title="1.1 悲观锁"></a>1.1 悲观锁</h4><p>​        悲观锁较常见于传统的关系型数据库的锁机制，比如行锁，表锁，读锁，写锁等，都会在操作之前上锁，保证同时只有一个线程进行修改。悲观锁总是假设最坏的情况，即每次拿数据时，都会认为别人会进行数据的修改，因为每次操作必须进行上锁。<strong>java中的synchronized关键字的实现就是悲观锁</strong>。</p><p>​    <em>悲观锁的缺陷：</em></p><ul><li>多线程竞争下，加锁，释放锁会导致较多的上下文切换和调度延时，引起性能问题。</li><li>一个线程持有锁会导致其他所有需要此锁的线程挂起。</li><li>优先级高的线程等待优先级低的线程释放锁，会导致优先级倒置，引起性能风险。</li></ul><h4 id="1-2-乐观锁"><a href="#1-2-乐观锁" class="headerlink" title="1.2 乐观锁"></a>1.2 乐观锁</h4><p>​        乐观锁，在每次拿数据时，都认为别人不会进行数据的修改，因为不会上锁，但需要在更新的时候判断一下此期间是否有人去更新这个数据。<strong>java 中的java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</strong>适用于多读的应用类型。</p><p>​        乐观锁如果在正式对数据是否产生并发冲突进行检测，发现了冲突存在，则会返回用户错误信息，并且不会被挂起。乐观锁的主要步骤就是：<strong>冲突</strong>与<strong>检测和数据更新</strong>。</p><h3 id="2-CAS-Compare-and-Swap"><a href="#2-CAS-Compare-and-Swap" class="headerlink" title="2. CAS(Compare and Swap)"></a>2. CAS(Compare and Swap)</h3><h4 id="2-1-概念解析"><a href="#2-1-概念解析" class="headerlink" title="2.1 概念解析"></a>2.1 概念解析</h4><p>​        CAS是乐观锁技术，乐观锁是一个思想概念，CAS是乐观锁的一种实现。</p><p>​        <em>CAS的操作包含三个操作数：</em></p><ul><li><p>需要读写的内存位置（V）</p></li><li><p>进行比较的预期原值（A）</p></li><li><p>拟写入的新值（B）    </p><p>​    如果内存位置V的值和预期原值A相匹配，即相同，没有发生改变，则处理器将会自动把该位置的值更新为新值B,否则不做任何操作。并且在CAS指令之前都会返回该位置的值。即V处应该是A，结果是A，那就替换成B，否则不做改动，将V处的值告诉我。</p></li></ul><h4 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h4><p>​        以下是 java.util.concurrent.atomic包下的AtomicInteger的部分源码：</p><pre><code>public class AtomicInteger extends Number implements java.io.Serializable {     private static final long serialVersionUID = 6214790243416807050L;     //在没有锁的机制下，字段value要使用volatile，来保证数据在线程间是可见的。     private volatile int value;     public AtomicInteger(int initialValue) {        value = initialValue;    }     public final int get() {        return value;    }    public final void set(int newValue) {        value = newValue;    }     public final int getAndSet(int newValue) {        return unsafe.getAndSetInt(this, valueOffset, newValue);    }    //prev拿到原始值，next拿到新值，采用compareAndSet方法进行CAS操作，其返回的是boolean值，即在自旋过程中，如果修改失败，则继续自旋重试，直到数据修改成功。      public final int updateAndGet(IntUnaryOperator updateFunction) {        int prev, next;        do {            prev = get();            next = updateFunction.applyAsInt(prev);        } while (!compareAndSet(prev, next));        return next;    }    //利用JNI（Java Native Interface）来完成CPU指令的操作     public final boolean compareAndSet(int expect, int update) {        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    }}</code></pre><h4 id="2-3-CAS的缺点："><a href="#2-3-CAS的缺点：" class="headerlink" title="2.3 CAS的缺点："></a>2.3 CAS的缺点：</h4><ul><li><p>ABA问题</p><p>​    如果内存地址V初次读取的值是A，期间被改成B，之后又被改回A，那么CAS操作就会认为它从来没有变过，这个漏洞称为CAS的“ABA”问题。java的atomic包提供了AtomicStampedReference类来解决ABA问题，其作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p>循环时间长，开销大</p><p>​    自旋CAS如果长时间不成功，会给CPU带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作</p><p>​    可以采用CAS来保证单个共享变量的原子操作，但当有多个共享变量操作时，CAS无法保证操作的原子性，可以采用锁机制，或者将多个原子变量合成一个来进行操作。<strong>Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></p></li></ul><h4 id="2-4-拓展"><a href="#2-4-拓展" class="headerlink" title="2.4 拓展"></a>2.4 拓展</h4><h5 id="2-4-1-CAS与Synchronized"><a href="#2-4-1-CAS与Synchronized" class="headerlink" title="2.4.1 CAS与Synchronized"></a>2.4.1 CAS与Synchronized</h5><ul><li><p>对于竞争资源较少的情况，使用synchronized同步锁进行线程阻塞和唤醒切换用户内核的切换操作会浪费额外的cpu资源；而CAS基于硬件实现，不需进入内核，不需切换线程，自旋几率较少，因此可以获得更高的性能。</p></li><li><p>对于竞争资源较多的情况：CAS自旋的概率会比较大，从而浪费更多的cpu资源，效率较低</p></li><li><p>synchronized在1.6之后进行了优化，底层主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了吞吐量。冲突较低时，和CAS性能基本类似，冲突较高时，性能远胜CAS。</p></li><li><p>concurrent包基本上有一个通用的实现模式</p><ul><li>首先声明共享变量为volatile</li><li>使用CAS的原子条件更新来实现线程之间的同步</li><li>配合voliate的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ul></li></ul><p><img src="/2019/06/16/java-bing-fa-shen-ru-jie-xi-cas/1047941-20170319190237932-274252686%5B1%5D.png" alt=""></p><ul><li><p>JVM中的CAS(堆中对象的分配)</p><p>在new object（）时，JVM会为对象在堆上划分存储空间</p><p>单线程情况下，有两种分配策略：</p><ul><li>指针碰撞：适用于内存绝对规整，分配空间只需要将指针向空闲内存进行移动。</li><li>空闲列表：适用于内存非规整的情况，JVM会维护一个内存列表，用于记录内存的使用情况，分配对象的内存时，只需查询分配即可。</li></ul><p>但JVM的运行一般都是非单线程，所以多线程分配对象时，采用空闲列表，即查询空闲列表，分配内存，修改空闲列表等等，这些都是不安全的，有两种策略可以解决：</p><ul><li>CAS:虚拟机采用CAS配合上失败重试的方式保证更新操作的原子性。</li><li>TLAB: 每个线程在java堆中会预先分配一小块内存，即本地线程分配缓冲区（TLAB），线程内部需要分配内存时，直接在TLAB上分配就行，避免了线程冲突。只有当缓冲区的内存用光需要重新分配内存的时候才会进行CAS操作分配更大的内存空间。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：流式数据处理</title>
      <link href="/2019/06/08/java-bing-fa-liu-shi-shu-ju-chu-li/"/>
      <url>/2019/06/08/java-bing-fa-liu-shi-shu-ju-chu-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​            采用JSONWriter + 多线程 + 安全队列 + CountDownLatch实现 Http请求下，请求边处理边以流的形式将结果进行返回。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><pre><code>public void execute(JSONWriter jsonWriter, List&lt;String&gt; ipList, int threadNum, String threadName) throws Exception{    //采用线程安全的队列存放处理信息    Queue&lt;String&gt; queue = new ConcurrentLinkedQueue();    for(String ip : ipList){        //增加一个元素，如果已满则抛出异常        queue.add(ip);    }    jsonWriter.startObject();    jsonWriter.writeKey("xxxxx");    jsonWriter.startArray();    //用于保证threadNum个任务完成后，主线程才继续执行。防止子线程在执行时，主线程结束。    CountDownlatch latch = new CountDownlatch(threadNum);    for(int i = 0; i &lt; threadNum; i++){        new Thread(new IPPingRunner(latch, queue, jsonWriter), threadName + "-" + i).start();    }    //主线程等待，直到threadNum个线程全部执行完毕，即计数器置0    latch.await();    jsonWriter.endArray();    jsonWriter.endObject();    jsonWriter.flush();}class IPPingRunner implements Runnable {    private CountDownLatch latch;    private Queue&lt;String&gt; queue;    private JSONWriter jsonWriter;    public IPPingRunner(CountDownLatch latch, Queue&lt;String&gt; queue, JSONWriter jsonWriter){    this.latch = latch;    this.queue = queue;    this.jsonWriter = jsonWriter;    }    @Override    public void run(){        try{            while(true){                //获取元素，没有则返回null                String ip = queue.poll();                if(ip == null){                    breadk;                }                采用latch作为锁                synchronized(latch){                    jsonWriter.startObject();                    jsonWriter.writeKey("ip");                    jsonWriter.writeValue(ip);                    jsonWriter.writeKey("xxx");                    jsonWriter.writeKey("xx");                    jsonWriter.endObject();                }            }        }catch(Exception e){            logger.error(e.getMessage(), e);        }finally{            //出现异常时，则自动释放            latch.countDown();        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 数据流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程：ThreadLocal</title>
      <link href="/2019/06/02/java-bing-fa-threadlocal/"/>
      <url>/2019/06/02/java-bing-fa-threadlocal/</url>
      
        <content type="html"><![CDATA[<h4 id="1-ThreadLocal-简介"><a href="#1-ThreadLocal-简介" class="headerlink" title="1. ThreadLocal 简介"></a>1. ThreadLocal 简介</h4><p>​            在多线程环境下，一个类的方法被调用，并且该类的方法涉及类自身某个属性的值的变更。那么为保证该属性值在多线程环境下的安全性，有两种选择：1.给方法加锁并且保证属性值的可见性。保证同时只有一个线程可以进入该方法去改变属性值，但会阻塞其他线程，属于<strong>时间换空间</strong>。2.采用ThreadLocal，为每一个线程创建独立的属性值的副本，保证线程修改的是属于当前线程的属性值副本，属于<strong>空间换时间</strong>。</p><p>​            ThreadLocal为每个使用该变量的线程分配一个独立的变量副本。所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。</p><p>​            <strong>示例：private static ThreadLocal<integer> threadLocal = new ThreadLocal();</integer></strong></p><h4 id="2-方法源码介绍"><a href="#2-方法源码介绍" class="headerlink" title="2. 方法源码介绍"></a>2. 方法源码介绍</h4><ul><li><p><strong>中间方法</strong></p><ul><li><p><strong>getMap</strong></p><pre><code>    //获取当前线程的ThreadLocalMap    ThreadLocalMap getMap(Thread t) {        return t.threadLocals;    }</code></pre></li><li><p><strong>createMap</strong></p><pre><code>    //创建ThreadLocalMap    void createMap(Thread t, T firstValue) {        t.threadLocals = new ThreadLocalMap(this, firstValue);    }</code></pre></li><li><p><strong>setInitialValue</strong></p><pre><code>     private T setInitialValue() {         //通过initialValue拿到初始值        T value = initialValue();        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        //自动将初始值放到Map中        if (map != null)            map.set(this, value);        else            createMap(t, value);        return value;    }</code></pre></li></ul></li></ul><ul><li><p><strong>核心方法</strong></p><ul><li><p><strong>set</strong></p><pre><code>     public void set(T value) {         //获取当前线程        Thread t = Thread.currentThread();        //通过当前线程拿到ThreadLocalMap        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }</code></pre></li><li><p><strong>get</strong></p><pre><code>     public T get() {         //获取当前线程        Thread t = Thread.currentThread();        //拿到当前线程的ThreadLocalMap        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) {                @SuppressWarnings("unchecked")                T result = (T)e.value;                return result;            }        }        //ThreadLocalMap如果是null，则获取初始值        return setInitialValue();    }</code></pre></li><li><p><strong>initialValue</strong></p><pre><code>      //初始化的值默认为null      protected T initialValue() {        return null;    }</code></pre></li><li><p><strong>remove</strong></p><pre><code>    public void remove() {        //拿到当前线程的Map，移除掉Map中的内容         ThreadLocalMap m = getMap(Thread.currentThread());         if (m != null)             m.remove(this);     }</code></pre></li></ul></li></ul><h4 id="3-逻辑图"><a href="#3-逻辑图" class="headerlink" title="3.逻辑图"></a>3.逻辑图</h4><p><img src="/2019/06/02/java-bing-fa-threadlocal/1570785755103.png" alt="1570785755103"></p><p>​        <strong>本质是线程通过ThreadLocal 这个属性，将线程变量存储到线程的ThreadLocalMap中。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：字符串类型</title>
      <link href="/2019/04/12/redis-zi-fu-chuan-lei-xing/"/>
      <url>/2019/04/12/redis-zi-fu-chuan-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><p><img src="/2019/04/12/redis-zi-fu-chuan-lei-xing/1572256192770.png" alt="1572256192770"></p><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><ul><li><p>设置值</p><pre><code>set key value </code></pre><ul><li><p>用于新加(键必须不存在)</p><pre><code>setnx key value</code></pre></li></ul></li><li><p>获取值</p><pre><code>get key</code></pre></li><li><p>批量设置值</p><pre><code>mset key value [key value ...]</code></pre></li><li><p>批量获取值</p><pre><code>mget key [key ...]</code></pre></li><li><p>计数</p><pre><code>incr key</code></pre></li></ul><h3 id="1-3-内部编码"><a href="#1-3-内部编码" class="headerlink" title="1.3 内部编码"></a>1.3 内部编码</h3><p>​    内部有三种编码：</p><ul><li>int：8个子节的长整型</li><li>embstr：小于等于39个子节的字符串</li><li>raw：大于39个子节的字符串</li></ul><p><strong>redis会根据当前值的类型和长度决定使用哪种内部编码实现</strong></p><h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h3><ul><li><p><strong>缓存功能</strong></p><p>​    redis作为用户和mysql存储层之间的缓冲，绝大多数的请求从redis中进行获取，能起到加速读写和降低后端压力的作用。</p></li></ul><p><img src="/2019/04/12/redis-zi-fu-chuan-lei-xing/1572255687909.png" alt="1572255687909"></p><ul><li><p><strong>计数</strong></p><p>​    redis可以快速实现计数，查询缓存的功能，同时数据可以异步落地到其他数据源。</p></li><li><p><strong>共享session</strong></p><p>​    分布式环境下，可将session信息存储在redis中，保证session的集中管理，用户每次登陆可以从session中进行获取。</p></li><li><p><strong>限速</strong></p><p>​    许多应用为防止机器人破坏，会进行验证时间的限速，比如手机短信的发送时间间隔等。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：有序集合类型</title>
      <link href="/2019/04/06/redis-you-xu-ji-he-lei-xing/"/>
      <url>/2019/04/06/redis-you-xu-ji-he-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>​        具有成员不可重复的特性，元素可以排序，但遵循元素的分数进行排序，并且其分数允许重复<img src="/2019/04/06/redis-you-xu-ji-he-lei-xing/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.PNG" alt=""></p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><ul><li><p>集合内</p><ul><li><p>添加成员</p><pre><code>zadd key score member [score member ...]</code></pre></li><li><p>计算成员个数</p><pre><code>zcard key</code></pre></li><li><p>计算某个成员的分数</p><pre><code>zscore key member</code></pre></li><li><p>计算成员的排名</p><pre><code>zrank key memberzrevrank key member</code></pre></li><li><p>删除成员</p><pre><code>zrem key member [member ...]</code></pre></li><li><p>增加成员的分数</p><pre><code>zincrby key increment member</code></pre></li><li><p>返回指定排名范围的成员</p><pre><code>zrange key start end [withscores]zrevrange key start end [withscores]</code></pre></li><li><p>返回指定分数范围的成员</p><pre><code>zrangebyscore key min max [withscores] [limit offset count]zrevrangebyscore key min max [withscores] [limit offset count]</code></pre></li><li><p>返回分数范围成员个数</p><pre><code>zcount key min max</code></pre></li><li><p>删除指定排名内的升序元素</p><pre><code>zremrangebyrank key start end</code></pre></li><li><p>删除指定分数范围的成员</p><pre><code>zremrangebyscore key min max</code></pre></li></ul></li><li><p>集合间的操作</p><ul><li><p>交集</p><pre><code>zinterstore destination numkeys key [key ...] [weights weight [weight ..]] [aggregate sum|min|max]</code></pre><ul><li>destination 计算的交集保存到这个键</li><li>numkeys 需要做交集计算键的个数</li><li>key[key …] 需要做交集计算的键</li><li>weights 权重</li><li>aggregate 计算交集后，分值做汇总，默认值是sum</li></ul></li><li><p>并集</p><pre><code>zunionstore destination numkeys key[key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></pre></li></ul></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3. 内部编码"></a>3. 内部编码</h3><p>​        内部编码有两种：</p><ul><li><p>ziplist：当有序集合的元素个数小于zset-max-ziplistentries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配 置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist 可以有效减少内存的使用。</p></li><li><p>skiplist：当ziplist条件不满足时，使用skiplist。</p></li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4.使用场景"></a>4.使用场景</h3><ul><li><p>添加用户赞数</p><p>使用分数作为投票数，使用zadd和zincrby</p></li><li><p>取消用户赞数</p><p>使用zrem</p></li><li><p>通过获赞数排名截取前几位</p><p>使用zrevrangebyrank </p></li><li><p>展示用户信息以及用户分数</p><p>zscore和zrank</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：列表类型</title>
      <link href="/2019/03/31/redis-lie-biao-lei-xing/"/>
      <url>/2019/03/31/redis-lie-biao-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>​        列表是用来存储多个有序的字符串，最多存储2的32次方减1个元素。</p><ul><li><p>支持两端插入(push)和弹出(pop)</p></li><li><p>获取指定范围的元素列表</p></li><li><p>获取指定索引下标的元素</p></li><li><p>可充当栈和队列的角色</p></li><li><p>列表的特点：</p><ul><li><p>元素是有序的</p></li><li><p>元素是允许重复的</p><p><img src="/2019/03/31/redis-lie-biao-lei-xing/1572258937(1).jpg" alt=""></p></li></ul></li></ul><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p>添加操作</p><ul><li><p>从右边插入</p><pre><code>  rpush key value[value ...]</code></pre></li><li><p>从左边插入</p><pre><code>lpush key value[value ...]</code></pre></li><li><p>向某个元素前或后插入元素</p><pre><code>linsert key before|after pivot value</code></pre></li></ul></li><li><p>查找</p><ul><li><p>获取指定范围的元素列表</p><pre><code>lrange key start end</code></pre></li><li><p>获取指定索引下标的元素</p><pre><code>lindex key index</code></pre></li><li><p>获取列表长度</p><pre><code>llen key</code></pre></li></ul></li><li><p>删除</p><ul><li><p>从列表左侧弹出元素</p><pre><code>lpop key</code></pre></li><li><p>右侧弹出元素</p><pre><code>rpop key</code></pre></li><li><p>删除指定元素(count &gt;0 ,从左到右，count&lt;0 从右到左，count = 0, 删除所有)</p><pre><code>lrem key count value</code></pre></li><li><p>按照索引范围修剪列表</p><pre><code>ltrim key start end</code></pre></li></ul></li><li><p>修改</p><pre><code>lset key index newValue</code></pre></li><li><p>阻塞操作(列表为空时，timeout=3，3秒后返回，timeout=0，客户端一直阻塞，直到新数据插入，列表不为空时，立即返回，多个客户端执行，遵循先到先得原则)</p><pre><code>blpop key [key ...] timeoutbrpop key [key ...] timeout</code></pre></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3. 内部编码"></a>3. 内部编码</h3><p>，        列表的内部编码有两种：</p><ul><li>ziplist(压缩列表)：当列表的元素个数小于list-max-ziplist-entries配置 （默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时 （默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使<br>用。</li><li>linkedlist(链表)：当ziplist无法满足时，采用linkedlist。</li><li>quicklist：以一个ziplist为节点的linkedlist，结合了两者的优势。</li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul><li><p>消息队列</p><p>​    lpush + brpop 可以实现阻塞队列组合</p></li><li><p>文章列表</p><p>​    列表不但有序，还支持索引范围获取元素</p></li><li><p>其他组合</p><p>​    lpush + lpop = Stack</p><p>​    lpish + rpop = Queue</p><p>​    lpsh + ltrim = Capped Collection(有限集合)</p><p>​    lpush + brpop = Message Queue(消息队列)</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：内存</title>
      <link href="/2019/03/27/redis-nei-cun/"/>
      <url>/2019/03/27/redis-nei-cun/</url>
      
        <content type="html"><![CDATA[<h3 id="1-内存消耗"><a href="#1-内存消耗" class="headerlink" title="1. 内存消耗"></a>1. 内存消耗</h3><p>​            内存消耗可以分为<strong>自身消耗</strong>和<strong>子进程消耗</strong>。</p><p>​            <img src="/2019/03/27/redis-nei-cun/1572428138468.png" alt="1572428138468"></p><ul><li><p><strong>对象内存</strong></p><p>​        内存占用最大的一块，存储用户所有数据，对象内存消耗可以理解为sizeof(keys)+sizeof(values)，键是字符串会消耗一定的内存，值为五种基本数据类型，或者由五种基本数据类型衍生的类型。</p></li><li><p><strong>缓冲内存</strong></p><p>​        缓冲内存包括<strong>客户端缓冲</strong>，<strong>复制积压缓冲</strong>，<strong>AOF缓冲区</strong>。</p><ul><li><em>普通客户端</em>：Redis并没有对普通客户端的输出缓冲区做限制，当有大量慢连接时，内存消耗不能忽略，使用大量数据输出的命令且数据无法及时推送给客户端时，会造成Redis服务器内存飙升。</li><li><em>从客户端</em>：主节点为从节点独建连接用于命令复制，当挂载过多节点或网络延迟高会造成内存消耗占用很大。</li><li><em>订阅客户端</em>：使用发布订阅会使用单独的输出缓冲区，当生产速度大于消费速度，会造成缓冲区空间溢出。</li><li><em>复制积压缓冲区</em>：可重用的固定大小的缓冲区用于实现复制功能，主节点只有一个，从节点共享此缓冲区。</li><li><em>AOF缓冲区</em>：用于在Redis重写期间保存最近的写入命令。</li></ul></li><li><p><strong>内存碎片</strong></p><ul><li>频繁更新操作</li><li>大量过期键删除</li><li>解决方法<ul><li>数据对齐，即数据尽可能采用数字类型或固定长度字符串</li><li>安全重启，重启可以做到内存碎片的整理</li></ul></li></ul></li><li><p><strong>子进程消耗</strong></p><p>​        <strong>子进程内存消耗主要指执行AOF/RDB重写时Redis创建的子进程内存消耗。</strong></p><ul><li>Redis子进程消耗并非父进程内存的1倍，根据期间写入命令量决定。</li><li>需要设置，允许内核可以分配所有的物理内存，防止fork时因内存不足而失败。</li><li>排查系统是否支持并开启THP，建议关闭。</li></ul></li></ul><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h3><p>​            <strong>Redis主要通过控制内存上限和回收策略实现内存管理。</strong></p><h5 id="2-1-设置内存上限"><a href="#2-1-设置内存上限" class="headerlink" title="2.1 设置内存上限"></a>2.1 设置内存上限</h5><ul><li>目的：<ul><li>用于缓存场景，超出内存上限时使用LRU等删除策略释放空间。</li><li>防止内存超过服务器物理内存</li></ul></li></ul><h5 id="2-2-动态调整内存上限"><a href="#2-2-动态调整内存上限" class="headerlink" title="2.2 动态调整内存上限"></a>2.2 动态调整内存上限</h5><p>​            Redis可以通过config set maxmemory 进行内存的动态修改，达到当前服务器下动态伸缩Redis内存的目的。</p><h5 id="2-3-内存回收策略"><a href="#2-3-内存回收策略" class="headerlink" title="2.3 内存回收策略"></a>2.3 内存回收策略</h5><ul><li><p>删除过期键对象</p><ul><li>惰性删除，客户读取超时属性的键，超过键的超时时间，会自动删除，但过期键一直没有访问，导致内存不能及时释放，可能造成内存泄漏问题。</li><li>定时任务删除，内部维护定时任务，一秒10次，采用自适应算法，根据键的过期比例、使用快慢两种速率模式回收键。</li></ul></li><li><p>内存溢出控制策略（6种策略）</p><table><thead><tr><th>策略名称</th><th>介绍</th></tr></thead><tbody><tr><td>noeviction</td><td>默认策略，拒绝所有写操作，不删除任何数据，返回OOM信息，只响应读操作</td></tr><tr><td>volatile-lru</td><td>根据lru算法删除过期键，直到空间足够，没有删除的键，回退默认策略</td></tr><tr><td>allkeys-lru</td><td>不管数据是否设置超时属性，直到腾出足够空间为止</td></tr><tr><td>allkeys-random</td><td>随机删除所有键，直到腾出足够空间</td></tr><tr><td>volatile-random</td><td>随机删除所有过期键，直到腾出足够空间为止</td></tr><tr><td>volatile-ttl</td><td>根据键值对象的ttl，删除最近要过期的数据，如果没有就回退默认策略</td></tr></tbody></table></li></ul><h3 id="3-内存优化"><a href="#3-内存优化" class="headerlink" title="3. 内存优化"></a>3. 内存优化</h3><ul><li><p><strong>redisObject对象</strong></p><p>​    redis存储的数据都使用redisObject来封装。</p><ul><li><em>type字段</em>：表示数据类型（string、hash、list、set、zset）</li><li><em>encoding：</em>内部编码类型</li><li><em>lru：</em>最后一次被访问的时间</li></ul></li><li><p>缩减键值对象</p><ul><li>key长度，越简短越好</li><li>value长度，将业务对象进行序列化成二进制数据放入redis中，常见的格式如json和xml，同样可以进行压缩存储。</li></ul></li><li><p>共享线程池</p><p>​        Redis内部维护【0-9999】的整数对象池，除了整数值对象之外，list、hash、set、zset内部元素也可以使用整数对象池。</p><p>​        注意事项：</p><ul><li>共享对象池和maxmemory+LRU策略冲突，因为LRU策略需要获取对象的最后访问时间，但共享对象意味着共享一个redisObject，lru字段也会共享。</li><li>对于ziplist编码的值对象，即使内部数据为整数也无法使用共享对象池，因为ziplist使用压缩且内存连续的结构，对象共享判断成本过高。</li></ul></li><li><p>字符串优化</p><ul><li><p>字符串结构</p><p><img src="/2019/03/27/redis-nei-cun/1572489998076.png" alt="1572489998076"></p><p>特点</p><ul><li>O(1)的时间复杂度，字符串长度，已用长度、未用长度</li><li>可用于保存字节数组，支持安全的二进制数据存储</li><li>内部实现空间预分配机制，降低再分配次数</li><li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留</li></ul></li><li><p>预分配机制</p><ul><li>尽量减少字符串的频繁修改操作如append、setrange等，直接使用set修改字符串，降低分配带来的内存浪费和内存碎片化。</li></ul></li><li><p>字符串重构</p><ul><li>不一定没份数据都按字符串进行存储，json可以使用hash结构进行存储，方便单个字段的修改。</li></ul></li></ul></li><li><p>编码优化</p><ul><li>编码类型转换在Redis写入数据时自动完成，过程不可逆，转换规则只能从小内存编码到大内存编码转换。</li><li>可以使用config set命令设置编码相关参数来满足使用压缩编码的条件。</li><li>已采用非压缩编码类型的数据，设置参数后，即使满足压缩编码条件也要重启redis重新加载数据才会生效。</li></ul></li><li><p>控制键数量</p><ul><li>通过在客户端预估键规模，把大量键分组映射到多个hash结构中降低键的数量。</li><li>hash的field记录键的字符串，value记录键的值</li><li>同样的数据使用ziplist编码的hash类型比string类型节约内存</li><li>节省内存随着value空间的减少越来越明显。</li><li>hash-ziplist类型比string类型写入耗时，但随着value空间的减少，耗时逐渐降低。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：集合类型</title>
      <link href="/2019/03/24/redis-ji-he-lei-xing/"/>
      <url>/2019/03/24/redis-ji-he-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>​        集合Set也用来保存多个字符串元素，但不允许有重复元素，并且时无序的，也无法通过下标进行元素获取，最多存储2的32次方减1个元素。</p><p><img src="/2019/03/24/redis-ji-he-lei-xing/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.PNG" alt=""></p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p>集合内操作</p><ul><li><p>添加元素</p><pre><code>sadd key element [element ...]</code></pre></li><li><p>删除元素</p><pre><code>srem key element [element ...]</code></pre></li><li><p>计算元素个数</p><pre><code>scard key</code></pre></li><li><p>判断元素是否存在</p><pre><code>sismember key element</code></pre></li><li><p>随机返回指定个数元素(count 默认为 1)</p><pre><code>srandmember key [count]</code></pre></li><li><p>随机弹出元素</p><pre><code>spop key</code></pre></li><li><p>获取所有元素</p><pre><code>smembers key</code></pre></li></ul></li><li><p>集合间操作</p><ul><li><p>交集</p><pre><code>sinter key [key ...]</code></pre></li><li><p>并集</p><pre><code>suinon key [key ...]</code></pre></li><li><p>差集</p><pre><code>sdiff key [key ...]</code></pre></li><li><p>保存上述结果</p><pre><code>sinterstore destination key [key ...]suionstore destination key [key ...]sdiffstore destination key [key ...]</code></pre></li></ul></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3. 内部编码"></a>3. 内部编码</h3><p>​        集合类型编码有两种：</p><ul><li><p>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实<br>现，从而减少内存的使用。</p></li><li><p>hashtable（哈希表）：intset无法满足时，采用hashtable。</p></li></ul><h3 id="4-场景"><a href="#4-场景" class="headerlink" title="4.场景"></a>4.场景</h3><ul><li>给用户添加标签<ul><li>给用户添加标签</li><li>给标签添加用户</li><li>删除用户下的标签</li><li>删除标签下的用户</li></ul></li><li>组合<ul><li>sadd=Tagging(标签)</li><li>spop/srandmember = Random item(生成随机数，比如抽奖)</li><li>sadd+sinter = Social Graph(社交需求)</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：持久化</title>
      <link href="/2019/03/18/redis-chi-jiu-hua/"/>
      <url>/2019/03/18/redis-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        Redis的持久化支持<strong>RDB</strong>和<strong>AOF</strong>两种持久化机制，持久化能有效避免进程的退出造成数据的丢失问题，保证重启时，利用持久化文件进行数据的恢复。</p><h3 id="2-RDB"><a href="#2-RDB" class="headerlink" title="2. RDB"></a>2. RDB</h3><h5 id="2-1-持久化触发"><a href="#2-1-持久化触发" class="headerlink" title="2.1 持久化触发"></a>2.1 持久化触发</h5><p>​        <strong>RDB</strong>的持久化分为<strong>手动触发</strong>和<strong>自动触发</strong>，是把当前进程数据生成快照保存到硬盘的过程。</p><ul><li><p>手动触发分别对应<strong>save</strong>和<strong>bgsave</strong></p><ul><li><strong>save：</strong> 阻塞当前服务器，知道RDB完成</li><li><strong>bgsave：</strong> Redis进程执行fork操作创建子进程，子进程负责持久化，阻塞发生在fork阶段。</li></ul></li><li><p>自动触发</p><ul><li>使用save相关配置 触发bgsave。</li><li>从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件发送给从节点。</li><li>执行debug reload 重新加载Redis。</li><li>默认情况执行shutdown，没有开启AOF持久化功能。</li></ul></li></ul><h5 id="2-2-bgsave命令运作流程"><a href="#2-2-bgsave命令运作流程" class="headerlink" title="2.2 bgsave命令运作流程"></a>2.2 bgsave命令运作流程</h5><p><img src="/2019/03/18/redis-chi-jiu-hua/1572338742164.png" alt="1572338742164"></p><ol><li>执行bgsave，父进程判断是否有子进程存在，若有直接返回。</li><li>父进程阻塞，fork创建子进程。</li><li>父进程fork完成之后，不再进行阻塞。</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成对原有文件进行原子替换。</li><li>进程发送信号给父进程表示完成。</li></ol><h5 id="2-3-RDB的优缺点"><a href="#2-3-RDB的优缺点" class="headerlink" title="2.3 RDB的优缺点"></a>2.3 RDB的优缺点</h5><ul><li><p><strong>优点</strong></p><ul><li>紧凑压缩的二进制文件，适于备份，全量复制等场景。</li><li>恢复数据速度远远快于AOF的方式</li></ul></li><li><p><strong>缺点</strong></p><ul><li>无法做到实时持久化和秒级持久化，需要创建子进程，成本高。</li><li>使用 二进制格式保存，老版可能无法兼容新版RDB格式</li></ul></li></ul><h3 id="3-AOF"><a href="#3-AOF" class="headerlink" title="3. AOF"></a>3. AOF</h3><p>​        以独立日志的方式记录每次写命令，重启执行AOF进行数据恢复。解决了持久化的实时性。</p><p>​        默认不开启，开启需要配置 <strong>appendonly yes</strong>,文件名默认为：<strong>appendonly.aof</strong></p><h5 id="3-1-工作流"><a href="#3-1-工作流" class="headerlink" title="3.1 工作流"></a>3.1 工作流</h5><p><img src="/2019/03/18/redis-chi-jiu-hua/1572340821778.png" alt="1572340821778"></p><ol><li><p>命令写入</p><ul><li>所有写入命令会追加到缓冲区</li><li>写入的内容是文本协议格式（很好的兼容性，直接追加，避免二次处理，具有可读性，方便修改处理）</li><li>如果写入硬盘则性能受限，写入缓存redis提供多种同步硬盘策略</li></ul></li><li><p>文件同步</p><ul><li>缓冲区根据对应策略向硬盘同步</li><li>redis提供多种缓冲区同步文件策略</li></ul></li><li><p>文件重写</p><ul><li><p>AOF文件越来越大，需要定期重写，压缩</p></li><li><p>将redis进程内的数据转为写命令同步到新AOF文件</p></li><li><p>降低了文件占用空间，更小的更快进行加载。</p></li><li><p>可以手动触发和自动触发</p><p><img src="/2019/03/18/redis-chi-jiu-hua/1572341878158.png" alt="1572341878158"></p><ol><li><p>执行AOF请求</p></li><li><p>父进程fork创建子进程</p></li><li><p>3.1 主进程fork完响应其他命令，修改内容写入缓冲区，并根据同步策略同步到硬盘</p><p>3.2 fork采用写时复制技术，子进程只能共享fork操作的内存数据，缓冲区保存新数据</p></li><li><p>子进程根据内存快照，写入新AOF文件中。默认32M。</p></li><li><p>5.1 子进程发送信号给父进程，父进程更新统计信息</p><p>5.2  父进程将缓冲区数据写入新AOF文件</p><p>5.3 使用新AOF文件替换旧文件，完成重写。</p></li></ol></li></ul></li><li><p>重启加载</p><ul><li>加载AOF文件进行数据恢复</li></ul></li></ol><p><img src="/2019/03/18/redis-chi-jiu-hua/1572342471292.png" alt="1572342471292"></p><ul><li>AOF持久化开启，并且存在AOF文件，优先加载AOF文件</li><li>上面不成立，则加载RDB文件</li><li>加载完毕后，成功启动</li><li>否则 启动失败，打印错误信息</li></ul><h3 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h3><h5 id="4-1-fork操作的优化"><a href="#4-1-fork操作的优化" class="headerlink" title="4.1 fork操作的优化"></a>4.1 fork操作的优化</h5><ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例最大可用内存，fork耗时和内存成正比</li><li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败</li><li>降低fork操作频率，放宽AOF自动触发时机，避免全量复制</li></ul><h5 id="4-2-子进程优化"><a href="#4-2-子进程优化" class="headerlink" title="4.2 子进程优化"></a>4.2 子进程优化</h5><ul><li><strong>CPU</strong><ul><li>Redis是CPU密集型服务，不要做绑定单核CPU操作。</li><li>避免和CPU密集服务部署，造成CPU过度竞争。</li><li>多个实例下，尽可能保证同时只有一个子进程执行重写工作。</li></ul></li><li>内存<ul><li>多个实例下，尽可能保证同时只有一个子进程执行重写工作。</li><li>避免大量写入时，进行子进程重写操作，导致父进程维护大量页副本。</li></ul></li><li>硬盘<ul><li>不要和其他高硬盘负载服务部署在一起，如消息队列，存储服务</li><li>AOF重写消耗大量硬盘IO,设置在AOF重写期间不做fsync操作</li><li>高流量写入场景，瓶颈在AOF同步硬盘上</li><li>单机配置多实例，可配置不同实例分盘存储AOF文件，平摊写入压力。</li></ul></li></ul><h3 id="5-多实例部署（监控轮询）"><a href="#5-多实例部署（监控轮询）" class="headerlink" title="5.多实例部署（监控轮询）"></a>5.多实例部署（监控轮询）</h3><p>​        Redis属于单线程架构，所以单台机器会部署多个实例，但同时开启AOF重写后，彼此会产生CPU和IO的竞争。</p><p>​        可以通过外部程序轮询控制AOF重写操作的执行</p><ul><li>外部程序定时轮询监控所有实例</li><li>对开启AOF的实例，确定其增长率</li><li>增长率超过一定值，手动触发当前实例重写</li><li>运行期间循环检查，直到AOF重写结束</li><li>确认实例AOF重写完成后，再检查其他实例并重复2~4.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：哈希类型</title>
      <link href="/2019/03/16/redis-ha-xi-lei-xing/"/>
      <url>/2019/03/16/redis-ha-xi-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p><img src="/2019/03/16/redis-ha-xi-lei-xing/1572256259607.png" alt="1572256259607"></p><p>​        哈希类型的值可以是字符串，数字，哈希，但键只能是字符串</p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p>设置值(可以给一个键设置多次，即设置多个值)</p><pre><code>hest key field value</code></pre></li><li><p>获取值</p><pre><code>hget key field</code></pre></li><li><p>删除值</p><pre><code>hdel key field[field ...]</code></pre></li><li><p>计算field个数</p><pre><code>hlen key </code></pre></li><li><p>批量设置或获取filed-value</p><pre><code>hmget key fieldhmset key field value [field value ...]</code></pre></li><li><p>判断是否存在</p><pre><code>hexists key field</code></pre></li><li><p>获取所有field</p><pre><code>hkeys key</code></pre></li><li><p>获取所有value</p><pre><code>hvals key</code></pre></li><li><p>获取所有的field-value（元素太多可能造成阻塞，建议使用hscan渐进式遍历）</p><pre><code>hgetall key</code></pre></li><li><p>计数</p><pre><code>hincrby key fieldhincrbyfloat key field</code></pre></li><li><p>计算value的字符串长度</p><pre><code>hstrlen key field</code></pre></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3.内部编码"></a>3.内部编码</h3><p>​        哈希类型的内部编码有两种：</p><ul><li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries 配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64子节）是采用。比hashtable更加节省内存。</li><li>hashtable（哈希表）：当ziplist无法满足时，采用hashtable，时间复杂度为O(1)。</li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul><li><p>相对于字符串序列化缓存用户信息，哈希类型更加直观</p></li><li><p>哈希类型与关系型数据库的不同：</p><ul><li>哈希的类型是稀疏的，键可以有多个值</li><li>不能做关联模拟查询，成本高</li></ul></li><li><p>三种缓存方式比较：</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>原生字符串，每个属性一个键</td><td>简单直观，每个属性支持独立更新</td><td>占用过多键，占用内存大</td></tr><tr><td>序列化，一键保存</td><td>显著提高内存效率</td><td>序列化和反序列化需要一定开销，修改开销大</td></tr><tr><td>哈希类型</td><td>有效提高内存效率</td><td>要控制ziplist和hashtable的转换。后者消耗更多内存</td></tr></tbody></table></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：基础介绍</title>
      <link href="/2019/03/16/redis-ji-chu-jie-shao/"/>
      <url>/2019/03/16/redis-ji-chu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-全局命令"><a href="#1-全局命令" class="headerlink" title="1. 全局命令"></a>1. 全局命令</h3><ul><li><p>查看所有键</p><pre><code>keys *    </code></pre></li><li><p>键总数</p><pre><code>dbsize</code></pre></li><li><p>检查键是否存在</p><pre><code>exists key </code></pre></li><li><p>删除键(支持删除多个)</p><pre><code>del key</code></pre></li><li><p>键过期</p><pre><code>expire key seconds</code></pre></li><li><p>键过期剩余时间(-1 : 没有过期时间， -2 ： 键不存在)</p><pre><code>ttl key</code></pre></li><li><p>键的数据结构类型(不存在返回none)</p><pre><code>type key</code></pre></li><li><p>查看内部编码</p><pre><code>objecy encoding key </code></pre></li></ul><h3 id="2-数据结构和内部编码"><a href="#2-数据结构和内部编码" class="headerlink" title="2. 数据结构和内部编码"></a>2. 数据结构和内部编码</h3><h5 id="2-1-五种数据结构"><a href="#2-1-五种数据结构" class="headerlink" title="2.1 五种数据结构"></a>2.1 五种数据结构</h5><p><img src="/2019/03/16/redis-ji-chu-jie-shao/1571973182171.png" alt="1571973182171"></p><h5 id="2-2-数据结构和内部编码"><a href="#2-2-数据结构和内部编码" class="headerlink" title="2.2 数据结构和内部编码"></a>2.2 数据结构和内部编码</h5><p><img src="/2019/03/16/redis-ji-chu-jie-shao/1571973218076.png" alt="1571973218076"></p><h3 id="3-单线程架构"><a href="#3-单线程架构" class="headerlink" title="3. 单线程架构"></a>3. 单线程架构</h3><p>​        Redis使用了<strong>单线程架构</strong>和<strong>I/O多路复用模型</strong>来实现高性能的内存数据服务。</p><p>​        单线程快的原因：</p><ul><li>纯内存访问</li><li>非阻塞I/O</li><li>避免线程切换和竞态产生的消耗    </li></ul><p><img src="/2019/03/16/redis-ji-chu-jie-shao/1572254956036.png" alt="1572254956036"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：基础命令</title>
      <link href="/2019/03/10/redis-ji-chu-ming-ling/"/>
      <url>/2019/03/10/redis-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        <strong>Redis</strong>是一个使用<a href="https://zh.wikipedia.org/wiki/ANSI_C" target="_blank" rel="noopener">ANSI C</a>编写的<a href="https://zh.wikipedia.org/wiki/开源" target="_blank" rel="noopener">开源</a>、支持<a href="https://zh.wikipedia.org/wiki/电脑网络" target="_blank" rel="noopener">网络</a>、基于<a href="https://zh.wikipedia.org/wiki/内存" target="_blank" rel="noopener">内存</a>、可选<a href="https://zh.wikipedia.org/w/index.php?title=持久性_(数据库)&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">持久性</a>的<a href="https://zh.wikipedia.org/wiki/键值-值数据库" target="_blank" rel="noopener">键值对存储数据库</a>，其特点如下：</p><ul><li>速度快</li><li>基于键值对的数据结构服务器</li><li>丰富的功能<ul><li>键过期</li><li>发布订阅</li><li>支持Lua</li><li>提供简单事务</li><li>提供流水线功能</li></ul></li><li>简单稳定</li><li>客户端语言多</li><li>持久化（AOF RDB）</li><li>主从复制</li><li>高可用和分布式</li></ul><p><strong>可以做什么</strong></p><ul><li>缓存</li><li>排行榜系统</li><li>计数器应用</li><li>社交网络</li><li>消息队列系统</li></ul><h3 id="1-Redis的安装"><a href="#1-Redis的安装" class="headerlink" title="1. Redis的安装"></a>1. Redis的安装</h3><h3 id="2-Redis的启动"><a href="#2-Redis的启动" class="headerlink" title="2. Redis的启动"></a>2. Redis的启动</h3><p>​        redis的启动有三种方式：</p><ul><li><p>默认启动</p><pre class=" language-shell"><code class="language-shell">redis-server</code></pre></li><li><p>运行启动(redis-server –configKey1 configValue1 –configKey2 configValue2)</p><pre><code>redis-server --port 6380 </code></pre></li><li><p>配置文件启动</p><pre><code>redis-server /opt/redis/redis.conf</code></pre></li></ul><h3 id="3-Redis命令客户端"><a href="#3-Redis命令客户端" class="headerlink" title="3. Redis命令客户端"></a>3. Redis命令客户端</h3><ul><li><p>交互式，一经连接，之后只输入命令返回结果</p><pre><code>redis-cli -h 127.0.0.1 -p 6379</code></pre></li><li><p>命令式</p><pre><code>redis-cli -h 127.0.0.1 -p 6379 get hello</code></pre></li></ul><h3 id="4-停止服务"><a href="#4-停止服务" class="headerlink" title="4. 停止服务"></a>4. 停止服务</h3><ul><li><p>停止服务(断开客户端的连接，生成持久化文件)</p><pre><code>redis-cli shutdown</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：安装</title>
      <link href="/2019/03/03/redis-an-zhuang/"/>
      <url>/2019/03/03/redis-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  在官网进行redis的下载:<a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis官网</a></p><h1 id="1-安装Redis"><a href="#1-安装Redis" class="headerlink" title="1.安装Redis"></a>1.安装Redis</h1><ul><li>解压安装包</li></ul><pre><code>tar -zxvf  redis-5.0.4.tar.gz</code></pre><ul><li>进入解压后的安装包进行编译(时间较长)</li></ul><pre><code>make</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567668459576.png" alt="1567668459576"></p><p>出现以上结果，表明编译成功。</p><ul><li>运行make test 进行测试(貌似这一步可以跳过)</li></ul><pre><code>make test</code></pre><p>我这边报错，提示需要tcl 8.5 才能进行make test。</p><p><img src="/2019/03/03/redis-an-zhuang/1567668669399.png" alt="1567668669399"></p><p>去官网下载了tcl8.6.9.tar.gz，在解压安装之后，但在进行tcl编译的过程中会报错，最后采用yum命令进行了tcl的安装。</p><pre><code>yum install tcl</code></pre><p>再进行 make test </p><ul><li>进入src下进行安装</li></ul><pre><code>make install</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567671273931.png" alt="1567671273931"></p><ul><li>查看安装版本</li></ul><pre><code>redis-cli -v</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567671322453.png" alt="1567671322453"></p><ul><li>启动redis(默认启动方式)</li></ul><pre><code>redis-server</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567671488856.png" alt="1567671488856"></p><p>​            OK,安装成功！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat：Linux多安装配置</title>
      <link href="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/"/>
      <url>/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h1><p>  关于jdk环境的安装详见</p><h1 id="2-tomcat安装配置"><a href="#2-tomcat安装配置" class="headerlink" title="2. tomcat安装配置"></a>2. tomcat安装配置</h1><ul><li>解压压缩包<pre><code>tar -zxvf apache-tomcat-8.5.45.tar.gz</code></pre></li><li>将解压后的tomcat文件夹重命名</li></ul><pre><code>mv apache-tomcat-8.5.45 tomcat8080</code></pre><ul><li>再次解压，重命名</li></ul><pre><code>tar -zxvf apache-tomcat-8.5.45.tar.gzmv apache-tomcat-8.5.45 tomcat8090</code></pre><ul><li>这时文件下面有两个tomcat 即 tomcat8080和tomcat8090</li></ul><p><img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567647778105.png" alt="1567647778105"></p><ul><li><p>配置环境变量（重点）</p><ul><li><p>编辑 /etc/profile文件 增加如下内容（注意采用自己的路径）：</p><pre><code>##########tomcat8080###########export CATALINA_HOME=/usr/lixs/tomcat/tomcat8080export CATALINA_BASE=/usr/lixs/tomcat/tomcat8080export TOMCAT_HOME=/usr/lixs/tomcat/tomcat8080###########tomcat8090############export CATALINA_2_HOME=/usr/lixs/tomcat/tomcat8090export CATALINA_2_BASE=/usr/lixs/tomcat/tomcat8090export TOMCAT_2_HOME=/usr/lixs/tomcat/tomcat8090</code></pre><p>改完/etc/profile 之后执行命令 使其生效：</p><pre><code>source /etc/profile</code></pre></li></ul></li><li><p>编辑tomcat8090的bin下的catalina.sh,增加以下语句（重点）：</p><pre><code>  # OS specific support.  $var _must_ be set to either true or false.  export CATALINA_BASE=$CATALINA_2_BASE  export CATALINA_HOME=$CATALINA_2_HOME</code></pre></li><li><p>编辑tomca8090的conf下的server.xml</p><pre><code>&lt;Server port="8006" shutdown="SHUTDOWN"&gt;  #8005 ---》8006   &lt;Connector port="8090" protocol="HTTP/1.1"    #8080---》8090                 connectionTimeout="20000"                 redirectPort="8443" /&gt;</code></pre></li></ul><pre><code>&lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8443" /&gt;   #8009 ---》8010```</code></pre><ul><li><p>修改tomcat各自的首页,以tomcat8080为例</p><pre><code>   vim /usr/lixs/tomcat/tomcat8080/webapps/ROOT/index.jsp  </code></pre><p>  修改如下：</p><p>  <img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567650064119.png" alt="1567650064119"></p></li><li><p>去tomcat8080的bin和tomcat8090的bin下面分别启动tomcat</p><pre><code>  ./startup.sh</code></pre></li><li><p>浏览器调用不同端口，结果显示如下：</p><p>  8080端口的tomcat</p></li></ul><p><img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567650140081.png" alt="1567650140081"></p><p>​    8090端口的tomcat</p><p><img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567650181367.png" alt="1567650181367"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx：原理规则解析</title>
      <link href="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/"/>
      <url>/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Nginx是一款免费开源的高性能HTTP代理服务器及反向代理服务器（Reverse Proxy）产品,同时提供IMAP/POP3邮件代理等功能。最频繁使用的是Nginx的<strong>负载均衡</strong>和<strong>反向代理</strong>两个功能，但其功能还不至这些。</p><p>​        Nginx 特点：</p><ul><li>更快</li><li>高扩展性</li><li>高可靠性</li><li>低内存消耗</li><li>单机支持10w+的并发连接</li><li>热部署</li></ul><p>​        Nginx是由内核和一系列模块组成，内核提供web服务的基本功能，如启用网络协议，创建运行环境，接受和分配客户端请求，处理模块之间的交互。Nginx的各种功能和操作都是由模块来实现。Nginx的模块从结构上分为核心模块、基础模块和第三方模块。</p><ul><li>核心模块：HTTP模块、EVENT模块和MAIL模块</li><li>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块</li><li>第三方模块：HTTP Upsream Request Hash模块、Notice模块和HTTP Access Key模块等。</li></ul><h1 id="1-常用功能"><a href="#1-常用功能" class="headerlink" title="1. 常用功能"></a>1. 常用功能</h1><h3 id="1-1-反向代理"><a href="#1-1-反向代理" class="headerlink" title="1.1 反向代理"></a>1.1 反向代理</h3><p>  常见的<strong>正向代理</strong>模式，如VPN的使用，我们挂载VPN访问墙外网站时，自身的IP是不能访问的，我们首先通过VPN进入公网的IP，再经由公网的IP去获取墙外资源，这里正向代理是VPN，由<strong>VPN代理客户端获取资源</strong>。<br>  <strong>反向代理</strong>模式，恰恰相反，客户端的请求会首先经过Nginx服务器，Nginx将服务请求分发到相应的WEB服务器，这里的Nginx就是反向代理，代理的是资源服务器，<strong>我们只需将请求发送到反向代理服务器，不在乎，请求被Nginx传递给谁，正如VPN案例中，资源服务器将资源返回给VPN，不在乎VPN将会把资源传递给谁一样</strong>。</p><ul><li><strong>正向代理—-VPN代理我们去和服务器交涉</strong>。</li><li><strong>反向代理—-Nginx代理服务器和我们交涉</strong>。<br>  Nginx在提供代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置灵活，转发过程中不关心网络环境如何，可指定任意的IP地址和端口号，或其他类型的连接、请求等。</li></ul><p><strong>示例：</strong><br>  以本服务器上安装的tomcat作为示例,配置nginx对tomcat 的访问进行代理。</p><p>​        本机tomcat访问路径为：106.12.128.114:8080/</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567599370340.png" alt="1567599370340"></p><ul><li><p>编辑nginx的配置文件nginx.conf<br><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567598657319.png" alt="1567598657319"></p></li><li><p>找到这段代码，注释掉 root html 这一行。</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567598746032.png" alt="1567598746032"></p></li><li><p>添加 proxy_pass <a href="http://106.12.128.114:8080" target="_blank" rel="noopener">http://106.12.128.114:8080</a>; 即tomcat的访问路径</p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567599565318.png" alt="1567599565318"></li><li><p>在nginx 的sbin 目录下 调用命令 ./nginx -s reload  重启nginx，并使新配置文件生效</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567598999790.png" alt="1567598999790"></p></li><li><p>这时候访问 <a href="http://106.12.128.114" target="_blank" rel="noopener">http://106.12.128.114</a> 会直接跳到tomcat的显示页面，因为nginx已经进行了代理。</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567599344314.png" alt="1567599344314"></p></li></ul><h3 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h3><p>  负载均衡可以分为两种，即将单一的重负载分担到多个网络节点上做并行处理，每个节点处理完成之后将结果汇总返回给用户，大幅提高网络系统的处理能力。另外就是，将大量的前端并发请求或数据流量分担到多个后端网络节点上分别处理，有效降低前端用户等待相应的时间。而Nginx负载均衡属于后一方面，保证用户访问效率，减少后端服务器处理压力。</p><p>  负载均衡的算法主要分为两大类：</p><ul><li><p><strong>静态负载均衡算法</strong>：主要包括<strong>轮询算法</strong>、<strong>基于比率的加权轮询算法</strong>或者<strong>基于优先级的加权轮询算法</strong>。</p></li><li><p><strong>动态负载均衡算法</strong>：主要包括<strong>基于任务量的最少连接优化算法</strong>、<strong>基于性能的最快响应优先算法</strong>、<strong>预测算法</strong>和<strong>动态性能分配算法</strong>等。</p><p>静态负载均衡在一般的网络环境下也能表现的比较好，动态负载均衡算法更适用于复杂的网络环境。</p><h5 id="1-2-1-普通轮询算法"><a href="#1-2-1-普通轮询算法" class="headerlink" title="1.2.1 普通轮询算法"></a>1.2.1 普通轮询算法</h5><p>  普通轮询算法是指，当任务传递过来时，会按照一个固定的顺序，将任务分配下去。缺陷是，由于客观原因，我们不能保证每个节点的处理速度和能力是相同的，即A处理100个同时，B只能处理50个，因为这样一视同仁的算法存在一定问题。<br>  下面以tomcat作为示例，<strong>服务器安装配置多个tomcat</strong>详见博文XXXXX。</p></li></ul><p>  nginx.conf配置代码如下：</p><pre><code> upstream OrdinaryPolling {      server 106.12.128.114:8080;      server 106.12.128.114:8090;      }      server {          listen       80;          server_name  localhost;          location / {             proxy_pass http://OrdinaryPolling;             index  index.html index.htm index.jsp;         }     }</code></pre><h5 id="1-2-2-基于比例加权轮询"><a href="#1-2-2-基于比例加权轮询" class="headerlink" title="1.2.2 基于比例加权轮询"></a>1.2.2 基于比例加权轮询</h5><p>  nginx.conf配置代码如下：</p><pre><code> upstream OrdinaryPolling {      server 106.12.128.114:8080 weight=5;      server 106.12.128.114:8090 weight=2;      }      server {          listen       80;          server_name  localhost;          location / {             proxy_pass http://OrdinaryPolling;             index  index.html index.htm index.jsp;         }     }</code></pre><p>加权轮询的区别在于加上了weight，普通轮询实质上也是基于比例的加权轮询算法，只不过weight都是1.</p><h5 id="1-2-3-基于IP路由负载"><a href="#1-2-3-基于IP路由负载" class="headerlink" title="1.2.3 基于IP路由负载"></a>1.2.3 基于IP路由负载</h5><p>  在请求经由服务器处理时，服务器会保存相关的会话信息，比如session，但如果是轮询模式下，session在不同服务器之间是不能共享的，可能导致用户每次发起请求都需要进行登录验证。<br>  解决上述问题有两种思路：</p><ul><li>采用中间件，将登录信息保存在中间件上，比如redis,这样第一次登录时，保存会话信息到redis中，当轮询跳转时，先去redis上查询登录信息，如果有就直接操作，没有就保存到redis上。</li><li>根据客户端的IP地址划分，即将一个IP的请求全部发送到同一个服务器上，就不存在session共享的问题，nginx的基于IP路由负载，就是该形式，详细实例代码如下：</li></ul><pre><code>     upstream OrdinaryPolling {       ip_hash      server 106.12.128.114:8080 weight=5;      server 106.12.128.114:8090 weight=2;      }      server {          listen       80;          server_name  localhost;          location / {             proxy_pass http://OrdinaryPolling;             index  index.html index.htm index.jsp;         }     }</code></pre><p>  区别在于加上了 <strong>ip_hash</strong>.</p><h5 id="1-2-4-基于服务器响应时间负载分配"><a href="#1-2-4-基于服务器响应时间负载分配" class="headerlink" title="1.2.4 基于服务器响应时间负载分配"></a>1.2.4 基于服务器响应时间负载分配</h5><p>  根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配。<br>代码同上 只是将 <strong>ip_hash</strong> 替换为<strong>fair</strong>。</p><h5 id="1-2-5-对不同域名实现负载均衡"><a href="#1-2-5-对不同域名实现负载均衡" class="headerlink" title="1.2.5 对不同域名实现负载均衡"></a>1.2.5 对不同域名实现负载均衡</h5><p>  配合location指令块实现对不同域名实现负载均衡。</p><pre><code>upstream wordbackend {    server 127.0.0.1:8080;    server 127.0.0.1:8081;    }    upstream pptbackend {    server 127.0.0.1:8082;    server 127.0.0.1:8083;    }    server {        listen       80;        server_name  localhost;        location /word/ {            proxy_pass http://wordbackend;            index  index.html index.htm index.jsp;        }    location /ppt/ {            proxy_pass http://pptbackend;            index  index.html index.htm index.jsp;        }    }</code></pre><h3 id="1-3-Web缓存"><a href="#1-3-Web缓存" class="headerlink" title="1.3 Web缓存"></a>1.3 Web缓存</h3><p>  Nginx会对用户已经访问过的内容在服务器本地建立副本，这段时间内再次访问是，不需要Nginx再向服务器后端发送请求，缓存前端请求，提高Web服务器的性能。</p><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><h5 id="1-4-1-Master-Worker模式"><a href="#1-4-1-Master-Worker模式" class="headerlink" title="1.4.1 Master-Worker模式"></a>1.4.1 Master-Worker模式</h5><ul><li><strong>Master</strong>：负责读取验证配置文件nginx.conf,管理worker进程。</li><li><strong>Worker</strong>：每一个Worker进程维护一个线程（避免线程切换），处理连接和请求。其个数由配置文件决定，和CPU个有关，配置几个就有几个work进程。</li></ul><p>​        </p><p>​            配置文件中设定的worker数量：</p><p>1573199360734</p><p>​            查看进程：</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1573199430465.png" alt="1573199430465"></p><p>​            工作模型：</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/153561774023221fec6df27%5B1%5D.jpg" alt=""></p><h5 id="1-4-2-用途"><a href="#1-4-2-用途" class="headerlink" title="1.4.2 用途"></a>1.4.2 用途</h5><ul><li>Nginx 可以作为web server处理静态资源，这也是nginx能提高速度的一个主要原因，静态资源nginx处理，动态请求转发给后端</li><li>可以在Nginx下把静态资源、日志文件归属到不同的域名之下，方便维护管理。</li><li>Nginx可以进行IP访问控制，黑名单可以在Nginx中进行拦截，不必交给后端进行处理。</li><li>对于Tomcat而言，请求的IP是Nginx的地址，并非真实的request地址，Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER.</li></ul><h5 id="1-4-3-思考"><a href="#1-4-3-思考" class="headerlink" title="1.4.3 思考"></a>1.4.3 思考</h5><ul><li><p><strong>Nginx如何做到热部署？</strong></p><p>​    修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求都必须交给新的worker进程，旧的进程在处理完请求之后，全部kill掉即可。</p></li><li><p><strong>Nginx如何做到高并发下的高效处理？</strong></p><p>​    Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程为异步，worker只需从队列中循环处理即可。</p></li><li><p><strong>Nginx挂了如何处理？</strong></p><ul><li><p>keepalived + Nginx实现高可用。</p></li><li><p>请求不直接打到Nginx上，应该先通过Keepalived。</p></li><li><p>Keepalived应该能监控Nginx的生命状态。</p></li></ul><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1535617740483760159cc3a%5B1%5D.jpg" alt=""></p></li></ul><p>  参考博客：<a href="https://www.cnblogs.com/ysocean/p/9392908.html" target="_blank" rel="noopener">Nginx反向代理</a></p><p>​                          <a href="https://blog.csdn.net/yinwenjie/article/details/46620711" target="_blank" rel="noopener">架构设计：负载均衡方案</a>            </p><p>​                          <a href="https://segmentfault.com/a/1190000007803704" target="_blank" rel="noopener">Nginx+Tomcat整合体验</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx：安装与配置文件详解</title>
      <link href="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/"/>
      <url>/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Nginx–Liunx安装"><a href="#1-Nginx–Liunx安装" class="headerlink" title="1.Nginx–Liunx安装"></a>1.Nginx–Liunx安装</h1><h3 id="1-安装nginx环境"><a href="#1-安装nginx环境" class="headerlink" title="1. 安装nginx环境"></a>1. 安装nginx环境</h3><pre><code>1 yum install gcc-c++2 yum install -y pcre pcre-devel3 yum install -y zlib zlib-devel4 yum install -y openssl openssl-devel</code></pre><ul><li>gcc，因为安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境的话，需要安装gcc。</li><li>pcre，prce(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</li><li>zlib，zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</li><li>openssl，OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</li></ul><h3 id="2-正式安装"><a href="#2-正式安装" class="headerlink" title="2. 正式安装"></a>2. 正式安装</h3><ul><li>下载nginx1.8.0版本</li></ul><pre><code>wget http://nginx.org/download/nginx-1.8.0.tar.gz</code></pre><ul><li>解压文件</li></ul><pre><code>tar -zxvf nginx-1.8.0.tar.gz</code></pre><ul><li>进入解压目录进行编译（nginx的全路径）</li></ul><pre><code>./configure --prefix=/usr/lixs/nginx/nginx-1.8.0</code></pre><pre><code>make</code></pre><pre><code>make install</code></pre><ul><li>上述操作完毕之后，会在nginx-1.8.0的目录下出现<strong>sbin</strong>和<strong>logs</strong>文件夹（如果没有logs文件夹，则需要手动创建，并创建<strong>error.log</strong>和<strong>access.log</strong>文件）。</li></ul><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570387898.png" alt="1567570387898"></p><ul><li>启动nginx，进入sbin目录，内部有一个<strong>nginx</strong>文件，执行命令<pre><code>./nginx</code></pre></li></ul><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570525335.png" alt="1567570525335"></p><ul><li>查看nginx进程，是否已经成功启动</li></ul><pre><code>ps aux|grep nginx</code></pre><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570599157.png" alt="1567570599157"></p><h3 id="2-1-查看结果"><a href="#2-1-查看结果" class="headerlink" title="2.1 查看结果"></a>2.1 查看结果</h3><ul><li>浏览器输入ip地址便可以直接访问nginx页面。<br><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570840754.png" alt="1567570840754"><h3 id="2-2-安装验证"><a href="#2-2-安装验证" class="headerlink" title="2.2 安装验证"></a>2.2 安装验证</h3></li><li>验证配置文件，可以检查nginx.conf配置文件其格式、语法是否正确，如果存在配置文件错误，则会出现相应提示，成功也会提示</li></ul><pre><code>./nginx -t</code></pre><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567578852819.png" alt="1567578852819"></p><ul><li>重加载/重启nginx，以新的nginx.conf配置文件启动</li></ul><pre><code>./nginx -s reload</code></pre><ul><li>停止nginx</li></ul><pre><code>./nginx -s stop</code></pre><h3 id="2-3-重要配置项"><a href="#2-3-重要配置项" class="headerlink" title="2.3 重要配置项"></a>2.3 重要配置项</h3><p>  以下是针对于Nginx安装目录下的conf文件夹下的<strong>nginx.conf</strong>配置文件的解析。</p><pre><code>#================================以下是全局配置项#指定运行nginx的用户和用户组，默认情况下该选项关闭（关闭的情况就是nobody）#user  nobody nobody;     #运行nginx的进程数量，最优值取决于多种因素，CPU核数，硬盘驱动，一般设置为CPU的核数worker_processes  1;      #nginx运行错误的日志存放位置。第二个参数决定了日记的级别，可选的值有 debug, info, notice, warn, error, crit, alert 或者 emerg#error_log  logs/error.log;    #error_log  logs/error.log  notice;#error_log  logs/error.log  info;#指定主进程id文件的存放位置，虽然worker_processes != 1的情况下，会有很多进程，管理进程只有一个#pid        logs/nginx.pid;    #这是工作者进程的最大文件打开数目worker_rlimit_nofile 1024;events {    #设置每个工作进程能够同时打开的最大连接数。需要注意的是：这个连接数是指所有的连接数（包括与代理服务器的连接数，还有其它的连接数），还有一点就是，最大连接数（worker_connections）的值不能超过当前工作者进程能够打开的最大文件数目（worker_rlimit_nofile）的限制    worker_connections  1024;       #连接规则，指定工作者进程的方法，一般不需要设置，nginx会选取最高效的方法，可以采用[kqueue rtsig epoll select poll eventport ]，    use   epoll;    }#================================以上是全局配置项http {    #=================================================以下是 http 协议主配置    #安装nginx后，在conf目录下除了nginx.conf主配置文件以外，有很多模板配置文件，这里就是将其它的文件包含到配置文件中    include       mime.types;    #HTTP核心模块指令，这里设定默认类型为二进制流，也就是当文件类型未定义时使用这种方式    default_type  application/octet-stream;         #日志格式    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                         '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    #日志文件存放的位置    #access_log  logs/access.log  main;             #启用或者禁用 sendfile()    sendfile        on;    #当sendfile启用时，该指令才会生效。它的作用是启用或者关闭在 freeDSB 中使用 TCP_NOPUSH socket 选项，或者在 linux 中使用 TCP_CORK socket 选项    tcp_nopush      on;    #启用或者禁用 TCP_NODELAY 选项，只有当一个连接是 keep-alive 状态时，该指令才会生效    tcp_nodelay     on;    #指定一个连接的等待时间（单位秒），如果超过等待时间，连接就会断掉。注意一定要设置，否则高并发情况下会产生性能问题。    keepalive_timeout  65;                          #开启数据压缩，后文详细介绍    gzip  on;                                       #=================================================以上是 http 协议主配置     #================================以下是Nginx后端服务配置项，upstream用来定义一组服务，里面的服务可以监听不同的端口。另外，服务也可以将 TCP 和 UNIX-domain sockets 进行混合使用。    upstream backendserver1 {        #nginx向后端服务器分配请求任务的方式，默认为轮询；如果指定了ip_hash，就是hash算法（上文介绍的算法内容）        #ip_hash            #后端服务器 ip:port ，如果有多个服务节点，这里就配置多个        server 192.168.220.131:8080;         server 192.168.220.132:8080;            #backup表示，这个是一个备份节点，只有当所有节点失效后，nginx才会往这个节点分配请求任务        #server 192.168.220.133:8080 backup;                #weight，固定权重，还记得我们上文提到的加权轮询方式吧。        #server 192.168.220.134:8080 weight=100;        }    #================================以上是Nginx后端服务配置项    #=================================================以下是一个服务实例的配置    server {        #用来设置虚拟主机要监听的端口        listen       80;        #设置虚拟主机的域名，多个域名使用空格隔开        #server_name         server_name  localhost;         # 指定特定的字符集到响应头部的 “Content-Type” 首部        charset utf-8;          #access_log 设置访问日记的路径及格式。        #access_log  logs/host.access.log  main;            #location将按照规则分流满足条件的URL。"location /"您可以理解为“默认分流位置”。        location / {            #root目录，这个html表示nginx主安装目录下的“html”目录。            root   html;               #目录中的默认展示页面            index  index.html index.htm;                }        #location支持正则表达式，“~” 表示匹配正则表达式。        location ~ ^/business/ {               #方向代理。后文详细讲解。            proxy_pass http://backendserver1;           }        #redirect server error pages to the static page /50x.html        #error_page  404              /404.html;        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }    #=================================================以上是一个服务实例的配置}从整体结构来看配置文件结构时这样子的，总共包括七大块。# main 1.全局配置    ...# 2.可以配置nginx的工作模式、工作者进程数    events {    ...}# 3.http的相关配置http {    ...    # 4.负载均衡配置块     upstream myproject{        ...    }    # 5.虚拟主机配置块    server {        ...        # 6.RUI 匹配块        location / {            ...            # 7.条件判断块            if(test_condition){                ...            }        }    }    server {        ...        location / {            ...            if(test_condition){                ...            }        }    }}</code></pre><p><strong>扩展信息：</strong></p><ul><li><p><strong>upstream块</strong></p><p>​    在Http Upstream模块中，可以设置后端服务器的socket信息，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用状态如下：</p><ul><li>down 表示当前server暂不参与负载均衡</li><li>backup 预留的备份机器</li><li>max_fails 允许请求失败的次数，默认为1，当超过最大次数时，返回proxy_next_stream模块定义的错误</li><li>fail_timeout 在经历max_fails次失败后，暂停服务的时间，可以和max_fails 一起使用。</li></ul><p>​     <strong>Nginx支持四种负载均衡的方法</strong>：</p><ul><li><p>Round-robin 根据权重的轮询方式，默认使用该方法</p><pre><code>upstream backend{    server backend1.example.com weight=3;    server backend2.example.com;}</code></pre></li><li><p>least_conn 具有最少活跃连接数的服务器将会被发送请求</p><pre><code>upsream backend{    least_conn;    server backend1.example.com;    server backend2.example.com;}</code></pre></li><li><p>ip_hash 根据客户端的ip地址来决定请求发送给哪个服务器（hash算法）</p><pre><code>upstream backend{    ip_hash;    server backend1.example,com;    server backend2.example.com;}</code></pre></li><li><p>hash 根据用户自定义的hash值来决定请求发送到哪个服务器</p><pre><code>upstream backend{    hash $request_uri consistent    server backend1.example.com;    server backend2.example.com;}</code></pre></li></ul></li><li><p><strong>location块</strong> </p><ul><li><p>一个location可以匹配字符串前缀，也可以匹配正则表达式。</p></li><li><p>正则表达式会以“<del>*”（大小写不敏感）开始，或以“</del>”（大小写敏感）开始。</p></li><li><p>解析url之后，会按照配置文件的顺序依次查找适配，一旦查到立马使用相关配置，并停止查找。</p></li><li><p>如果没有找到与之对应的正则表达式，那么值钱匹配的前缀字符串location里面的配置将会被采用。</p></li><li><p>使用“=”可以进行精确匹配。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>把 URI 作为字符串，以便于参数中 uri 做完全匹配</td></tr><tr><td>~</td><td>匹配URL时大小写敏感</td></tr><tr><td>~*</td><td>匹配URL时忽略字母大小写</td></tr><tr><td>^~</td><td>匹配URI时只需要前半部分与URI参数匹配</td></tr><tr><td>@</td><td>仅用于Nginx服务内部请求之间的重定向</td></tr></tbody></table><pre><code>location ~*\.(gif|jpg|jpeg)${    # 匹配以.gif .jpg .jpeg结尾的请求}</code></pre><p>如果请求可以匹配多个location，只会被第一个location处理。</p></li><li><p><strong>文件路径</strong></p><ul><li><p>以root 设置资源路径 root path</p><pre><code># 如果请求是 /abc/index/test.html 则web服务器将会返回 /data/html/abc/index/test.htmllocation /abc {    root /data/html}# 请求 .js文件都会返回 /data/js 下的文件location \/js$ {    root /data/js}</code></pre></li><li><p>以 alias 设置资源路径：alias path</p><pre><code># 访问 /abc 会映射到 /data/abc 文件夹location /abc {    alias /data/abc}# 等同于location /abc {    root /data}</code></pre></li><li><p>首页 index file</p><pre><code># 收到请求后，先尝试访问path/index.html 文件，如果可以访问，直接返回文件内容结束请求，否则，再尝试返回 path/index.phplocation / {    root path;    index /index.html /index.php}</code></pre></li><li><p>根据HTTP返回码重定向</p><pre><code>error_page 404 /404.htmlerror_page 502 503 504 /50x.htmlerror_page 403 http://example.com/forbidden.html</code></pre><p>通过 = 更改返回的错误码：</p><pre><code>error_page 404=200 /empty.gif</code></pre></li></ul></li><li><p><strong>反向代理服务器</strong></p><ul><li><p><strong>proxy_pass</strong></p><p>该配置将当前请求反向代理到URL参数指定的服务器上，URL可以是主机名或IP地址。</p><pre><code># 访问 /abc 会转发到 http://127.0.0.1:8080/index.htmllocation /abc {    proxy_pass http://127.0.0.1:8080/index.html}</code></pre></li></ul></li></ul></li></ul><h3 id="2-4-常用命令"><a href="#2-4-常用命令" class="headerlink" title="2.4 常用命令"></a>2.4 常用命令</h3><pre><code>nginx -s reload #使运行中的Nginx重加载配置并生效nginx -s stop #停止服务nginx -s quit #处理完当前所有请求再停止服务nginx -t # 检查配置信息是否有错误nginx -c new_nginx.conf #使用自定义配置文件</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka：深入原理</title>
      <link href="/2019/02/08/kafka-shen-ru-yuan-li/"/>
      <url>/2019/02/08/kafka-shen-ru-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​            Kafka的应用场景一般是<strong>大数据领域的实时计算、日志采集等</strong>，是业内标准。其设计的首要目标是解决网站中海量用户的操作行为记录、页面浏览记录，后被捐献给apche。以“满足搞数据吞吐量”为首要目标，因而在其他方面做出了一定的牺牲，比如：消息的事务性。</p><p>​        常用于收集操作日志，对于消息的可靠性没有太多要求。</p><h3 id="2-原理结构"><a href="#2-原理结构" class="headerlink" title="2.原理结构"></a>2.原理结构</h3><p>​        完整的Kafka解决方案包括四个要素：</p><ul><li><p>Producer（消息生产者）</p></li><li><p>Server Broker（服务代理器）</p></li><li><p>Zookeeper（协调者）</p></li><li><p>Consumer（消息消费者）</p><p><strong>Kafka在设计之初就被认为是集群化工作的</strong></p></li></ul><h4 id="2-1-Kafka-Broker-工作结构"><a href="#2-1-Kafka-Broker-工作结构" class="headerlink" title="2.1 Kafka Broker 工作结构"></a>2.1 Kafka Broker 工作结构</h4><p>​        <img src="/2019/02/08/kafka-shen-ru-yuan-li/1573789480(1).jpg" alt=""></p><ul><li>一个独立进行消息获取，消息记录和消息分送操作的队列称为topic，和ActiveMQ中的queue和topic属于同一概念</li><li>将Topic拆分分区，这些分区可能在同一个Broker上也可能在多个Broker上。</li><li>producer的消息会被分到各分区存储，一条消息只会被分到一个分区进行存储，并且这些消息以分区为单位，保持顺序排列。   这样的好处在于，消息派送到多个broker的多个分区上，充分调动计算资源</li><li>每一个分区还会有一个段结构或多个段结构<ul><li>.index后缀的索引文件：记录消息在整个topic中的序号以及在log中的偏移单位</li><li>.log后缀的数据文件：这条消息的真实内容</li></ul></li><li>对索引文件始终保证顺序读取</li><li>kafka对Linux操作系统下Page Cache技术的应用，才是其高性能的最大保证</li></ul><h4 id="2-2-Kafka-Cluster结构"><a href="#2-2-Kafka-Cluster结构" class="headerlink" title="2.2 Kafka Cluster结构"></a>2.2 Kafka Cluster结构</h4><p><strong>消息在kafka集群中的流动：</strong></p><p> <img src="/2019/02/08/kafka-shen-ru-yuan-li/cluster.jpg" alt=""></p><ul><li>消息生产者会决定发送的消息将会送入Topic的哪一个分区</li><li>在同一个Topic下，kafka会为不同的消费者组创建独立的index索引定位，生产者发送有个消息，topic下不同组的消费者都会收到消息。</li><li>同一个组下的消费者可以消费一个或多个分区中的消息，但是一个分区的消息只能被同一组下的某一个消费者所消费。</li><li>消费者会通过zookeeper协调集群获取当前消费组中其他消费者的连接状态，并得到当前topic下可用于消费的分区和该消费组中其他消费者的对应关系，若发现分区都已一一对应，则将自己挂起，以便接替后面的失效者</li><li>消费者发现存在一个消费者关联多个分区，并且处于繁忙不能全部处理时，会接替它处理一个或多个分区的消息，并且一直和这个分区保持关联</li><li>kafka集群只保证同一个分区下消息队列中的消息顺序</li><li>topic下分区的消息不是broker进行推送的，而是消费者主动拉取的。</li></ul><h4 id="2-3-复制功能"><a href="#2-3-复制功能" class="headerlink" title="2.3 复制功能"></a>2.3 复制功能</h4><ul><li>kafka让topic下的每一个分区复制到多个broker服务节点上，由zookeeper进行管理，目的是当leader挂掉之后，follower会成为leader。</li><li>两个概念区分：<ul><li>分区：若干消息按照一定的规则分别存放在不同的区域，一条消息只存入一个区域（<strong>且Topic下的多个分区可以存在同一个Broker上</strong>）</li><li>复制：为保证消息在被消费之前不丢失，需要将某一个区域中的消息集合复制出多个副本（<strong>同一个分区的多个副本不能存放在同一个Broker上</strong>）</li></ul></li><li><strong>只有当ISR中所有分区副本全部完成了某一条消息的同步过程，这条消息才算完成了真正的“记录”操作</strong>。</li></ul><h4 id="2-4-生产者"><a href="#2-4-生产者" class="headerlink" title="2.4 生产者"></a>2.4 生产者</h4><ul><li>生产者直接和Broker进行连接，并没有连接zookeeper进行协调，生产者唯一知道的就是Topic有多少个分区，以及每个分区存在于哪些Broker上，都是直接对一个Broker的轮询</li><li>生产者可以决定指向Topic的哪一个分区发送消息，而不是由Broker来决定</li><li>生产者可以决定对消息的一致性的关注的级别，或者又可以完全不关心</li><li>可以决定是异步，还是同步发送消息，如果是异步，还可以决定发送的周期</li><li>随机选取节点，读取当前Topic的分区和复制表信息，并保存到本地的Pool中</li><li>没有像ActiveMQ中那样的事务机制</li><li><strong>生产者指定分区</strong><ul><li>第一种，在创建消息对象KeyedMessage时，指定方法中partkey/key的值。</li><li>第二种：重新实现kafka.producer.Patitioner接口</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMQP：协议学习</title>
      <link href="/2019/02/06/amqp-xie-yi-xue-xi/"/>
      <url>/2019/02/06/amqp-xie-yi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  AMQP协议的全称是：Advanced Message Queuing Protocol（高级消息队列协议）。目前AMQP协议的版本为 Version 1.0，是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><h1 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2. 协议结构"></a>2. 协议结构</h1><p>  AMQP协议结构如下：</p><p><img src="/2019/02/06/amqp-xie-yi-xue-xi/AMQP1.PNG" alt=""></p><ul><li>由上图可以看出，AMQP结构的构成分为六块<ul><li><strong>Message</strong>：消息体</li><li><strong>Producer</strong>：生产者</li><li><strong>Consumer</strong>：消费者</li><li><strong>Virtual Host</strong>：虚拟节点</li><li><strong>Exchange</strong>：交换机</li><li><strong>Queue</strong>：队列<ul><li>AMQP的客户端由<strong>Producer</strong>和<strong>Consumer</strong>组成，服务端Broker则是由Virtual Host，Exchange和Queue组成。</li></ul></li></ul></li><li><strong>Message</strong>的传递需要客户端（Producer和Consumer）创建连接到Broker的连接Connection，之后由客户端在Connection之上建立channel通道连接到Virtual host或者Queue上。Connection支持多个Channel的建立，消息的发送与接受只有在channel上才能进行。</li><li><strong>Exchange</strong>作为协议中的交换机，可以和多个Queue以及Exchange进行绑定，消息会根据Exchange上的路由规则进行发送传播。Exchange要至少和一个Queue或者Exchange绑定关系，并且设置好Queue和Exchange的Routing（路由规则），Exchange根据路由规则发送消息到符合路由规则的Queue或Exchange中，路由规则可以和Message中的Routing key属性配合使用。Exchange的路由规则包含三种：<strong>Direct、Fanout、Topic</strong></li><li><strong>Queue</strong>对于消息的处理，没有channel连接到Queue时，消息将会被存储，知道channel被创建，如果channel已经创建，消息按顺序发送给channel</li><li><strong>Consumer</strong>在收到消息后，需要手动（可以设置自动发送和无需发送）发送一条ACK回应消息给对应的Queue，Queue接收到后，会将该消息移除掉，在channel断开之前Queue若未能收到消息，则该消息会被发送给其他的channel。发送NACK，消息会发送给其他channel，不论当前channel是否已经断开。<h1 id="3-消息格式"><a href="#3-消息格式" class="headerlink" title="3.消息格式"></a>3.消息格式</h1>  作为一种网络通讯协议，AMQP工作在七层/五层网路模型的应用层。其消息真正的内容主要在PAYLOAD区域，即交付区，非PAYLOAD区，在网络协议的应用层说明Channel的工作状态。<br>PAULOAD区域共七个数据区域：<table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>header</td><td>记录AMQP消息在“支持AMQP的中间件”中的交互状态，如消息在节点间被交互的总次数，优先级，TTL值等信息</td></tr><tr><td>delivery-annotations</td><td>在header部分只能传递规范的、标准的、经过ISO/IEC组织定义过的属性。所以对应这里用来记录“非标”的header信息</td></tr><tr><td>message-annotations</td><td>用于存储一些自定义的辅助属性，主要用于消息的转换</td></tr><tr><td>properties</td><td>AMQP消息的正文内容是从properties到application-data部分，properties记录了消息正文中标准的，规范的属性，例如消息ID，分组ID,发送者ID等</td></tr><tr><td>application-properties</td><td>主要记录和应用有关的数据，该协议的实现产品需要用这部分数据决定其处理逻辑，例如消息的Routing是什么，是否进行持久化等</td></tr><tr><td>application-data</td><td>使用二进制格式描述的AMQP消息的用户部分内容，即发送的真实内容</td></tr><tr><td>footer</td><td>一般用来存储辅助内容，如消息的哈希值，HMAC，签名或加密细节</td></tr></tbody></table></li></ul><h1 id="3-Exchange路由规则"><a href="#3-Exchange路由规则" class="headerlink" title="3. Exchange路由规则"></a>3. Exchange路由规则</h1><table><thead><tr><th>规则命称</th><th>区别</th></tr></thead><tbody><tr><td>Direct路由</td><td>该模式下Exchange将使用消息中所携带的Routing key 和Queue中的Routing key进行比较，如果匹配，该消息进入该队列</td></tr><tr><td>Fanout</td><td>Exchange接受消息后，会将消息赋值多份，发送到自己绑定的Exchange和Queue中，不需要Routing key</td></tr><tr><td>Topic路由</td><td>Exchange将支持‘#’和’*‘通配符进行Routing key的匹配查找</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> AMQP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stomp：协议学习</title>
      <link href="/2019/02/03/stomp-xie-yi-xue-xi/"/>
      <url>/2019/02/03/stomp-xie-yi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  消息从发送到接受的方式有两种：一种称为<strong>即时消息通讯</strong>，即一端发送之后，另一端能够立即接受 ，具体实现就是RPC。另一种称为<strong>延迟消息通讯</strong>，即消息发出后，进入中间容器进行存储，到达一定条件之后，再发送给接受者，中间的容器称为<strong>消息队列</strong>。<br>  <strong>Stomp协议</strong>，英文全名<strong><em>Streaming Text Orientated Message Protocol</em></strong>，中文名称为 ‘流文本定向消息协议’。是一种以纯文本为载体的协议，前身是TTMP协议，专为消息中间件设计。<br>  <strong>Stomp协议属于延迟消息通讯</strong><br>  目前的版本为V1.1和V1.2</p><h3 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2.协议结构"></a>2.协议结构</h3><p>  标准的协议包括：<strong>命令/关键信息，头信息，文本内容</strong></p><pre><code>CONNECT    //命令accept-version:1.2  //版本号（头信息）param1:value1param2:value2this is stomp    //文本内容</code></pre><p>  Stomp协议由两个角色组成：<strong>客户端(Client)</strong>和<strong>消息代理(Broker)</strong></p><p><img src="/2019/02/03/stomp-xie-yi-xue-xi/1566985233886.png" alt="1566985233886"></p><p>  <strong>消息代理（Broker）</strong>只负责接受和存储客户端发送的消息，依据客户端要求的路径进行转发，对消息内容不做任何处理，只负责客户端连接和订阅</p><h3 id="3-交互流程及命令"><a href="#3-交互流程及命令" class="headerlink" title="3. 交互流程及命令"></a>3. 交互流程及命令</h3><p>   交互流程大致如下图：<br><img src="/2019/02/03/stomp-xie-yi-xue-xi/1566986429790.png" alt="1566986429790"></p><ul><li><strong>CONNECT/STOMP</strong>：客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</li><li><strong>CONNECTED</strong>：代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</li><li><strong>SEND</strong>：客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</li><li><strong>BEGIN</strong>：Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</li><li><strong>COMMIT</strong>：提交事务。使得事务中的一条或多条消息进入Stomp代理队列</li><li><strong>ABORT</strong>：取消/终止当前还未COMMIT的事务。</li><li><strong>SUBSCRIBE</strong>：订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</li><li><strong>UNSUBSCRIBE</strong>：取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</li><li><strong>ACK</strong>：若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</li><li><strong>NACK</strong>：若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</li><li><strong>DISCONNECT</strong>：断开客户端和消息代理之间的连接</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong>CONNECT/STOMP</strong></td><td>客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</td></tr><tr><td><strong>CONNECTED</strong></td><td>代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</td></tr><tr><td><strong>SEND</strong></td><td>客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</td></tr><tr><td><strong>BEGIN</strong></td><td>Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</td></tr><tr><td><strong>COMMIT</strong></td><td>提交事务。使得事务中的一条或多条消息进入Stomp代理队列</td></tr><tr><td><strong>ABORT</strong></td><td>取消/终止当前还未COMMIT的事务</td></tr><tr><td><strong>SUBSCRIBE</strong></td><td>订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</td></tr><tr><td><strong>UNSUBSCRIBE</strong></td><td>取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</td></tr><tr><td><strong>ACK</strong></td><td>若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</td></tr><tr><td><strong>NACK</strong></td><td>若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</td></tr><tr><td><strong>DISCONNECT</strong></td><td>断开客户端和消息代理之间的连接</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> Stomp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ：安装</title>
      <link href="/2019/01/27/activemq-an-zhuang/"/>
      <url>/2019/01/27/activemq-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   ActiveMQ安装较为简单, 下载的官网：<a href="https://activemq.apache.org/download-archives.html" target="_blank" rel="noopener">ActiveMQ</a></p><h1 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h1><ul><li>解压包</li></ul><pre><code>tar -zxvf apache-activemq-5.13.2-bin.tar.gz  </code></pre><ul><li>配置环境变量</li></ul><pre><code>vim /etc/profile</code></pre><p>添加内容如下：</p><pre><code>############activemq############export PATH=/usr/lixs/activemq/apache-activemq-5.13.2/bin/linux-x86-64:$PATH</code></pre><ul><li>启动程序</li></ul><pre><code>activemq start</code></pre><ul><li>访问页面 ip + 8161</li></ul><p><img src="/2019/01/27/activemq-an-zhuang/1567665904552.png" alt="1567665904552"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 消息中间件 </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ：存储方案</title>
      <link href="/2019/01/20/activemq-cun-chu-fang-an/"/>
      <url>/2019/01/20/activemq-cun-chu-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  上文已经学习了ActiveMQ的存储分为两种：持久化和非持久化，其中持久化的介质可以是<strong>磁盘文件系统</strong>，也可以是其<strong>内置数据库</strong>，或者外部的<strong>关系型数据库</strong>。</p><h1 id="2-持久化存储"><a href="#2-持久化存储" class="headerlink" title="2.持久化存储"></a>2.持久化存储</h1><ul><li>发布订阅模式下，没有订阅者时，消息也要进行先存储再标记，但不一定进入物理磁盘。</li><li>事务没有提交的情况下，消息依旧会被服务端持久化，但没有进入到具体的队列之中。</li><li>服务端持久化消息的行为，可以设置为异步，持久化完成会告知服务端。</li><li>持久化数据的删除，只有在消息被通知已经被消费时，才会被移除。<h2 id="2-1-配置介绍"><a href="#2-1-配置介绍" class="headerlink" title="2.1 配置介绍"></a>2.1 配置介绍</h2>  ActiveMQ每一个服务节点都是一个独立的进程。</li></ul><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td>systemUsage</td><td>表示进程级别的容量设置</td></tr><tr><td>memoryUsage</td><td>子标记设置节点的“可用内存限制”，内存容量供所有队列使用</td></tr><tr><td>storeUsage</td><td>标记节点的用于存储“持久化消息”的“可用磁盘空间”，采用数据库存储方案，该参数无作用</td></tr><tr><td>tempUsage</td><td>设置“temp store”的可用磁盘空间限制</td></tr></tbody></table><h1 id="3-存储方案"><a href="#3-存储方案" class="headerlink" title="3.存储方案"></a>3.存储方案</h1><h2 id="3-1-KahaDB"><a href="#3-1-KahaDB" class="headerlink" title="3.1 KahaDB"></a>3.1 KahaDB</h2><h3 id="3-1-1-基本结构"><a href="#3-1-1-基本结构" class="headerlink" title="3.1.1 基本结构"></a>3.1.1 基本结构</h3><p>emsp;emsp;KahaDB基于文件系统，支持事务，是目前ActiveMQ默认的持久化存储方案。<br>基本元素：</p><ul><li><p>Metadata Cache：用于在内存中检索消息的存储位置</p></li><li><p>Data log：记录消息内容，默认大小为32M，当其内部所有消息被成功消费后，该文件会在Metadata Cache中被标记为删除，在下一个checkpoint周期进行删除操作。Data log文件采用顺序写的方式操作，为保证物理上的连接，文件需要进行区域预占。</p></li><li><p>Metadata Store：在磁盘上检索消息存储位置。内存中没有被处理的消息索引会以一定周期，同步到Metadata Store中。</p></li><li><p>redo文件：用于系统异常关闭后恢复Btree结构</p><h3 id="3-1-2-配置KahaDB"><a href="#3-1-2-配置KahaDB" class="headerlink" title="3.1.2 配置KahaDB"></a>3.1.2 配置KahaDB</h3><p>  ActiveMQ会默认启动KahaDB。</p><pre><code>&lt;broker xmlns="http://activemq.apache.org/schema/core"  brokerName="localhost" dataDirectory="${activemq.data}"&gt;  ......  &lt;persistenceAdapter&gt;      &lt;kahaDB directory="${activemq.data}/kahadb" journalMaxFileLength="64mb" indexWriteBatchSize="500"/&gt;  &lt;/persistenceAdapter&gt;  ......&lt;/broker&gt;</code></pre></li><li><p>journalMaxFileLength：表示设置后的信息文件大小</p></li><li><p>indexWriteBatchSize：表示Metadata Cache 和 Metadata Store进行checkpoint同步的上限</p></li></ul><h2 id="3-2-LevelDB"><a href="#3-2-LevelDB" class="headerlink" title="3.2 LevelDB"></a>3.2 LevelDB</h2><h3 id="3-2-1-基本结构"><a href="#3-2-1-基本结构" class="headerlink" title="3.2.1 基本结构"></a>3.2.1 基本结构</h3><p>  核心的设计算法是<strong>跳跃表</strong>，核心操作策略是对磁盘上的数据日志结构进行归并（LSM）。</p><p>  结构元素如下：</p><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td>Log 文件</td><td>新的消息进入时，直接写log文件目的是系统异常时能够进行数据的恢复，采用预占磁盘空间的形式顺序写入，可设置为异步，有丢失数据风险</td></tr><tr><td>MemTable//Immutable</td><td>新的消息进入时，会写入MemTable，内部数据组织结构就是跳跃表。当内部数据大于一定参数值时，会被标记为Immutable，开启一个新的MemTable,Imuutable的“删除”数据会被剔除，其余可能压缩写入到.sst文件中</td></tr><tr><td>SStable</td><td>位于硬盘，后缀为.sst，默认大小为2M,因其按照数据的key排序随机写，固无需预占磁盘空间<br>SSTable文件也分层次，每层为上层的十倍，某曾达到最大值时，选取一个文件做Compact操作<br>读写SSTable的最小单元是Block，大小为4KB，最后的Index Block指明每SSTable一个Data Block的起始位置<br>LevelDB的内存区域，存在Block Cache区域，存储众多的Index Block</td></tr><tr><td>Manifest</td><td>该文件记录sst文件的关键信息，包括：某个.sst文件属于哪一个Level，最小key值是多少，最大key值是多少等</td></tr></tbody></table><h3 id="3-2-2-配置LevelDB"><a href="#3-2-2-配置LevelDB" class="headerlink" title="3.2.2 配置LevelDB"></a>3.2.2 配置LevelDB</h3><pre><code>&lt;persistenceAdapter&gt;    &lt;levelDB directory="${activemq.data}/levelDB" logSize="52428800" sync="false"/&gt;&lt;/persistenceAdapter&gt;</code></pre><ul><li>directory：LevelDB的结构文件所放置的目录位置</li><li>logSize：默认大小为100M，采用预占用磁盘，即一旦消息进入，就会有100MB被预先占用。</li><li>sync：异步写log，异步在内存区域向Memtable写入位置索引。<h2 id="3-3-关系型数据库"><a href="#3-3-关系型数据库" class="headerlink" title="3.3 关系型数据库"></a>3.3 关系型数据库</h2>  ActiveMQ支持使用关系型数据库进行持久化存储–通过JDBC实现数据库的连接。<br>mysql数据库配置如下：</li></ul><pre><code>&lt;broker&gt;     &lt;persistenceAdapter&gt;        &lt;jdbcPersistenceAdapter dataSource="#mysql_datasource" createTablesOnStartup="true"/&gt;    &lt;/persistenceAdapter&gt;&lt;/broker&gt;&lt;bean id="mysql_datasource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;  &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;  &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/activemqdb?relaxAutoCommit=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8"/&gt;  &lt;property name="user" value="root"/&gt;  &lt;property name="password" value="123456"/&gt;  &lt;property name="minPoolSize" value="10"/&gt;  &lt;property name="maxPoolSize" value="30"/&gt;  &lt;property name="initialPoolSize" value="10"/&gt;&lt;/bean&gt;</code></pre><p><strong>备注：</strong>使用关系型数据库，需要将相关jar包放置到安装路径下的./lib目录下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ：基本原理</title>
      <link href="/2019/01/13/activemq-ji-ben-yuan-li/"/>
      <url>/2019/01/13/activemq-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  ActiveMQ是Apache软件基金会的开源产品，支持AMQP协议、MQTT协议、Openwire协议和Stomp协议等多种消息协议,并且支持JMS API接口规范。</p><h1 id="2-基本参数"><a href="#2-基本参数" class="headerlink" title="2. 基本参数"></a>2. 基本参数</h1><table><thead><tr><th>参数名称</th><th>参数介绍</th></tr></thead><tbody><tr><td>stop</td><td>停止当前ActiveMQ节点的运行</td></tr><tr><td>restart</td><td>重启当前的ActiveMQ节点</td></tr><tr><td>status</td><td>仅展示当前节点是处于运行还是停止</td></tr><tr><td>console</td><td>使用控制台启动ActiveMQ节点</td></tr><tr><td>dump</td><td>采用console启动ActiveMQ,使用dump参数，可获取当前线程的快照</td></tr></tbody></table><h1 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3.工作机制"></a>3.工作机制</h1><p>  ActiveMQ有两种不同的模式队列：<strong>Topic订阅-发布模式，Queue负载均衡模式。</strong></p><table><thead><tr><th>比较内容</th><th>Topic</th><th>Queue</th></tr></thead><tbody><tr><td>工作模式</td><td>“订阅-发布”模式，如果有多个订阅者，消息会被复制多份进行发送，若没有订阅者，消息将会被丢弃</td><td>“负载均衡”模式，如果有多个消费者，消息只会发送给其中的一个，并且要求ack进行消息的确认，如果没有消费者，消息将会被保存，直到有消费者连接订阅</td></tr><tr><td>持久化</td><td>不会</td><td>数据默认在MQ服务器上以文件形式进行保存，可以配置为DB存储</td></tr><tr><td>传递完整性</td><td>没有订阅者，消息将被丢弃</td><td>没有订阅者，消息被存储</td></tr><tr><td>效率</td><td>处理性能会伴随订阅者数量的增加而降低，并且也要考虑使用的协议性能差异</td><td>仅有一个消费者进行信息的接受，性能不随消费者数量的变化而影响，但也受协议影响</td></tr><tr><td># 4. 优化</td><td></td><td></td></tr><tr><td>  ActiveMQ的优化可以考虑从多个次层入手，如<strong>代码级性能、规则性能、网络性能和集群方案</strong>。</td><td></td><td></td></tr></tbody></table><h2 id="4-1-网络性能优化"><a href="#4-1-网络性能优化" class="headerlink" title="4.1 网络性能优化"></a>4.1 网络性能优化</h2><p>  ActiveMQ的网络信息传递方式默认是基于网络模型的BIO方式，为提高单点性能，可以为单个节点配置更高效的网络IO模型。<br>  ActiveMQ支持的协议如下：</p><ul><li><strong>AMQP</strong></li><li><strong>MQTT</strong></li><li><strong>OpenWire</strong></li><li><strong>REST</strong></li><li><strong>Stomp</strong></li><li><strong>XMPP</strong></li></ul><p><strong>不同的协议需要设置不同的网络监听端口</strong>，详见./conf/conf/activemq.xml文件。<br><strong>ActiveMQ中默认的消息协议是openwire</strong><br>在5.13.0+版本后，OpenWire，Stomp，AMQP，MQTT四种协议的端口监听进行了合并，使用auto关键字进行表示。ActiveMQ将会监听这一个端口的消息状态，匹配合适的协议格式,优化使得连接管理变的简洁，但没有提升单节点的处理性能。</p><pre><code>&lt;transportConnectors&gt;    &lt;transportConnector name="auto" uri="auto://0.0.0.0:61617?maximumConnections=1000" /&gt;&lt;/transportConnectors&gt;</code></pre><p>端口默认使用BIO网络IO模型，为提高单节点吞吐量，可以指定网络模型为nio：</p><pre><code>&lt;transportConnectors&gt;      &lt;transportConnector name="nio" uri="nio://0.0.0.0:61618?maximumConnections=1000"/&gt;  &lt;/transportConnectors&gt;</code></pre><p>让某一端口支持NIO和协议：</p><pre><code>&lt;transportConnector name="stomp+nio" uri="stomp+nio://0.0.0.0:61613?transport.transformer=jms"/&gt;// 表示这个端口使用NIO模型支持Stomp协议</code></pre><p>让某一端口支持NIO网络和多协议：</p><pre><code>&lt;transportConnector name="auto+nio" uri="auto+nio://0.0.0.0:61608?maximumConnections=1000" /&gt;</code></pre><p>每一种协议都有一些特定的参数，各协议也包含共用的参数，具体详见官方文档<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ官网</a></p><h2 id="4-2-处理规则和优化"><a href="#4-2-处理规则和优化" class="headerlink" title="4.2 处理规则和优化"></a>4.2 处理规则和优化</h2><h3 id="4-2-1-JMS规范概念"><a href="#4-2-1-JMS规范概念" class="headerlink" title="4.2.1 JMS规范概念"></a>4.2.1 JMS规范概念</h3><p>   ActiveMQ是JMS规范的完整实现，故其调度与存储等原理与JMS中的概念原理相关。JMS的相关概念如下表：</p><ul><li><p>订阅发布与负载均衡模式<br>详见ActiveMQ的工作机制。</p></li><li><p>持久化消息和非持久化</p><table><thead><tr><th>差异</th><th>持久化（PERSISTENT）</th><th>非持久化（NON_PERSISTENT）</th></tr></thead><tbody><tr><td>存储位置</td><td>不受JMS服务端异常状态的影响，服务端会持久化保存消息，直到被处理</td><td>只存储在JMS服务节点的内存区域</td></tr><tr><td>持久化方案</td><td>KahaDB、AMQ和关系型数据库</td><td>无</td></tr><tr><td>宕机</td><td>数据保存</td><td>数据丢失</td></tr><tr><td>策略</td><td>无</td><td>内存区域不足时，采用辅助方案进行转存（ActiveMQ使用临时存储区域）</td></tr></tbody></table></li><li><p>持续订阅和非持续订阅<br>是针对<strong>“订阅-发布”</strong>模式的细分处理策略</p><ul><li>持续订阅（Durable-subscribers）被标记的用户获取某条消息和它曾经下线没有任何关系，Topic会保存该消息，直到订阅者上线，该消息被正确处理为止。</li><li>非持久化订阅（Non-Durable-subscribers）Topic不再为下线的订阅者保留消息，发送给在线的消费者之后就可以标记为“处理完成”。<h3 id="4-2-2-生产者与消费者优化"><a href="#4-2-2-生产者与消费者优化" class="headerlink" title="4.2.2 生产者与消费者优化"></a>4.2.2 生产者与消费者优化</h3><h4 id="4-2-2-1-生产者（producer）"><a href="#4-2-2-1-生产者（producer）" class="headerlink" title="4.2.2.1 生产者（producer）"></a>4.2.2.1 生产者（producer）</h4>  生产者发送消息支持<strong>同步发送</strong>和<strong>异步发送</strong>。在消息产生堆积的情况下，补不能一味只追求发送效率。<br>  处理消息堆积的基本原则是：</li></ul></li><li><p><strong>持久化状态</strong>：无论如何消息总会被持久化存储，再视情况进行发送。完成消息的存储后，服务节点<strong>会</strong>向生产者发送回执确认消息。</p></li><li><p><strong>非持久化状态</strong>：在内存中产生消息堆积后，会进行消息的转储到Temp store区域。完成消息的存储后，服务节点<strong>不会</strong>向生产者发送回执确认消息。<br>以上两种，如果区域也产生堆积，则会通知生产者开启Slow Producer机制。</p><h5 id="4-2-2-1-1-生产者消息发送"><a href="#4-2-2-1-1-生产者消息发送" class="headerlink" title="4.2.2.1.1 生产者消息发送"></a>4.2.2.1.1 生产者消息发送</h5><p>   生产者默认发送的消息是<strong>持久化类型</strong>，非持久化消息需要明确指明，并且非持久的消息发送默认方式为<strong>异步方式</strong>，即消息存储之后默认不会发送回执消息给生产者。</p></li></ul><p><strong>注意</strong>：异步模式下，在生产者发送一定量的消息后，也需要等待服务端的消息回执,否则会导致消息堆积，需要进行相关配置，仅限异步模式下，是必须配置的。</p><pre><code>    //以下语句设置消息发送者在累计发送102400byte大小的消息后（可能是一条消息也可能是多条消息    connectionFactory.setProducerWindowSize(102400);</code></pre><p>使用以下配置可以异步条件下每次消息的存储都返回回执信息：</p><pre><code>//会降低消息发送的效率    connectionFactory.setAlwaysSyncSend(true);</code></pre><p>在发送持久化消息时，也可以设置为异步方式。</p><pre><code>//发送持久化消息时设置的异步    connectionFactory.setUseAsyncSend(true);    //因此异步模式下也要设置回执窗口    connectionFactory.setProducerWindowSize(102400);</code></pre><p><em>小结：</em><br>||持久化（系统默认）|非持久化|<br>|– |– |—|<br>|默认方式|同步发送|异步发送|<br>|改为同步||每次进行消息回执<br>connectionFactory.setAlwaysSyncSend(true);|<br>|改为异步|connectionFactory.setUseAsyncSend(true);<br>设置回执窗口<br>connectionFactory.setProducerWindowSize(102400);|并非改为同步<br>异步模式下需要设置回执connectionFactory.setProducerWindowSize(102400);|</p><h5 id="4-2-1-1-2-生产者事务"><a href="#4-2-1-1-2-生产者事务" class="headerlink" title="4.2.1.1.2 生产者事务"></a>4.2.1.1.2 生产者事务</h5><p>  事务由消息发送者发起，会在连接会话中设置一个Transaction ID,之后可以在事务中发送多条消息。事务未提交之前，消息已经被服务端所接受，但不会进入队列（发现有Transaction ID），消息会被先放置在“transaction store”中，该区域存在“redo”日志，用于事务的回滚。事务在被提交之后，服务端根据自身的规则（持久化还是非持久化）进行消息的入队操作（无论订阅-发布模式还是负载均衡模式）。</p><h5 id="4-2-1-1-3-生产者策略"><a href="#4-2-1-1-3-生产者策略" class="headerlink" title="4.2.1.1.3 生产者策略"></a>4.2.1.1.3 生产者策略</h5><p>  ProducerFlowControl 生产控制流，当发生消息堆积时，生产者收到服务端的回执消息，服务端会让生成者进入<strong>等待状态</strong>或者直接<strong>抛出JMSException</strong>异常。<br>  关闭订阅-发布的生产控制流</p><pre><code> &lt;policyEntry topic="&gt;" producerFlowControl="false"/&gt;</code></pre><p>  启用负载均衡的生产控制流</p><pre><code>&lt;policyEntry queue="&gt;" producerFlowControl="true" memoryLimit="200mb"&gt;</code></pre><p>memoryLimit 表示每个Queue信息的最大内存存储限制，指最多使用200MB的内存区域，非消息总和。</p><h4 id="4-2-2-2-消费者"><a href="#4-2-2-2-消费者" class="headerlink" title="4.2.2.2 消费者"></a>4.2.2.2 消费者</h4><p>  相比较于生产者，消费者的性能会更加影响ActiveMQ系统的整体性能。</p><h5 id="4-2-2-2-1-消费者消息接收"><a href="#4-2-2-2-1-消费者消息接收" class="headerlink" title="4.2.2.2.1 消费者消息接收"></a>4.2.2.2.1 消费者消息接收</h5><p>  默认情况下，ActiveMQ服务端采用异步的方式向消费者推送消息，即服务端不会一直等待消费者响应，消费者完成消息处理之后，主动发送状态到服务端。<br>  将推送设置为同步：</p><pre><code>connectionFactory.setDispatchAsync(false);</code></pre><p>  服务端推送消息给消费者，存在推送数量限制，即“预期数量”PrefetchSize。ActiveMQ的默认策略是一旦有新的消息，就主动按照设置的规则推送给当前活动的消费者。<br>   针对不同的工作机制，不同的存储方案，服务端有不同的预期数量设置：<br>||Queue|Topic|<br>|–|–|–|<br>|持久化|1000|100|<br>|非持久化|1000|32766|</p><ul><li>通过ActiveMQPrefetchPolicy变更预取数量<pre><code>// 预取策略对象ActiveMQPrefetchPolicy prefetchPolicy = connectionFactory.getPrefetchPolicy();// 设置Queue的预取数量为50prefetchPolicy.setQueuePrefetch(50);connectionFactory.setPrefetchPolicy(prefetchPolicy);</code></pre></li><li>更改Properties属性变更预取数量<pre><code>Properties props = new Properties();props.setProperty("prefetchPolicy.queuePrefetch", "1000");props.setProperty("prefetchPolicy.topicPrefetch", "1000");//设置属性connectionFactory.setProperties(props);</code></pre><h5 id="4-2-2-2-2-消费者事务"><a href="#4-2-2-2-2-消费者事务" class="headerlink" title="4.2.2.2.2 消费者事务"></a>4.2.2.2.2 消费者事务</h5>  消费者采用事务告知服务器一组消息是否处理成功，要么全部处理成功，要么失败全部进行回滚。<br>  调用回滚时，回滚之前的数据将会被重新进行发送，并且在同一个会话之中。消息的重发计数器（redeliveryCounter）属性将会加1.<h5 id="4-2-2-2-3-死信队列"><a href="#4-2-2-2-3-死信队列" class="headerlink" title="4.2.2.2.3 死信队列"></a>4.2.2.2.3 死信队列</h5>  一条消息失败，会进行回滚重发，一旦重发次数达到一定的策略值（默认为6次），该消息将会被加入到死信队列。</li><li>非持久化策略下，消息超过重发上限，将会被删除</li><li>默认情况下持久化策略下，消息会加入到死信队列<br>  设置非持久化也加入到死信队列：<pre><code>&lt;policyEntry queue="&gt;"&gt;    &lt;deadLetterStrategy&gt;        &lt;sharedDeadLetterStrategy processNonPersistent="true" /&gt;    &lt;/deadLetterStrategy&gt;  &lt;/policyEntry&gt;</code></pre>  修改默认的重发次数：<pre><code>RedeliveryPolicy redeliveryPolicy = connectionFactory.getRedeliveryPolicy();// 设置最大重发次数redeliveryPolicy.setMaximumRedeliveries(3);</code></pre>  触发重发的三种机制：<table><thead><tr><th>描述</th><th>重发计数器的作用域</th></tr></thead><tbody><tr><td>在消费者连接会话中调用回滚</td><td>本次连接会话</td></tr><tr><td>在消费者连接会话中，commit之前，连接终止</td><td>整个ActiveMQ系统范围</td></tr><tr><td>在发送ACK告知服务器之前，连接终止</td><td>整个ActiveMQ系统范围</td></tr><tr><td>##### 4.2.2.2.4 消费者acknowledge策略</td><td></td></tr><tr><td>  消费者端通知服务器的两种方式：<strong>事务</strong>和<strong>acknowledge</strong></td><td></td></tr></tbody></table></li></ul><p>  acknowledge模式的四种方式：<br>|参数|简介|<br>|–|–|<br>|AUTO_ACKNOWLEDGE|连接会话会自动认为消费者端对消息的处理时成功的，无论是服务端主动推送还是消费者端主动拉取，但消费端不一定是逐条进行ACK|<br>|CLIENT_ACKNOWLEDGE|同上场景，但必须要进行ACK确认，否则认为消息没有处理成功|<br>|DUPS_OK_ACKNOWLEDGE|批量确认方式，消费端依据策略间隔发送ack，表示一批消息处理完成|<br>|INDIVIDUAL_ACKNOWLEDGE|单独确认方式，消费者端逐条发送ack确认消息，性能较差|</p><p><strong>备注</strong>：</p><ul><li>推荐使用AUTO_ACKNOWLEDGE + optimizeACK，该优化选项只有在AUTO_ACKNOWLEDGE的模式下生效，目的在于“延迟确认”，当消息的数量达到策略值，通过ack告知服务端，这批消息处理完成。<strong>数量阈值为：prefetch*0.65, 时间阈值为：&gt; optimizeAcknowledgeTimeOut</strong></li><li>DUPS_OK_ACKNOWLEDGE 在<strong>负载均衡模式</strong>下和AUTO_ACKNOWLEDGE是一致的。</li><li>AUTO_ACKNOWLEDGE 下 如果prefetchSize = 1,也会进行逐条确认</li><li>如果是<strong>发布-订阅模式</strong>，阈值&gt;= prefetch*0.5时，都会进行批量确认。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：类加载机制</title>
      <link href="/2019/01/05/java-xu-ni-ji-lei-jia-zai-ji-zhi/"/>
      <url>/2019/01/05/java-xu-ni-ji-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是类加载机制？"><a href="#1-什么是类加载机制？" class="headerlink" title="1.什么是类加载机制？"></a>1.什么是类加载机制？</h3><ul><li>虚拟机把描述类的数据从Class文件加载到内存中，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</li><li><strong>类型的加载，连接和初始化都是在程序运行期间完成的</strong>，增加了性能开销，但是提高了代码灵活性</li><li>用户可以通过java预定义的和自定义类加载器，让本地的应用程序可以在运行时，从网络或者其他地方加载一个二进制流作为程序代码的一部分</li></ul><h3 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2.类加载的时机"></a>2.类加载的时机</h3><h5 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h5><ul><li>要完成的事情<ul><li>通过类的全限定名获取此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java。lang。Class对象，作为方法区的这个类的各种数据访问入口。Hotspot会将其放到方法区中</li></ul></li><li>数组类本身不通过类加载器创建，由java虚拟机直接创建，但数组类的元素类型，最终要靠类加载器进行创建<ul><li>如果数组的组件类型是引用类型，就采用上述加载过程进行加载</li><li>如果是非引用类型，虚拟机将会把数组C标记为与引导类加载器相关联</li></ul></li></ul><h5 id="2-2-连接"><a href="#2-2-连接" class="headerlink" title="2.2 连接"></a>2.2 连接</h5><ul><li>验证<ul><li>目的是确保Class文件的字节流包含的信息符合当前虚拟机的要求，不会危害虚拟机。</li></ul></li><li>准备</li><li>解析</li></ul><p>​        <strong>备注：加载和连接阶段的部分内容是交叉进行的</strong></p><h5 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h5><ul><li>遇到new等字节码指令时，如果类没有初始化，则需要先触发初始化，触发点为<ul><li>new关键字实例化对象</li><li>读取或设置一个类的非常量静态字段</li><li>调用一个类的静态方法</li></ul></li><li>对类进行反射调用，类没有初始化，则需要先初始化。</li><li>初始化一个类，父类若没有初始化，先初始化父类</li><li>虚拟机启动，用户指定一个要执行的主类，即包含main方法，先初始化主类</li><li>方法句柄所对应的类没有进行初始化，则需要触发初始化。</li><li>被动引用不会触发初始化<ul><li>通过其子类来引用父类中定义的静态字段，只会触发父类的初始化，而不会触发子类的初始化</li><li>通过数组来定义引用类，不会触发此类的初始化</li><li>final  常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，不会触发定义常量类的初始化</li></ul></li><li>一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用到父接口的时候，才会初始化。</li></ul><h5 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h5><h5 id="2-5-卸载"><a href="#2-5-卸载" class="headerlink" title="2.5 卸载"></a>2.5 卸载</h5><p>​                </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：垃圾收集器与内存分配策略</title>
      <link href="/2019/01/03/java-xu-ni-ji-la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
      <url>/2019/01/03/java-xu-ni-ji-la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/</url>
      
        <content type="html"><![CDATA[<h3 id="1-回收依据"><a href="#1-回收依据" class="headerlink" title="1. 回收依据"></a>1. 回收依据</h3><h5 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h5><ul><li>给对象添加一个引用计数器，每当有一个地方引用它，计数器值加1，引用失效，计数器减1，任何时刻计数器为0，表示该对象不再使用</li><li>实现简单，判定效率高</li><li>主流虚拟机未采用其进行内存管理，因为难以解决对象之间相互循环引用的问题</li></ul><h5 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h5><ul><li>以一系列GC roots的对象作为起始点，从这些节点向下搜索，走过的路径称为引用链，当一个对象到GC root没有任何引用链，则认为该对象不可达，不可用。</li><li><em>GC root</em><ul><li>虚拟机栈中引用的对象</li><li>方法区中静态类引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li></ul><h3 id="2-对象引用"><a href="#2-对象引用" class="headerlink" title="2.对象引用"></a>2.对象引用</h3><h5 id="2-1-强引用"><a href="#2-1-强引用" class="headerlink" title="2.1 强引用"></a>2.1 强引用</h5><ul><li>只要强引用在，垃圾收集器就永远不会回收掉被引用的对象</li></ul><h5 id="2-2-软引用"><a href="#2-2-软引用" class="headerlink" title="2.2 软引用"></a>2.2 软引用</h5><ul><li>还有用，但非必须的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收</li></ul><h5 id="2-3-弱引用"><a href="#2-3-弱引用" class="headerlink" title="2.3 弱引用"></a>2.3 弱引用</h5><ul><li>被弱引用关联的对象只能生存到下一次垃圾收集发生之前，无论内存是否足够，都会被回收</li></ul><h5 id="2-4-虚引用"><a href="#2-4-虚引用" class="headerlink" title="2.4 虚引用"></a>2.4 虚引用</h5><ul><li>幽灵引用或幻影引用，存在的唯一目的是该对象被回收时，收到一个通知。</li></ul><h3 id="3-对象的回收"><a href="#3-对象的回收" class="headerlink" title="3. 对象的回收"></a>3. 对象的回收</h3><ul><li>即使在可达性算法中不可达的对象，也并非非死不可，一个对象的死亡需要经历两次标记过程。</li><li>认为对象不可达之后，将会进行第一次标记筛选，条件是，该对象是否又必要执行finalize（）方法，对象如果没有覆盖finalize方法，或者已经执行过该方法，则虚拟机认为该对象没有必要执行。</li><li>如果该对象被判定为有必要执行将被放到F-Queue的队列之中，并由一个虚拟机建立的低优先级的Finalize线程去执行它。</li><li>虚拟机对F-Queue进行第二次小规模标记，对象要在finalize（）中拯救自己，只要和引用链的任何一个对象建立关联即可。这样在第二次标记时，它将被移出“即将回收”的集合，否将就将要被回收</li></ul><h3 id="4-回收方法区"><a href="#4-回收方法区" class="headerlink" title="4.  回收方法区"></a>4.  回收方法区</h3><ul><li><p>在方法区会回收效率比较低</p></li><li><p><em>垃圾回收包含两部分</em></p><ul><li><p><em>废弃的常量</em></p><ul><li>常量池中没有任何对象赋予该常量，或者也没有其他地方引用这个字面量，常量池中的其他类，方法，字段的符号引用也与此类似</li></ul></li><li><p><em>无用的类</em>（判断条件）</p><ul><li><p>该类的所有实例都已经被回收，java堆中不存在该类的任何实例</p></li><li><p>加载该类的ClassLoader已经被回收</p></li><li><p>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p><strong>满足这三个条件，表明该类可以被回收，不是必然会被回收</strong></p></li></ul></li></ul></li></ul><h3 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5. 垃圾收集算法"></a>5. 垃圾收集算法</h3><ul><li><p>标记-清除法</p><ul><li>标记出所有的需要回收的对象，在标记完成之后，再进行同一回收</li><li><em>缺点</em><ul><li>效率不高</li><li>会产生大量的不连续的内存碎片，程序运行中需要大内存进行分配时，如果找不到合适大小的内存，将会触发二次回收。</li></ul></li></ul></li><li><p>复制算法</p><ul><li><p>将n内存容量划分大小相等的两块，每次只使用一块，当另一块用完时，将存活对象放到另一块，将该块进行全部清理掉。</p></li><li><p>实现简单，效率高，不考虑内存碎片问题</p></li><li><p>缺点是内存变为原来一半，代价过高</p></li><li><p><em>演变</em></p><ul><li><p>现在的商业型虚拟机进行新生代对象回收时，分配比例一般为8：1</p><ul><li><p>占据8的Eden</p></li><li><p>占据1的Survivor</p></li><li><p>占据1的Survivor</p><p><strong>拿到该两处的存活对象，放入Survivor中，然后进行擦除，如果Survivor放不下，需要依赖其他内存（老年代）进行分配担保，即Survivor如果放不下，会直接存入到老年代中。</strong></p></li></ul></li></ul></li><li><p>如果老年代存活率较高，不适合使用该算法</p></li></ul></li><li><p>标记整理法</p><ul><li>在标记清除的算法基础上，增加了整理工作</li><li>让所有存活的对象都向另一端移动，然后清除掉边界以外的内存</li></ul></li><li><p>分代收集算法</p><ul><li>根据老年代和新生代的特点，进行算法的选择</li><li>新生代，对象死亡率较高，采用复制算法比较合理</li><li>老年代，存活率高，没有额外空间为其担保，一般采用标记-清理或者标记-整理算法。</li></ul></li></ul><h3 id="6-HotSpot的算法实现"><a href="#6-HotSpot的算法实现" class="headerlink" title="6.HotSpot的算法实现"></a>6.HotSpot的算法实现</h3><ul><li>枚举根节点<ul><li>作为GC root的节点在全局性的引用与执行上下文中。</li><li>采用OopMap的数据结构来达成目的，在类加载完成的时候，HotSpot会把对象内什么偏移量上是什么类型的数据计算出来。在JIT编译时，也会在特定的位置记录下栈和寄存器中哪些位置时引用。这样GC扫描时，可以直接扫这些信息</li></ul></li><li>安全点<ul><li>程序执行时，并非在所有地方都能停顿下来开始GC,只有到达安全点，才能暂停</li><li>安全点的选定基本上是以程序‘’是否具有让程序长时间执行的特征“为标准进行选定的</li><li>GC发生时，让所有的线程都跑到安全点再停顿下来<ul><li><strong><em>抢先式中断</em></strong> ，不需要线程的执行代码主动配合，gc发生时，所有线程中断，发现其不在安全点，就恢复其线程，跑到安全点。现在几乎不怎么使用</li><li><strong><em>主动式中断</em></strong>，不对线程直接操作，设定一个标志位，各个线程执行时，主动去轮询这个标志，发现标志为真，就自己中断挂起，轮询标志的地方和安全点是重合的</li></ul></li></ul></li><li>安全区域<ul><li>线程可能处于sleep或者blocked状态，无法响应JVM的中断请求，这时就需要安全区域</li><li>安全区域指在一段代码片段中，引用关系不会发生变化，这个区域的任意地方开始GC都是安全的，可以将安全区域看成安全点的扩展</li><li>在线程要离开安全区域之前，检查系统是否已经完成根节点枚举，如果完成，那线程就继续执行，否则必须等到收到可以安全离开的Safe Region的信号为止</li></ul></li></ul><h3 id="7-垃圾收集器"><a href="#7-垃圾收集器" class="headerlink" title="7.垃圾收集器"></a>7.垃圾收集器</h3><ul><li>Serial收集器<ul><li>是一个单线程收集器，收集期间，必须暂停其他所有线程，直到收集结束</li><li>是虚拟机运行在client下的默认新生代收集器</li><li><em>优点</em><ul><li>简单高效</li><li>没有线程交互的开销</li></ul></li></ul></li><li>ParNew收集器<ul><li>是Serial的多线程版本，控制参数，收集算法，对象分配规则，回收策略和Serial收集器一样</li><li>运行在Server模式下的虚拟机中首选二点新生代收集器</li><li>除了Serial之外，只有该收集器可以和CMS配合使用</li><li>它的出现，使得垃圾收集线程可以和用户线程同时工作</li><li>默认开启的线程数与CPU数目相同</li><li>在单cpu情况下，不一定比Seria收集器好，因为存在线程交互的开销</li></ul></li><li>Parallel Scavenge<ul><li>新生代收集器，使用复制算法，支持并行多线程</li><li>其目标关注点是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU消耗总时间的比值。 = 运行用户代码时间/（运行用户代码时间+垃圾回收时间）</li><li>适合后台运算，被称为“吞吐量优先”收集器</li><li>支持虚拟机的自适应参数配置</li></ul></li><li>Serial Old 收集器<ul><li>是Serial的老年代版本</li><li>单线程收集器</li><li>使用“标记-整理”算法</li><li><em>适用范围</em><ul><li>server<ul><li>与1.5以及之前版本中与Parallel Scavenge 收集器搭配使用</li><li>作为CMS收集器的后备预案</li></ul></li><li>client</li></ul></li></ul></li><li>Parallel Old收集器<ul><li>Parallel Scavenge 收集器的老年代版本</li><li>多线程收集器</li><li>使用标记-整理算法</li><li>在注重吞吐量和CPU资源的场合，优先考虑Parallel scavenge 与 Parallel Old 收集器</li></ul></li><li>CMS收集器<ul><li>一种以获取最短回收停顿时间为目标的收集器</li><li>采用 标记-清楚</li><li><em>步骤</em><ul><li><strong>初始标记</strong>, 标记一下GC roots 能直接关联的对象</li><li><strong>并发标记</strong>,GC Roots进行Tracing的过程</li><li><strong>重新标记</strong>，修正并发标记期间因用户程序继续运转而导致标记变动的那一部分对象的标记记录</li><li><strong>并发清除</strong></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：对象和异常分析</title>
      <link href="/2018/12/30/java-xu-ni-ji-dui-xiang-he-yi-chang-fen-xi/"/>
      <url>/2018/12/30/java-xu-ni-ji-dui-xiang-he-yi-chang-fen-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-HotSpot虚拟机对象"><a href="#1-HotSpot虚拟机对象" class="headerlink" title="1. HotSpot虚拟机对象"></a>1. HotSpot虚拟机对象</h3><h5 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h5><ul><li><strong>遇到一条new指令，首先检查这个指令参数是否在常量池中定位到一个类的符号引用，检查符号代表的类是否被加载，解析和初始化过。如果没有先执行相应的类的加载过程</strong></li><li><strong>虚拟机为对象分配内存</strong><ul><li>内存大小在类加载完成后便可以确定，即是把一块确定大小的内存，从Java堆中划分出来<ul><li>如果java内存是绝对规整的，内存一边，空闲一边，中间是分界点的指示器，那内存分配只是将指针向空闲区挪动对象大小的范围，称为“指针碰撞”。</li><li>如果已使用内存与未使用内存相互交互，虚拟机维护一个列表，记录哪一块内存是可用的，从列表中寻找大小合适的空间划给对象，并更新列表。称为“空闲列表”</li><li>选择哪种方式由java堆是否规整决定，而java堆是否规整又由采用的垃圾回收器是否带有压缩整理而决定</li></ul></li><li>并发情况下不是线程安全的<ul><li>解决方案一：对分配内存空间的动作进行同步处理</li><li>解决方案二：把内存分配的动作按照线程划分在不同的空间进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲。</li></ul></li><li>内存分配完成过后，虚拟机将分配的内存初始化为零值</li><li>将类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，存放到对象的对象头之中。</li><li>对象创建完成之后，紧接着将会执行init方法进行初始化。</li></ul></li></ul><h5 id="1-2-对象的内存布局"><a href="#1-2-对象的内存布局" class="headerlink" title="1.2 对象的内存布局"></a>1.2 对象的内存布局</h5><ul><li><strong>在内存中的布局可分为三部分</strong><ul><li><em>对象头</em><ul><li>第一部分：存储对象自身的运行时数据，如哈希码，gc分代年龄，锁状态标志，线程持有的锁，偏向线程ID,偏向时间戳等，对象头信息是与对象自身定义的数据无关的额外存储成本</li><li>第二部分：类型指针，即对象指向它的类元数据的指针，通过该指针，确定对象是哪个类的实例。查找对象的元数据信息不一定要经过对象本身。如果是个java数组，对象头中还必须有一块用于记录数组长度的数据。</li></ul></li><li><em>示例数据</em><ul><li>是对象真正存储的有效信息，存储顺序会受到虚拟机分配策略参数和字段在java源码中定义的顺序的影响。</li><li>相同宽度的字段总是分配到一起，在该基础下，父类的变量出现在子类的变量之前。</li></ul></li><li><em>对齐填充</em><ul><li>并不是必然存在的</li><li>起占位符作用，对象的大小必须为8字节的整倍数，当对象实例数据没有补齐时，就需要对齐填充来补全</li></ul></li></ul></li></ul><h5 id="1-3-对象的访问定位"><a href="#1-3-对象的访问定位" class="headerlink" title="1.3 对象的访问定位"></a>1.3 对象的访问定位</h5><ul><li><strong>java通过操作栈上的reference数据，来操作堆上的具体对象</strong></li><li><strong>指向对象的引用，可以分为两种方式</strong><ul><li><em>使用句柄</em><ul><li>java堆会划分出一块内存，来作为句柄池，reference存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li><li>优势在于，对象移动时，只会改变句柄中的实例数据指针，而reference本身不需要修改。</li></ul></li><li><em>直接指针</em><ul><li>java堆对象布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的就是直接的对象地址</li><li>优势在于，速度更快，节省了一次指针定位的开销。</li></ul></li></ul></li></ul><h3 id="2-异常分析"><a href="#2-异常分析" class="headerlink" title="2. 异常分析"></a>2. 异常分析</h3><h5 id="2-1-Java堆异常"><a href="#2-1-Java堆异常" class="headerlink" title="2.1 Java堆异常"></a>2.1 Java堆异常</h5><p>​        区分是<strong>内存泄漏</strong>，还是<strong>内存溢出</strong></p><h5 id="2-2-虚拟机栈和本地方法栈溢出"><a href="#2-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.2 虚拟机栈和本地方法栈溢出"></a>2.2 虚拟机栈和本地方法栈溢出</h5><ul><li>线程请求的栈深度大于虚拟机所允许的最大深度，抛出stackOverFlow异常</li><li>虚拟机在扩展栈时，无法申请到足够的内存空间，导致OutOfMemory异常</li><li>在单线程下，无论时栈帧太大，还是虚拟机的容量太小，当内存无法分配时，虚拟机抛出的都是StackOverFlowError异常</li><li>为每个线程的栈分配的内存越大，反而容易产生内存溢出<ul><li>操作系统分配给进程的内存有限，减去方法去和java堆，再减去程序计数器，其余由虚拟机栈和本地方法栈瓜分，每个线程分配的栈容量越大，可建的线程数量会减小，再建时，会将剩下的内存耗尽。</li><li>如果建立太多线程导致内存溢出，可以考虑减少最大堆和减少栈容量来换取更多线程，即通过减少内存的手段来解决内存溢出的问题。</li></ul></li></ul><h5 id="2-3-方法区和运行时常量池溢出"><a href="#2-3-方法区和运行时常量池溢出" class="headerlink" title="2.3 方法区和运行时常量池溢出"></a>2.3 方法区和运行时常量池溢出</h5><ul><li>常见的内存溢出异常</li><li>动态期间生成大量Class的应用中，需要特别注意类的回收状况</li></ul><h5 id="2-4-本地直接内存溢出"><a href="#2-4-本地直接内存溢出" class="headerlink" title="2.4 本地直接内存溢出"></a>2.4 本地直接内存溢出</h5><ul><li>DirectMemory导致的内存溢出，一个明显的特征是Head Dump 文件不会看见明显的异常，如果发现OOM很小，代码中又用了NIO，可以考虑下这方面的原因。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：内存区域</title>
      <link href="/2018/12/21/java-xu-ni-ji-nei-cun-qu-yu/"/>
      <url>/2018/12/21/java-xu-ni-ji-nei-cun-qu-yu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​            Java虚拟机在执行java程序时，会将所管理的内存划分为不同的数据区域，大致如下：</p><p>​        <img src="/2018/12/21/java-xu-ni-ji-nei-cun-qu-yu/1570861077915.png" alt="1570861077915"></p><p>​            其中<strong>方法区</strong>和<strong>堆</strong>属于线程共享，<strong>虚拟机栈、本地方法栈和程序计数器</strong>属于线程隔离。</p><h3 id="2-区域介绍"><a href="#2-区域介绍" class="headerlink" title="2. 区域介绍"></a>2. 区域介绍</h3><h5 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h5><ul><li><p>可以看作是当前线程所执行的字节码的行号指示器</p></li><li><p>java虚拟机的多线程，实质上是线程轮流切换并分配处理器的执行时间的方式来实现的。在任意时刻，只有一个线程在执行其中的指令。确保线程切换后工作的正常执行，每个线程拥有独立的程序计数器，属于线程私有。</p></li><li><p>若执行Java方法，记录字节码指令的地址，Native方法，计数器值为空。</p></li><li><p>唯一一个没有规定任何OutMemoryError情况的区域。</p></li></ul><h5 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h5><ul><li>属于线程私有，生命周期与线程相同</li><li>用于描述Java方法执行的内存模型</li><li>每个方法在执行时，会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息</li><li>一个方法的完成就是一个栈帧在虚拟机栈中的进栈出栈过程</li><li>局部变量表<ul><li>存放编译器可知的各种基本数据类型</li><li>对象引用类型</li><li>不是对象本身，可能是一个指向对象起始地址的引用指针，或者是指向一个代表对象的句柄，或者其他与此对象相关的位置</li><li>long和double会占用两个字节，其余的只占用一个</li><li>所需的内存空间在编译期间完成分配，进入一个方法时，帧中的大小已经固定，运行期间不会改变</li></ul></li><li>两种异常<ul><li>线程请求的栈的深度大于虚拟机所允许的深度，会抛出StackOverFlow异常</li><li>如果虚拟机栈可以扩展，但扩展时没有足够的内存，会抛出OutOfMemoryError</li></ul></li></ul><h5 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h5><ul><li>与虚拟机栈发挥的作用类似，但是虚拟机栈为java方法服务，本地方法栈为Native方法服务</li><li>虚拟机对于使用的语言，使用方式，和数据结构没有做强制规定，具体的虚拟机可以自由实现</li><li>会抛出两种异常<ul><li>StackOverFlowError异常</li><li>OutofMemoryError异常</li></ul></li></ul><h5 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h5><ul><li>Java虚拟机所管理的内存中最大的一块</li><li>是被所有线程共享的一块内存区域，在虚拟机启动时创建</li><li>内存的唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配内存，详细描述是，所有的对象实例以及数组都要在堆上分配实例</li><li>Java堆是 垃圾收集器的主要区域，即GC堆</li><li>结构<ul><li>新生代<ul><li>Eden</li><li>From survivor</li><li>To survivor</li></ul></li><li>老年代</li></ul></li><li>从内存角度来看，堆中可能划分出多个线程私有的分配缓冲区，划分的目的是更好的分配内存或者划分内存</li><li>java堆可以在物理上不连续的内存空间中，只要逻辑连续即可</li><li>通过-Xms  和-Xmx控制</li><li>堆中没有内存完成实例分配，并且无法扩展时，会抛出OutOfMemoryError异常</li></ul><h5 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h5><ul><li>和java堆一样，都是线程共享区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据</li><li>虚拟机规范，描述方法区为堆的一个逻辑部分，但自身又称为非堆，目的是和java堆区分开，或者被称为“永久代”。</li><li>不需要连续的内存，可以选择固定大小，并且可以扩展，还可以选择不实现垃圾回收。</li><li>这个区域的内存回收目标主要是针对常量池的回收和对类的卸载</li><li>当方法区无法满足内存分配需求时，将会抛出OutOfMemory异常</li></ul><h3 id="3-其他区域"><a href="#3-其他区域" class="headerlink" title="3. 其他区域"></a>3. 其他区域</h3><h5 id="3-1-运行时常量池"><a href="#3-1-运行时常量池" class="headerlink" title="3.1 运行时常量池"></a>3.1 运行时常量池</h5><ul><li>是方法区一部分，用于存放编译期间生成的各种字面量和符号的引用。这部分内容将会在类加载后进入方法区的运行时常量池中存放</li><li>虚拟机规范没有做细节的要求，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中</li><li>常量池具有动态性，并非一定产生于编译器，运行期间也可能将新的常量存放于池中。</li><li>当常量池无法再申请到内存时，会抛出OutOfMemoryError异常</li></ul><h5 id="3-2-直接内存"><a href="#3-2-直接内存" class="headerlink" title="3.2 直接内存"></a>3.2 直接内存</h5><ul><li>不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域</li><li>这部分内存被频繁使用，可能导致OutOfMemory的异常出现</li><li>不会受java堆的限制，但会受到本机内存的限制</li><li>设置时，忘了设置直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展出现OutOfMemoryError异常</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql：深入之分区</title>
      <link href="/2018/12/15/mysql-shen-ru-zhi-fen-qu/"/>
      <url>/2018/12/15/mysql-shen-ru-zhi-fen-qu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>  日常开发中经常会遇到数据库的一些大表，即单表数据存储可能是百万级甚至千万级并且字段非常多，由于表数据的庞大，会导致在数据检索和变更方面的效率很低，如果SQL复杂，级联表众多，其运行性能会变的非常糟糕。使得数据库在高并发情况下成为系统的性能瓶颈。一定程度的分区分表，甚至在分布式情况下的分库等，能有效提升数据库的效率，但凡事均有度，分区分表过多，会造成内存占用升高，以及主从之间数据的一致性问题等等，怎样分区分表，分多少合适，还是要基于现实的业务情况进行选择处理。</p><h3 id="2-分区"><a href="#2-分区" class="headerlink" title="2.分区"></a>2.分区</h3><p>  分区允许通过设置需要的规则在文件系统中分布存储单个表的各个部分。实际上就是表的不同部分作为单独的表存储在不同的位置，Mysql5.1引入的，是一种简单的<strong>水平拆分</strong>，在建表时加上分区参数，对应用是透明的，无需代码的修改。分区本质上是将数据底层的存储块变多，在数据库层面依旧是一张表。</p><p>  目前的mysql8.0中，唯一支持分区的存储引擎是InnoDB和NDB。分区不能与不支持分区的存储引擎一起使用，这些引擎包括MyISAM、MERGE、CSV和FEDERATED存储引擎。</p><p>  分区可以分为两种：<strong>水平分区</strong>和<strong>垂直分区</strong></p><ul><li>水平分区，通常是对表的行进行分区，将不同的行数据进行切割，但表中定义的列在每个数据集中都能找到，只是根据规则将不同的行数据存储在不同的存储块中。</li><li>垂直分区，通过对表的垂直划分来减少目标表的宽度，使得特定的列被划分到特定的分区，每个分区都包含了该列所对应的所有的行</li></ul><p><strong>分区的本质是单表数据在物理层存储的改变，目前mysql还不支持垂直分区，网上大多数将垂直分区和垂直分表混为一谈。</strong></p><p>  <strong>水平分区的四大类型</strong></p><ul><li>范围分区（Range）</li><li>列表分区（List）</li><li>哈希分区（Hash）</li><li>Key分区<h5 id="2-1-Range分区"><a href="#2-1-Range分区" class="headerlink" title="2.1 Range分区"></a>2.1 Range分区</h5>   把一个连续的区间进行划分，把多行分配给分区，常见的字段为自增的主键ID,或者是时间等，基于分区的列最好是整型。</li></ul><pre><code>CREATE TABLE `sql_range` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY RANGE (id)(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN (30),    PARTITION p4 VALUES LESS THAN (40),    PARTITION p5 VALUES LESS THAN (MAXVALUE))-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- range添加新分区alter table &lt;table&gt; add partition(partition p4 values less than MAXVALUE);-- range重新分区ALTER TABLE user REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES LESS THAN MAXVALUE);</code></pre><p><strong><em>注意</em></strong>：</p><ul><li>按照时间范围分区时，转换函数最好使用UNIX_TIMESTAMP 而不是TIMESTAMP</li><li>对于null值，Range分区会将其作为最小分区值存储<h5 id="2-2-List分区"><a href="#2-2-List分区" class="headerlink" title="2.2 List分区"></a>2.2 List分区</h5>  类似于Range分区，但区别在于List分区是一个枚举值列表的集合，而非区间，建议分区为非null列，否则插入null，而集合中不包含，则会报错。另外，List分区只支持整型。</li></ul><pre><code>CREATE TABLE `sql_list` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY LIST (id)(    PARTITION p1 VALUES IN (1,3,5),    PARTITION p2 VALUES IN  ('a','b'))会报错：VALUES value for partition 'p2' must have type INT-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- list添加新分区alter table &lt;table&gt; add partition(partition p4 values in (25,26,28));-- list重新分区ALTER TABLE &lt;table&gt; REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES in (1,2,3,4,5));</code></pre><h5 id="2-3-Hash分区"><a href="#2-3-Hash分区" class="headerlink" title="2.3 Hash分区"></a>2.3 Hash分区</h5><p>  对于一些表，是没有连续的字段或者集合性质的可以用来明显分区的特征字段，但表数据又非常庞大，为了将这些数据分散存储，mysql提供了hash分区，基于给定的分区个数，将数据分配到不同分区，但只针对于整数hash，非整数类型数据需要表达式转换，复杂表达式可能造成性能问题。</p><p>hash分区可以细分为：<strong><em>hash</em></strong>分区和<strong><em>线性hash</em></strong>分区，语法区别在于 partition by linear hash.</p><ul><li>Hash分区，是通过MOD函数取模的方式可以让数据非常平均的分布在每一分区，但由于分区在创建时已经固定，新增和收缩分区，数据的迁移比较大。</li><li>线性Hash分区，优点在于增加，删除，合并和拆分分区变的快捷，有利于处理大量的数据的表，缺点在于数据分布可能不太均匀。</li></ul><p>  hash分区示例代码如下：</p><pre><code>CREATE TABLE `sql_hash` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY HASH (id)PARTITIONS 4;//不指定PARTITIONS 4子句时，默认分区为1-- hash重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-4-Key分区"><a href="#2-4-Key分区" class="headerlink" title="2.4 Key分区"></a>2.4 Key分区</h5><p>  key分区类似于Hash分区，但区别在于以下四点：</p><ul><li><p>KEY分区允许多列，Hash只允许一列。</p></li><li><p>如果有主键或唯一键，key分区可不指定，默认是主键或唯一键。如果没有必须显示指定。</p></li><li><p>KEY分区必须基于列，而不是基于列的表达式</p></li><li><p>Hash的算法是MOD函数，而Key是MD5</p></li></ul><pre><code>CREATE TABLE `sql_key` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY KEY (id)PARTITIONS 4;    -- key重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-5-子分区"><a href="#2-5-子分区" class="headerlink" title="2.5 子分区"></a>2.5 子分区</h5><p>  子分区是对分区表中的每个分区再进行分割，又称复合分区，支持对range和list进行子分区，子分区可以采用hash分区或者key分区。复合分区用于保存大量的数据记录。<br>  示例代码如下：</p><pre><code>CREATE TABLE custom(    id INT,    NAME VARCHAR(20))PARTITION BY RANGE(id)SUBPARTITION BY HASH(id) SUBPARTITIONS 2(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN MAXVALUE)# 指明了子分区名CREATE TABLE seller(    id INT,    NAME VARCHAR(50)) PARTITION BY RANGE(id)SUBPARTITION BY HASH(id)(    PARTITION p1 VALUES LESS THAN (10)(SUBPARTITION s1, SUBPARTITION s2, SUBPARTITION s3),    PARTITION p2 VALUES LESS THAN (20)(SUBPARTITION s4, SUBPARTITION s5, SUBPARTITION s6),    PARTITION p3 VALUES LESS THAN MAXVALUE(SUBPARTITION s7, SUBPARTITION s8, SUBPARTITION s9))--子分区添加新分区，系统自动为子分区命名alter table &lt;table&gt; add partition(partition p3 values less than MAXVALUE);</code></pre><h3 id="3-分区表"><a href="#3-分区表" class="headerlink" title="3.分区表"></a>3.分区表</h3><h5 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h5><p>  普通表进行分区之后就被称为分区表，分区表是由多个相关的底层表（存储块）来实现的，这些底层表也是由句柄对象表示，所以我们可以直接访问各个分区，管理分区的各个底层表和普通表对于存储引擎来说是一样的，分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储角度来看没有区别，存储引擎无需知道该表是普通表还是分区表。</p><p><img src="/2018/12/15/mysql-shen-ru-zhi-fen-qu/1566879182129.png" alt=""></p><h5 id="3-2-操作分析"><a href="#3-2-操作分析" class="headerlink" title="3.2 操作分析"></a>3.2 操作分析</h5><ul><li>select：查询分区表时，分区层先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</li><li>insert：写入分区表时，分区层先打开并锁住所有的底层表，确定哪个分区接受这条记录，再将记录写入对应的底层</li><li>delete: 删除数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，并进行记录删除</li><li>uodate: 更新数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，取出更新，再确定数据该放到哪个分区，对底层表进行写操作，并删除原分区表的旧数据。</li></ul><p><strong>注意</strong>：如果存储引擎能够自己实现行级锁，如Innodb，则会在分区层释放对应的表锁，这个加锁和解锁的过程与普通Innodb上的查询类似。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><h5 id="4-1-分区的注意事项"><a href="#4-1-分区的注意事项" class="headerlink" title="4.1 分区的注意事项"></a>4.1 分区的注意事项</h5><ul><li><p>primary key  和unique key必须包含在分区key的一部分，否则在创建primary key 和unique index时会报错</p></li><li><p>范围分区添加分区只能在最大值后面追加分区</p></li><li><p>所有分区的engine必须一样</p></li><li><p>范围分区字段：integer，数值表达式，日期列，日期函数表达式（如year(), to_days(), to_seconds(), unix_timestamp()）</p></li><li><p>分区字段尽量避免null值，null值对于range分区，会放置到最左边的分区，对于list分区，必须在集合中加入null，对于key和hash分区，都会将null返回为0</p></li><li><p>一个表最多只能有1024个分区</p></li><li><p>分区表无法使用外键约束</p><h5 id="4-2-分区的优点"><a href="#4-2-分区的优点" class="headerlink" title="4.2 分区的优点"></a>4.2 分区的优点</h5></li><li><p>只获取表的热点数据，其他都是历史数据</p></li><li><p>分区表更容易进行维护，可以针对单个分区删除数据，也可以新增分区进行数据的插入，还可以对一个独立的分区进行优化、检查和修复等操作</p></li><li><p>部分查询能够从查询条件确定只落到少数分区上，速度比较快</p></li><li><p>分区表的数据可以分布到不同的物理设备上，从而高效利用多个硬件设备</p></li><li><p>可以使用分区表避免某些特殊瓶颈，如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</p></li><li><p>可以备份和恢复单个分区</p></li><li><p>优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时，涉及聚合函数是，可以在分区上进行处理，最终只需要汇总所有分区的得到的结果</p><h5 id="4-3-分区与分表的关系"><a href="#4-3-分区与分表的关系" class="headerlink" title="4.3 分区与分表的关系"></a>4.3 分区与分表的关系</h5></li><li><p>都能提高mysql的性能，在高并发状态下有一个良好的表现</p></li><li><p>分表和分区不矛盾，可以相互配合，对于需要大量访问，并且数据比较多的表，可以采用分区加分表的方式，访问量不大，但数据很多的表，可以仅采用分区的方式。</p></li><li><p>分表稍微复杂，需要手动创建子表，读写时需要计算子表名。</p></li><li><p>表分区相对于分表，操作方便，不需要创建子表</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql：深入之分表</title>
      <link href="/2018/12/08/mysql-shen-ru-zhi-fen-biao/"/>
      <url>/2018/12/08/mysql-shen-ru-zhi-fen-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  mysql中存在一种机制是表锁定（myisam存储引擎）和行锁定（innodb存储引擎），对于一行数据或一张表，同时只能有一条sql进行操作，其他针对该行或该表的执行sql需要进行排队，在高并发情况下，请求执行的sql如果出现骤增，整个系统的性能将会卡在sql的执行效率上。对一些数据庞大的表，可以采取分表策略，将执行的sql进行均匀分布，减少sql等候执行队列的长度，提高数据库的吞吐量。</p><h3 id="2-分表"><a href="#2-分表" class="headerlink" title="2.分表"></a>2.分表</h3><p> 分表依据不同的业务情况可以分为两种切分方式：<strong>垂直切分</strong>和<strong>水平切分</strong>。</p><h5 id="2-1-垂直切分"><a href="#2-1-垂直切分" class="headerlink" title="2.1 垂直切分"></a>2.1 垂直切分</h5><p> 垂直切分的场景是，表中属性很多，但是基本上是核心的几个属性的操作频率很高，其他的属性平时不怎么需要获取到。</p><ul><li>将长度较短，访问频率高的属性可以放到一个表中，暂且称为主表。</li><li>将长度较短，访问频率低的属性放到一个表中，暂且称为扩展表。</li><li>也可以将经常一起访问的属性，放置到同一表中，具体视业务而定。</li></ul><p> 数据库有自身的内存buffer，会将磁盘上的数据load到内存buffer中，其单位是以row为单位的，在内存有限的情况下，缓存越短的row，就能缓存更多的数据，提高缓存命中率，减少磁盘访问，有效提高操作效率。</p><p><strong>缺点：</strong></p><ul><li>会造成一定量的冗余列</li><li>查询所有数据需要进行join操作，如果进行了分库，表在不同库或服务器，将会增加访问数据库次数。<h5 id="2-2-水平切分"><a href="#2-2-水平切分" class="headerlink" title="2.2 水平切分"></a>2.2 水平切分</h5> 水平切分场景是，单表的数据量很大，执行多条sql会造成排队较长，整体的执行效率降低。这时需要将表中行数据按照一定的规则进行进行划分，创建多个子表，<strong>分表不同于分区，mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对应三个文件，.MYD数据文件，。MYI索引文件，。FRM表结构文件</strong>。这样就能保证sql的执行是在不同的表中，读取的时候从各自的表中进行读取，降低了单表的sql执行的排队长度。</li></ul><p><strong>缺点：</strong></p><ul><li>当分配规则确定后，打破这条规则很麻烦，可能会导致相同的数据，因为规则不同而出现在不同的表中。</li><li>同库不同表数据需要进行union操作</li><li>不同库不同表将会增加数据库访问次数</li></ul><p><strong>利用merge存储引擎分表</strong><br> 把已有的大数据量的表进行切分的确非常困难，可能涉及到要修改代码中大量的sql，利用merge存储引擎分表将会在数据库层面进行表的切分，而对外程序的中依旧是该主表，不需要代码中sql的修改，但仅限于MyISAM存储引擎，采用InnoDB引擎的表不适用。<br> 具体代码如下：</p><pre><code># 分表1CREATE TABLE user_1(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50)) ENGINE=MYISAM#分表2CREATE TABLE user_2(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50)) ENGINE=MYISAM# merge表挂载分表CREATE TABLE USER(    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(50))  ENGINE=MERGE UNION=(user_1,user_2) INSERT_METHOD=LAST;</code></pre><ul><li><strong>ENGINE=MERGE</strong> 指明merge表使用MERGE引擎</li><li><strong>UNION=(user_1,user_2)</strong> 指明merge表挂载了哪些表</li></ul><pre><code>#该sql用于移除user_2的挂载ALTER TABLE USER ENGINE=MERGE UNION=(user_1) INSERT_METHOD=LAST </code></pre><ul><li><strong>INSERT_METHOD=LAST</strong> 指明输入插入的方式，0表示不允许数据插入，<strong>FIRST</strong>将会插入UNION的第一个分表中，<strong>LAST</strong>将会插入UNION的最后一个分表中</li><li>如上sql所示，merger表和其他的分表结构必须保持一致，包括同样的索引。</li><li>一个merge表不能在整个表上维持unique约束，若merge存在重复主键，按主键查询，获取一条记录便会停止。后续重复主键的数据将无法插入，即只保证挂载之后主键的唯一性。</li><li>若分表存在自增主键，merge表新数据的插入自增将会从分表中最大的主键开始自增。即user_1最大自增主键为10，user_2为20，则merge表数据的主键将会从21开始。</li></ul><p><strong>推荐：利用merge存储引擎分表，可以先有一张merge表，且只挂载一个分表，当分表的数据到达一定的数量级之后，再建立新的分表进行挂载，数据将会插入到新分表中</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql：深入分库</title>
      <link href="/2018/12/02/mysql-shen-ru-zhi-fen-ku/"/>
      <url>/2018/12/02/mysql-shen-ru-zhi-fen-ku/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  大多数的数据库设计往往是一台主库负责数据的写入，多台从库同步主库数据仅提供读数据，但随着业务的增长，主库的写压力会与日俱增，这时往往通过分库+分布式的架构来缓解来自业务数据增长带来的压力，但同时也会引发数据的一致性和事务等诸多问题。</p><h3 id="2-分库"><a href="#2-分库" class="headerlink" title="2.分库"></a>2.分库</h3><p>  数据库的拆分同样也可以分为两种<strong>垂直拆分</strong>和<strong>水平拆分</strong><br>  <strong>垂直拆分</strong>是分库的首选，其分库方式较为简单，因其的依据在于业务的整体架构，可以将独立不相关的业务模块的表迁移到不同的库中，要求数据的增长速度比较平稳。<br>  <strong>水平拆分</strong>复杂度较高，往往会涉及<strong>分表</strong>。<br>  拆分思路：</p><ul><li>按算法对应<br>  将数据的主键按照固定的算法进行分类，放置到不同的数据库中，实现较为方便，但扩展性较差，后续节点收缩或算法变动会造成很大的数据集迁移。</li><li>按索引映射表对应<br>  即建立数据主键与所在数据库的关系表，每次数据请求先去该表查取，再到具体的数据库获取数据，优势在于伸缩性，新的数据进来，只需要放入合适的库中，在关系表上添加对应的记录便可。缺点在于会增加数据库的访问次数。<h3 id="3-分库面临的问题"><a href="#3-分库面临的问题" class="headerlink" title="3.分库面临的问题"></a>3.分库面临的问题</h3></li><li>不能跨库关联查询<br>  当关联数据分布在不同的数据库中或者获取级联数据时不能进行join操作，解决思路要么数据两边均存储一份（全局表），采用空间换时间，要么只能代码层查询之后再进行聚合，牺牲部分性能</li><li>不能保证数据的一致性<br>  跨库的数据没有外键约束，也没有事务保证。</li><li>所有查询必须提供数据库线索<br>  分库之后的数据可能存在于不同库中，每次数据的操作都需要先定位库的位置。</li><li>自增ID<br>  有时跨库数据可能依赖于数据主键，采取自增主键可能导致不同库的数据录入时主键信息不一致，可以采取第三方表数据生成自增主键为标准，作为相关数据的主键，保证自增的一致性。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：泛型</title>
      <link href="/2018/11/24/java-fan-xing/"/>
      <url>/2018/11/24/java-fan-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        泛型的主要目的之一就是来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性，基本类型无法作为类型参数。</p><h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h3><h5 id="2-1-元组概念"><a href="#2-1-元组概念" class="headerlink" title="2.1 元组概念"></a>2.1 元组概念</h5><p>​        将一组对象打包直接存储在其中一个单一对象中。</p><pre><code>//可被继承 进行扩展public class TwoTuple&lt;A, B&gt;{    public final A first;    public final B second;    public TwoTuple(A a, B b){       first = a;       second = b;   }}public class ThreeTuple&lt;A, B, C&gt; extends TwoTuple&lt;A, B&gt;{    public final C three;    public ThreeTuple(A a, B b, C c){       super(a, b)       three = c;   }    }//元组测试  存放多个返回对象public class Tupletest{    public static TwoTuple&lt;String, Integer&gt; f(){       return new TwoTuple&lt;String, Integer&gt;("hello", 1024);       }}</code></pre><h5 id="2-2-泛型接口"><a href="#2-2-泛型接口" class="headerlink" title="2.2 泛型接口"></a>2.2 泛型接口</h5><pre><code>pulic interface Gernerator&lt;T&gt;{    T next();}public class Coffee implements Generator&lt;String&gt;{    @Override    public String next(){   }}参数化的接口确保next（）的返回值是参数的类型。</code></pre><h5 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h5><p>​        泛型方法使得方法独立于类而产生变化。</p><pre><code>public class GeneratorMethods{    public &lt;T&gt; void f(T x){       sout(x.getClass().getName());   }}</code></pre><p>​        使用泛型类时必须指明参数类型，而泛型方法不必指出， 编译器会进行类型参数推断。 类型参数判断若传入是基本类型，系统会自行进行打包处理。</p><p>​        类型判断只对赋值操作有效，若将泛型方法调用的结果作为参数进行传递，编译器不会类型推断。因为编译器认为：泛型方法调用后，其返回值被赋给了Object类型的变量。</p><pre><code>static void f(Map&lt;People, List&lt;? extends Pet&gt;&gt; petPeople){}f(New.map());</code></pre><p>​        显示进行说明 可以解决上述问题，即泛型显示说明</p><pre><code>f(Map&lt;People, List&lt;Pet&gt; petPeople&gt;){}f(New.&lt;Person.List&lt;Pet&gt;&gt;map());</code></pre><p>​        静态方法</p><pre><code>public static &lt;T&gt; T getSelf(T a){   return a;}</code></pre><h5 id="2-4-泛型的限制"><a href="#2-4-泛型的限制" class="headerlink" title="2.4 泛型的限制"></a>2.4 泛型的限制</h5><ul><li>不能实例化类型变量</li></ul><pre><code>T objg = new T(); ERROR//可以利用反射进行public class GenerateObj&lt;T&gt;(){    private T obj;    public GenerateObj(Class&lt;T&gt; c){       try{       obj = c.newInstance();       }catch(Exception e){           e.printStackTrance();       }   }}test:GenerateObj&lt;String&gt; obj = new GenerateObj&lt;&gt;(String.class);</code></pre><ul><li>不能实例化泛型数据</li></ul><pre><code>T[] arr = new T[3]; ERROR//A.可以先创建Object类型的数组，然后获取时转换为T类型的数组。public class GenerateArray{    private Object[] arr;    public GenerateArray(int n){       this.arr = new object[n];   }    public void set(int i, T o){       arr[i] = o;   }    public T get(int i){       return (T)this,arr[i];   }}//B.利用反射机制public generateArray(Class&lt;T&gt; type, int n){    arr = (T[])Array.newInstance(type, n);}</code></pre><ul><li>不能在<strong>泛型类</strong>的静态上下文使用类型变量</li></ul><pre><code>public class Foo&lt;T&gt;{    private static T t;   public static T get(){     //error       return T;   }}</code></pre><ul><li>不能抛出或者捕获泛型类的实例</li></ul><pre><code>public class Problem&lt;T&gt; extends Exception{  //error}//扩展Throwable也是不合法的public class Foo {    public static &lt;T extends Throwable&gt; void doWork(){       try{       }catch(T t){   //error       }   }}//但在异常规范中使用泛型变量是允许的public class Foo{    public static &lt;T extends Throwable&gt; void doWork(T t) throws T{       try{       }catch(Throwable realCause){           throw t;       }   }}</code></pre><h5 id="2-5-类型变量的规定"><a href="#2-5-类型变量的规定" class="headerlink" title="2.5 类型变量的规定"></a>2.5 类型变量的规定</h5><p>​        <strong>java类库中，常用E表示集合的元素类型，K和V分别表示关键字和值的类型，T（U, S）表示任意类型。</strong></p><ul><li><p>被定义的泛型类作为接收方，也需要对传入的类型变量T的值做一定的限制和约束，如必须是某个超类的子类，或实现某个接口</p></li><li><p>对于实现接口，和继承某个父类。统一使用extends。</p></li><li><p>限定类型之间使用“&amp;”进行分割。</p></li><li><p>如果有类有接口，类名放于前，且至多有一个，接口不限</p><pre><code>public class Foo&lt;T extends SuperClass&amp;Comparable&gt;{}</code></pre></li></ul><h5 id="2-6-泛型的继承关系"><a href="#2-6-泛型的继承关系" class="headerlink" title="2.6 泛型的继承关系"></a>2.6 泛型的继承关系</h5><ul><li>类名相同，但类型变量T不同的两个泛型类没有什么联系（即使Employee 是Manager的父类）。（ArrayList<manager> 和 ArrayList<employee>）</employee></manager></li><li>类型变量T相同，同是本来就是父子关系的两个类，作为泛型类依然保持继承关系。（ArrayList<employee> 和 List<employee>）</employee></employee></li><li>某个类的原始类型，和其对应的泛型类可以看做由“继承关系” (ArrayList 和ArrayList<employee>)</employee></li></ul><h5 id="2-7-统配符的使用"><a href="#2-7-统配符的使用" class="headerlink" title="2.7 统配符的使用"></a>2.7 统配符的使用</h5><ul><li><p>向上造型一个泛型对象的引用（上界通配符）</p><pre><code>List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();List&lt;? extends Fruits&gt; fruits = apples;</code></pre><p>​        <strong>上界通配符，List&lt;? extends Fruits&gt; 是 List<fruits>和List<apple>的基类,一个能放水果以及一切都是水果派生类的盘子。</apple></fruits></strong></p></li><li><p><strong>下界通配符，Plate&lt;? super Fruit&gt; 是 Plate<fruit>的基类，但不是Plate<apple>的基类。一个能放水果以及一切是水果基类的盘子。Food 是 Fruits的基类。</apple></fruit></strong></p><pre><code>List&lt;? super Fruits&gt; list = new List&lt;Fruit&gt;(new Fruit());</code></pre><p><strong><em>副作用：</em></strong></p><ul><li>上界不能存，只能外取。即&lt;? extends Fruits&gt; 会让set方法失效，但get方法还是有效的。</li><li>原因：编译器只知道容器内是Frutis或者它的子类，但不知道具体的类型，所以标上一个占位符，具体类不清楚，插入时，容器类不清楚是否与之匹配，所以就不允许。  并且读出来的东西，只能以父类进行接收。</li><li>T 代表同一类型，而? 代表不同类型。</li><li>下界不影响存，但只能以object进行接收。</li></ul></li></ul><h5 id="2-8-PECS-原则"><a href="#2-8-PECS-原则" class="headerlink" title="2.8 PECS 原则"></a>2.8 PECS 原则</h5><ul><li><p>频繁往外读取内容的，适合上界Extends。</p></li><li><p>经常往里插入的，适合用下界Super。</p></li><li><p>材料：</p><ul><li>Java是单继承，所有继承的类构成一棵树。假设A和B都在一颗继承树里（否则super，extend这些词没意义）。</li><li>A super B 表示A是B的父类或者祖先，在B的上面。</li><li>A extend B 表示A是B的子类或者子孙，在B下面。</li><li>由于树这个结构上下是不对称的，所以这两种表达区别很大。假设有两个泛型写在了函数定义里，作为函数形参（形参和实参有区别）：<ul><li>参数写成：T&lt;? super B&gt;，对于这个泛型，?代表容器里的元素类型，由于只规定了元素必须是B的超类，导致元素没有明确统一的“根”（除了Object这个必然的根），所以这个泛型你其实无法使用它，对吧，除了把元素强制转成Object。所以，对把参数写成这样形态的函数，你函数体内，只能对这个泛型做<strong>插入操作，而无法读</strong>。</li><li>参数写成： T&lt;? extends B&gt;，由于指定了B为所有元素的“根”，你任何时候都可以安全的用B来使用容器里的元素，但是插入有问题，由于供奉B为祖先的子树有很多，不同子树并不兼容，由于实参可能来自于任何一颗子树，所以你的插入很可能破坏函数实参，所以，对这种写法的形参，<strong>禁止做插入操作，只做读取</strong>。</li></ul></li></ul></li></ul><h5 id="2-9-泛型的命名规范"><a href="#2-9-泛型的命名规范" class="headerlink" title="2.9  泛型的命名规范"></a>2.9  泛型的命名规范</h5><ul><li><strong>E</strong>  :Element 常用在 java collection中，如List<e>,Iterator<e>.</e></e></li><li><strong>K, V</strong>: Key Value 代表Map的键值对</li><li><strong>N</strong>: number 数字</li><li><strong>T</strong> : type 类型</li><li><strong>S, U, V</strong> 和 <strong>T</strong>的用法一样</li></ul><h3 id="3-关于泛型的几点建议（Effective-Java）"><a href="#3-关于泛型的几点建议（Effective-Java）" class="headerlink" title="3.关于泛型的几点建议（Effective Java）"></a>3.关于泛型的几点建议（Effective Java）</h3><ul><li><p>第 23 条：请不要在新代码中使用原生类型</p><ul><li><p>如果使用原生类型，就失去了泛型在安全性和标书性方面的优势，所以尽可能的使用泛型参数，少使用原生类型。List 和List<object>  的区别在于前者逃避了泛型检查，后者则告知了编译器。如果使用List就会失去类型的安全性。所以能使用List<object> 就不使用List,并且List<string> 是 List的子类，但不是List<object>的子类。</object></string></object></object></p></li><li><p>在不确定或者不关心实际的参数的时候，就可以用一个问号代替</p></li><li><p>不要在代码中使用泛型的两个例外</p><ul><li>在类文字中必须使用原生态类型，规范不允许使用参数，List.class, String[].class  都是合法的，List&lt;String.class&gt;和 List&lt;?&gt;.class则不合法。</li><li>泛型信息在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用instance操作符是非法的。用无限制通配符类型替换原生类型，对instanceof操作符的行为不会产生任何影响</li></ul><pre><code>if&lt;o instanceof Set&gt;{    Set&lt;?&gt; m = (Set&lt;?&gt;) o;}</code></pre></li></ul></li><li><p>第 24 条：消除非受检警告</p><ul><li>消除非受检警告，要尽可能的消除每一个非受检警告,每一个警告都有可能抛出ClassCastException异常，使用该注解，最好写上原因。</li><li>SuppressWarnings注解放在return语句是非法的，应该新建一个局部变量进行保存返回值</li></ul><pre><code>@SuppressWarnings("uncheck")T[] result = (T[])Arrays.copeOf(elements, size, a.getClass());</code></pre></li><li><p>第 25 条：列表优先于数组</p><ul><li>数组与泛型相比，是协变的，具体化的。 sub是super的子类型，则sub[] 就是super[]的子类型，但是泛型却是不行的。数组的错误会在运行时才抛出异常，而列表则会进行编译检查。</li><li>泛型在编译时强化它们的类型信息，在运行时丢弃或擦出元素类型信息。擦除就是使用泛型可以与没有使用泛型的代码随意互用</li><li>创建泛型、参数化类型或者类型参数的数组都是非法的。 非法的原因在于它不是类型安全的。</li></ul><pre><code>new List&lt;E&gt;[]  new List&lt;String&gt;[] 和 new E[]举例说明非法的原因：创建一个使用参数化类型List的数组List&lt;String&gt;[] stringlist = new List&lt;String&gt;[1];创建一个使用参数化类型的列表List&lt;Integer&gt; intList = new ArrayList[];由于数组是协变的，所以下面的是成立的。Object[] objects = stringList因而，就可以objects[0] = stringList;但是下面的取值方式，看似是合理的，但是由于存入的是一个Integer参数画的List，所以会将Integer转换成String，这时就会抛出异常String s = stringList[0].get(0);</code></pre></li><li><p>第26条：优先考虑使用泛型</p></li></ul><pre><code>当在使用泛型类型时，进行转换的时候，//标量类型private Object[] elements;E result = (E)elements[size];//数组类型private E[] elements;elements = (E[]) new Object[12];两种方式都可以，但当使用SuppressWarnings注解时禁止数组类型的未受检转换比禁止标量类型的更加危险(2比1更加危险)。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：Java8特性</title>
      <link href="/2018/11/18/java-java8-te-xing/"/>
      <url>/2018/11/18/java-java8-te-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Default-Method-for-Interfaces（接口的default方法）"><a href="#1-Default-Method-for-Interfaces（接口的default方法）" class="headerlink" title="1. Default Method for Interfaces（接口的default方法）"></a>1. Default Method for Interfaces（接口的default方法）</h4><pre><code>public interface Formula {    double calcute(int a);    default double sqrt(int a){        return Math.sqrt(a);    }    public static void main(String[] args) {        Formula formula = new Formula() {            @Override            public double calcute(int a) {                return sqrt(a * 100);            }        };        System.out.println(formula.calcute(100));        System.out.println(formula.sqrt(16));    }}</code></pre><h4 id="2-Lambda-expression-集合排序"><a href="#2-Lambda-expression-集合排序" class="headerlink" title="2.Lambda expression(集合排序)"></a>2.Lambda expression(集合排序)</h4><pre><code>public static void main(String[] args) {        List&lt;Integer&gt; numList = new ArrayList&lt;&gt;();        numList.add(1);        numList.add(3);        numList.add(2);        // #1        Collections.sort(numList, (Integer a, Integer b) -&gt;{            return b.compareTo(a);        });        // #2        Collections.sort(numList, (Integer a, Integer b) -&gt; b.compareTo(a));        // #3        numList.sort((a,  b) -&gt; b.compareTo(a));        System.out.println(numList.toString());    }</code></pre><h4 id="3-Functional-Intefaces-功能性接口的快速实现"><a href="#3-Functional-Intefaces-功能性接口的快速实现" class="headerlink" title="3.Functional Intefaces(功能性接口的快速实现)"></a>3.Functional Intefaces(功能性接口的快速实现)</h4><pre><code>public static void main(String[] args) {        // #1        Converter&lt;String, Integer&gt; convert = (from -&gt; Integer.valueOf(from));        // #2        Converter&lt;String, Integer&gt; convert = Integer::valueof;        // #3        Converter&lt;String, String&gt; convert = Something::startWith;        Integer converted = convert.convert("123");        System.out.println(converted);    }    @FunctionalInterface    interface Converter&lt;F, T&gt;{        T convert(F from);    }    class Something{        String startWith(String s){            return String.valueOf(s.charAt(0));        }    }    //构造函数的使用    class Person{        String name;        public Person(){}        public Person(String name){            this.name = name;        }    }    interface PersonFactory&lt;T extends Person&gt;{        T create(String name);    }    PersonFactory factory = Person::new;    Person person = factory.create("Peter");</code></pre><h4 id="4-Lambda-Scopes-使用范围"><a href="#4-Lambda-Scopes-使用范围" class="headerlink" title="4. Lambda Scopes(使用范围)"></a>4. Lambda Scopes(使用范围)</h4><h6 id="4-1-Accessing-local-variables-接受本地变量"><a href="#4-1-Accessing-local-variables-接受本地变量" class="headerlink" title="4.1 Accessing local variables(接受本地变量)"></a>4.1 Accessing local variables(接受本地变量)</h6><pre><code>final int num = 1Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2);</code></pre><h6 id="4-2-Accessing-fields-and-static-variables-属性和静态属性"><a href="#4-2-Accessing-fields-and-static-variables-属性和静态属性" class="headerlink" title="4.2 Accessing fields and static variables(属性和静态属性)"></a>4.2 Accessing fields and static variables(属性和静态属性)</h6><pre><code>class Lambda4{    static int outerStaticNum;    int outerNum;    void testScopes(){        java8Study.Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; {            outerNum = 23;            return String.valueOf(from);        };        java8Study.Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {            outerStaticNum = 70;            return String.valueOf(from);        };    }}</code></pre><h4 id="5-Built-in-Functional-Interfaces-内置功能接口"><a href="#5-Built-in-Functional-Interfaces-内置功能接口" class="headerlink" title="5. Built-in Functional Interfaces(内置功能接口)"></a>5. Built-in Functional Interfaces(内置功能接口)</h4><h6 id="5-1-Predicates-用于判断boolean值的接口"><a href="#5-1-Predicates-用于判断boolean值的接口" class="headerlink" title="5.1 Predicates(用于判断boolean值的接口)"></a>5.1 Predicates(用于判断boolean值的接口)</h6><pre><code>  Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;        Predicate&lt;Object&gt; nonNull = Objects::nonNull;        Predicate&lt;Object&gt; isNull = Objects ::isNull;        Predicate&lt;String&gt; isEmpty = String::isEmpty;        Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();        boolean t1 =  predicate.test("job");        boolean t2 = predicate.negate().test("job");        String a = null;        boolean t3 = nonNull.test(a);        boolean t4 = isNull.test(a);        System.out.println(t1+" "+t2+" "+t3+" "+t4);        true false false true</code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569555883604.png" alt="1569555883604"></p><h6 id="5-2-Functions-接受一个参数，返回一个结果"><a href="#5-2-Functions-接受一个参数，返回一个结果" class="headerlink" title="5.2 Functions(接受一个参数，返回一个结果)"></a>5.2 Functions(接受一个参数，返回一个结果)</h6><pre><code>    Function&lt;String, Integer&gt; toInteger = Integer::valueOf;    Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);    System.out.println(backToString.apply("123"));        123</code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569556224804.png" alt="1569556224804"></p><h6 id="5-3-Suppliers-产生指定类型结果-不接受参数"><a href="#5-3-Suppliers-产生指定类型结果-不接受参数" class="headerlink" title="5.3 Suppliers(产生指定类型结果,不接受参数)"></a>5.3 Suppliers(产生指定类型结果,不接受参数)</h6><pre><code>        Supplier&lt;Person&gt; personSupplier = Person::new;        Person person = personSupplier.get();</code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569556641067.png" alt="1569556641067"></p><h6 id="5-4-Consumers-指定对输入参数的处理动作"><a href="#5-4-Consumers-指定对输入参数的处理动作" class="headerlink" title="5.4 Consumers(指定对输入参数的处理动作)"></a>5.4 Consumers(指定对输入参数的处理动作)</h6><pre><code>Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println("Hello" + p.name);greeter.accept(new Person("Lee"));</code></pre><h6 id="5-6-Comparators-比较器接口"><a href="#5-6-Comparators-比较器接口" class="headerlink" title="5.6 Comparators(比较器接口)"></a>5.6 Comparators(比较器接口)</h6><pre><code>Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.name.compareTo(p2.name);        Person p1 = new Person("a");        Person p2 = new Person("b");        comparator.compare(p1, p2);        comparator.reversed().compare(p1, p2);</code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569557367186.png" alt="1569557367186"></p><h4 id="6-Optionals-防止空指针异常"><a href="#6-Optionals-防止空指针异常" class="headerlink" title="6.Optionals(防止空指针异常)"></a>6.Optionals(防止空指针异常)</h4><pre><code>Optional&lt;String&gt; optional = Optional.of("bam");optional.isPresent();  //trueoptional.get();  //"bam"optional.orElse("fallback");  //"bam"optional.ifPresent((s) -&gt; System.out.println(s.chartAt(0)));</code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569557923854.png" alt="1569557923854"></p><h4 id="7-Streams"><a href="#7-Streams" class="headerlink" title="7. Streams"></a>7. Streams</h4><h6 id="7-1-Filter-过滤器"><a href="#7-1-Filter-过滤器" class="headerlink" title="7.1 Filter(过滤器)"></a>7.1 Filter(过滤器)</h6><pre><code>stringCollection                .stream()                .filter((s) -&gt; s.startsWith("a"))                .forEach(System.out::println);</code></pre><h6 id="7-2-Sorted"><a href="#7-2-Sorted" class="headerlink" title="7.2 Sorted"></a>7.2 Sorted</h6><p>​        元素会自然排序，除非指定Comparator，并且只是流进行了排序，集合并不会被改变。</p><pre><code>stringCollection                .stream()                .sorted()                .filter((s) -&gt; s.startsWith("a"))                .forEach(System.out::println);</code></pre><h6 id="7-3-Map"><a href="#7-3-Map" class="headerlink" title="7.3 Map"></a>7.3 Map</h6><pre><code> stringCollection                .stream()                .map(String::toUpperCase)                .sorted((a, b) -&gt; a.compareTo(b))                .forEach(System.out :: println);</code></pre><h6 id="7-4-Match"><a href="#7-4-Match" class="headerlink" title="7.4 Match"></a>7.4 Match</h6><pre><code>//是否存在以a开头的元素boolean anyStartWithA =                stringCollection                .stream()                .anyMatch((s) -&gt; s.startsWith("a")); //所有元素是否以a开头                     boolean allStartWithA =                stringCollection                .stream()                .allMatch((a) -&gt; a.startsWith("a"));  //没有以Z开头的                boolean nonStartWithZ =                stringCollection                .stream()                .noneMatch((a) -&gt; a.startsWith("z"));</code></pre><h6 id="7-5-Count"><a href="#7-5-Count" class="headerlink" title="7.5 Count"></a>7.5 Count</h6><pre><code>long startWithB =                stringCollection                .stream()                .filter((s)-&gt;s.startsWith("b"))                .count();</code></pre><h6 id="7-6Reduce"><a href="#7-6Reduce" class="headerlink" title="7.6Reduce"></a>7.6Reduce</h6><pre><code>Optional&lt;String&gt; reduced =                stringCollection                .stream()                .sorted()                .reduce((s1, s2) -&gt; s1 + "#" + s2);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：JDK动态代理</title>
      <link href="/2018/11/10/java-jdk-dong-tai-dai-li/"/>
      <url>/2018/11/10/java-jdk-dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  学习动态代理，可以先了解一下设计模式中的代理模式。<br>  <a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">设计模式–代理模式</a></p><h2 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2.JDK动态代理"></a>2.JDK动态代理</h2><p>  JDK生成类的过程中比较高效，其基于java内部的拦截器和反射机制实现的，应用的前提是目标类要基于统一的接口</p><h4 id="2-1-使用JDK动态代理的五大步骤："><a href="#2-1-使用JDK动态代理的五大步骤：" class="headerlink" title="2.1 使用JDK动态代理的五大步骤："></a>2.1 使用JDK动态代理的五大步骤：</h4><ul><li>实现InvocationHandler接口，重写自己的invoke方法。</li><li>通过Prxoy.getProxyClass获得代理类的Class</li><li>通过ProxyClazz.getConstructor获得代理类的构造函数</li><li>通过代理类的构造函数，将实现的InvocationHandler实例作为参数进行传递，获得代理类</li><li>代理类调用具体的函数方法</li></ul><p><strong><em>代码如下</em></strong></p><pre><code>//被代理类接口public interface UserService {    String getName();}//被代理类实现类public class UserServiceImpl implements UserService{    @Override    public String getName() {        System.out.println("this is Jerry");        return "Jerry";    }}//InvocationJHandler的实现类public class MyInvocationHandler implements InvocationHandler {    private Object target;    public MyInvocationHandler(){    }    public MyInvocationHandler(Object target) {        super();        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            System.out.println("beforeExecute---" + method.getName());            Object result = method.invoke(target, args);            System.out.println("afterExecute---" + method.getName());            return result;    }}//测试类public class MainTest {    public static void main(String[] args) throws Exception {        //1.获取代理类的class        Class clazz = Proxy.getProxyClass(UserService.class.getClassLoader(), UserService.class);        //2.获取代理类的构造函数        Constructor constructor = clazz.getConstructor(InvocationHandler.class);        //3.通过构造函数，拿到代理对象        UserService userService  = (UserService) constructor.newInstance(new MyInvocationHandler(new UserServiceImpl()));        //4.代理对象调用方法        userService.getName();        //Proxy 提供了静态方法，可以一步获得代理类的执行结果，以上的几步可以整合为一个方法        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(                UserService.class.getClassLoader(),                new Class[]{UserService.class},                new MyInvocationHandler(new UserServiceImpl())        );        userServiceProxy.getName();    }}//执行结果beforeExecute---getNamethis is JerryafterExecute---getNamebeforeExecute---getNamethis is JerryafterExecute---getName</code></pre><h4 id="2-2-补充整理："><a href="#2-2-补充整理：" class="headerlink" title="2.2 补充整理："></a>2.2 补充整理：</h4><p>  在动态代理中，InvocationHandler是核心，每一个代理实例都具有一个关联的调用处理程序，当代理对象生成后，还最后由InvocationHandler的invoke()方法调用目标方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：CGLIB</title>
      <link href="/2018/11/04/java-cglib/"/>
      <url>/2018/11/04/java-cglib/</url>
      
        <content type="html"><![CDATA[<h1 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h1><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  CGLIB（Code Generator Library）是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。<br>  CGLIB的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。</p><h2 id="2-CGLIB-实例代码："><a href="#2-CGLIB-实例代码：" class="headerlink" title="2.CGLIB 实例代码："></a>2.CGLIB 实例代码：</h2><pre><code>//被代理类public class User {    public String getUserName(){        System.out.println("this is Tom");        return "Tom";    }}//实现接口public class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println("------beforeExecute");        Object object = methodProxy.invokeSuper(o, objects);        System.out.println("------afterExecute");        return object;    }}//测试类public class CglibTest {    public static void main(String[] args) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(User.class);        enhancer.setCallback(new MyMethodInterceptor());        User userProxy = (User)enhancer.create();        userProxy.getUserName();    }}//结果------beforeExecutethis is Tom------afterExecute</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
