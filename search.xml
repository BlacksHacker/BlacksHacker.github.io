<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx：Keepalived高可用</title>
      <link href="/2021/03/23/nginx-keepalived-gao-ke-yong/"/>
      <url>/2021/03/23/nginx-keepalived-gao-ke-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        nginx通过反向代理实现了后端服务的高可用性，保证了单个服务宕机时，不会影响整体的系统响应。相应的为了保证nginx实现高可用，可以用过keepalived来实现。</p><h3 id="步骤与配置"><a href="#步骤与配置" class="headerlink" title="步骤与配置"></a>步骤与配置</h3><ol><li><p>安装并启动keepalived, 两台服务器都要进行安装。</p><pre class=" language-shell"><code class="language-shell">http://www.keepalived.org/software/keepalived-1.2.18.tar.gz# keepalived安装yum -y install gcc gcc-c++ autoconf automake makeyum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel# 解压安装tar -zxvf keepalived-1.2.18.tar.gz cd  keepalived-1.2.18./configure   --prefix=/usr/local/keepalived/make && make install</code></pre></li><li><p>添加到系统服务</p><pre class=" language-shell"><code class="language-shell">#创建keepalived配置文件目录mkdir /etc/keppalived#拷贝配置文件到/etc/keepalived目录下cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/ #复制keepalived脚本到/etc/init.d/目录cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/#拷贝keepalived脚本到/etc/sysconfig/目录cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/#建立软连接ln -s /usr/local/keepalived/sbin/keepalived  /sbin/# 添加到开机启动chkconfig keepalived on #启动命令service keepalived start#查看服务状况 systemctl status keepalived   </code></pre><ol start="3"><li>安装sendmail服务</li></ol><pre class=" language-shell"><code class="language-shell">yum -y install sendmail*yum -y install mailx</code></pre><p> 启动服务</p><pre><code>service sendmail start#发送邮件测试echo 'mail content' | mail -s 'mail title' 18829718888@qq.com</code></pre><ol start="4"><li>安装killall</li></ol><pre><code>yum install -y psmisc</code></pre><ol start="5"><li>配置keepalived</li></ol></li></ol><p>   matser 服务器配置</p><p>   <img src="/2021/03/23/nginx-keepalived-gao-ke-yong/master.webp" alt></p><p>   backup配置</p><p>   ​    <img src="/2021/03/23/nginx-keepalived-gao-ke-yong/backup.webp" alt></p><p>   nginx检测脚本如下：</p><pre class=" language-shell"><code class="language-shell">   #!/bin/bash   COOUNT=$(ps -C nginx --no-header |wc -l)   echo  $COUNT   #判断Nginx 是否都挂掉了   if [ $COUNT -eq 0 ]   then           #如果挂掉了，就启动nginx           /usr/local/nginx/sbin/nginx           echo "重启nginx"           #等5秒钟后，再次查看是否 启动成功           sleep 5           #如果nginx没有启动起来，就直接干掉keepalived           COUNT=$(ps -C nginx --no-header |wc -l)           if [ $COUNT -eq 0 ]           then                   echo "干掉keepalived"                   #如果killall命令不能使用，就需要安装psmisc工具了                   #yum install -y psmisc                   killall keepalived           fi   fi</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx：静态缓存</title>
      <link href="/2021/03/18/nginx-jing-tai-huan-cun/"/>
      <url>/2021/03/18/nginx-jing-tai-huan-cun/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        采用Key value 缓存详情页主体html，通过nginx配置缓存，能极大加快页面上的静态资源加载速度，提高QPS.当请求过来时，优先去访问本地静态缓存文件，在本地没有的时候，再去访问redis或者数据库，可以进一步提高并发性。当后台数据发生变更时，及时清楚nginx上指定的缓存。</p><h3 id="基本缓存配置"><a href="#基本缓存配置" class="headerlink" title="基本缓存配置"></a>基本缓存配置</h3><ol><li><p>配置缓存区块, 创建缓存目录</p><pre class=" language-shell"><code class="language-shell">mkdir -p /cache</code></pre></li><li><p>配置nginx,conf</p></li></ol><ul><li><p>http下配置如下：</p><pre class=" language-shell"><code class="language-shell">proxy_cache_path /cache/nginx levels=1:2 keys_zone=cache_nginx:500m inactive=20d max_size=1g;#proxy_cache_path 缓存路径#levels 缓存层级及目录位数 1:2 表示采用两层目录，首层为key的md5后倒数第一个字符，第二层为第2-3个字符#keys_zone 缓存区内存大小#inactive 有效期#max_size 硬盘大小</code></pre></li><li><p>location配置如下：</p><pre class=" language-shell"><code class="language-shell"># 表示引用上面的缓存配置proxy_cache cache/nginx;# 设置缓存的key,$host表示域名，$uri表示除了？外的域名信息，$is_args表示问号，$args就是参数。proxy_cache_key $host$uri$is_args$args;# 哪些页面进行缓存，只缓存结果为200 或 304的，缓存有效期为12小时；proxy_cache_valid 200 304 12h;</code></pre></li></ul><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>​        缓存更新依赖于第三方模块 ngx_cache_purge.该模块。</p><p>​        配置如下：</p><pre class=" language-shell"><code class="language-shell">location ~ /clear(/.*) {    allow 192.168.0.1; #允许特定的ip访问    deny all; #拒绝所有访问    proxy_cache_purge cache_nginx $host$1$is_args$args;}</code></pre><p>调用 <a href="http://www.test.com/test" target="_blank" rel="noopener">www.test.com/test</a> 将会进行页面缓存</p><p>调用<a href="http://www.test.com/clear/test" target="_blank" rel="noopener">www.test.com/clear/test</a> 将会进行页面缓存清除</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos：服务治理</title>
      <link href="/2021/03/16/nacos-fu-wu-zhi-li/"/>
      <url>/2021/03/16/nacos-fu-wu-zhi-li/</url>
      
        <content type="html"><![CDATA[<h4 id="Nacos-简介"><a href="#Nacos-简介" class="headerlink" title="Nacos 简介"></a>Nacos 简介</h4><h5 id="Nacos是什么"><a href="#Nacos是什么" class="headerlink" title="Nacos是什么?"></a>Nacos是什么?</h5><p>​        Nacos致力于帮助您发现、配置和管理微服务。Nacos提供一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>​        Nacos不仅仅是一个像 Zookeeper、Consul一样是<strong>注册中心</strong>，同时也是一个<strong>配置中心</strong>。</p><p>​        Nacos是阿里巴巴基于自家自研产品ConfigServer的开源实现，于2018年7月发布首个开源版本V0.1.0.</p><h5 id="Nacos能做什么？"><a href="#Nacos能做什么？" class="headerlink" title="Nacos能做什么？"></a>Nacos能做什么？</h5><ul><li><p>服务注册发现和健康检测</p><p>​        Nacos支持基于DNS和RPC的服务发现，服务端可以通过SDK或者API进行服务注册，相应的服务消费者可以使用DNS或者Http查找的方式获取服务列表。Nacos同时提供对服务的实时健康检查，阻止不健康的主机或服务发送请求，与Eureka类似，Nacos也有友好的控制台界面。</p></li><li><p>动态配置服务</p><p>​        Nacos支持动态的配置管理，将服务的配置信息可以分环境、分类别进行外部管理，并且支持热更新。</p><p>​        Nacos的配置信息存储与数据库中，支持配置信息的监听和版本回滚。</p></li><li><p>动态DNS服务</p><p>​        支持权重路由，更容易实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。</p></li><li><p>服务及元数据管理</p><p>​        可以从微服务平台建设的视角管理数据中心的所有服务及元数据，包括服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的SLA以及首要的metrics统计数据。</p></li></ul><h4 id="配置文件参数详解"><a href="#配置文件参数详解" class="headerlink" title="配置文件参数详解"></a>配置文件参数详解</h4><ol><li><p>在bootstap.yml中进行nacos配置文件管理的地址配置，SpringCloud在启动过程中会根据配置的路径获取Nacos上对应的项目配置。</p><ul><li>bootstrap.yml(位于项目中)</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> idCenter  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>      <span class="token key atrule">nacos</span><span class="token punctuation">:</span>          <span class="token key atrule">config</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 配置管理</span>              <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 81.68.118.170<span class="token punctuation">:</span><span class="token number">8848</span>              <span class="token key atrule">file-extension</span><span class="token punctuation">:</span> yml                <span class="token key atrule">group</span><span class="token punctuation">:</span> id<span class="token punctuation">-</span>center<span class="token punctuation">-</span>service              <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 5e400be4<span class="token punctuation">-</span>3671<span class="token punctuation">-</span>40c8<span class="token punctuation">-</span>9ebb<span class="token punctuation">-</span>e79740376b60</code></pre></li></ol><ol start="2"><li><p>在Nacos上建立对应配置文件，配置文件内容为项目具体配置</p><p><img src="/2021/03/16/nacos-fu-wu-zhi-li/image-20210316111231404.png" alt=""></p><p><img src="/2021/03/16/nacos-fu-wu-zhi-li/image-20210316111331716.png" alt=""></p></li><li><p>配置文件中包含Nacos的服务注册配置</p></li></ol><ul><li><p>idCenter.yml (该配置位于Nacos上)</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">application</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> idCenter    <span class="token key atrule">cloud</span><span class="token punctuation">:</span>        <span class="token key atrule">nacos</span><span class="token punctuation">:</span>            <span class="token key atrule">discovery</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 服务注册</span>                <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 81.68.118.170<span class="token punctuation">:</span><span class="token number">8848</span>                <span class="token key atrule">group</span><span class="token punctuation">:</span> id<span class="token punctuation">-</span>center<span class="token punctuation">-</span>service                <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 5e400be4<span class="token punctuation">-</span>3671<span class="token punctuation">-</span>40c8<span class="token punctuation">-</span>9ebb<span class="token punctuation">-</span>e79740376b60</code></pre></li></ul><p>总结：SpringCloud在启动过程中，会通过Bootstrap的配置信息，获取Nacos上对应项目配置文件，再根据其配置文件中配置的<strong>服务注册</strong>进行相应的服务注册。</p><h4 id="POM配置"><a href="#POM配置" class="headerlink" title="POM配置"></a>POM配置</h4><pre class=" language-xML"><code class="language-xML">        <!-- 配置中心管理-->        <dependency>            <groupId>com.alibaba.cloud</groupId>            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>        </dependency>        <!--服务注册管理-->        <dependency>            <groupId>com.alibaba.cloud</groupId>            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>        </dependency></code></pre><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@EnableDiscoveryClient</span>    <span class="token comment" spellcheck="true">//启动注册发现服务</span></code></pre><h4 id="nacos-配置文件规则"><a href="#nacos-配置文件规则" class="headerlink" title="nacos 配置文件规则"></a>nacos 配置文件规则</h4><p>​    <strong><em>配置维度：Profiles + Group + Namespace</em></strong></p><h5 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h5><ul><li>是指Nacos配置管理中心的单个配置文件</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># bootStrap.yml</span><span class="token key atrule">Spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span>        <span class="token key atrule">active</span><span class="token punctuation">:</span> DEV</code></pre><ul><li><p>未在bootstrap配置该参数时，DATA ID 的命名方式为：${spring.applicaiton.name}.${spring.cloud.nacos.config.file-extension}，例如：idCenter.yml</p></li><li><p>若启动时，在bootstrap中添加了上述配置，则命名方式为：${spring.applicaiton.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}, 例如：idCenter-DEV.yml</p></li></ul><h5 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h5><ul><li><p>Data ID 集合的概念，可以将同一工程的配置文件划分到一个组中，启动时通过bootstrap来指定：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">cloud</span><span class="token punctuation">:</span>        <span class="token key atrule">nacos</span><span class="token punctuation">:</span>            <span class="token key atrule">config</span><span class="token punctuation">:</span>                 <span class="token key atrule">group</span><span class="token punctuation">:</span> idCenter</code></pre></li></ul><h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5><ul><li>Nacos用于做多环境多租户数据配置和服务隔离，官方推荐，多套环境建议创建不同的namespace进行隔离。</li><li>不同命名空间，可以有相同的Group 和Data ID.</li></ul><pre class=" language-YAML"><code class="language-YAML">spring:    cloud:        nacos:            config:                 namespace: 7e8ccc22-6f51-42fa-bcf1-db45f99dbf57</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker：基础文件配置与命令</title>
      <link href="/2021/03/15/docker-ji-chu-wen-jian-pei-zhi-yu-ming-ling/"/>
      <url>/2021/03/15/docker-ji-chu-wen-jian-pei-zhi-yu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h4 id="Dockerfile命令详解"><a href="#Dockerfile命令详解" class="headerlink" title="Dockerfile命令详解"></a>Dockerfile命令详解</h4><ul><li><p>FROM</p></li><li><p>定制的镜像基于FROM的镜像</p></li><li><p>RUN</p><ul><li>用于执行后面跟着的命令行命令。</li></ul></li><li><p>COPY</p><ul><li>从上下文目录复制文件或目录到容器指定路径</li></ul></li><li><p>ADD</p><ul><li>和COPY的使用格式一致，比较推荐</li><li>执行tar压缩文件，会自动复制解压到目标路径</li></ul></li><li><p>CMD</p><ul><li>类似于RUN命令<ul><li>CMD在docker run时执行</li><li>RUN在docker build时执行</li><li>作用：为启动容器指定默认要启动的程序，可被docker run命令行参数中指定运行的程序覆盖。</li></ul></li></ul></li><li><p>ENTRYPOINT</p><ul><li>类似于CMD指令，但不会被run命令覆盖，会被当做参数传递给ENTRYPOINT指令指定的程序，当加了–entrypoint选项，其程序会被该参数指定的程序所覆盖。</li><li>执行docker run 可以指定ENTRYPOIT</li></ul></li><li><p>ENV</p><ul><li>设置环境变量</li></ul></li><li><p>ARG</p><ul><li>构建参数，与ENV作用一致</li><li>仅对Dockerfile内有效，即docker build的过程有效</li><li>构建好的镜像内不存在此环境变量</li></ul></li><li><p>VOLUME</p><ul><li>定义匿名数据卷，若启动忘记挂载，会自动挂载到匿名卷</li></ul></li><li><p>EXPOSE</p><ul><li>仅仅是声明端口</li><li>在运行时随机端口映射时，会自动随机映射EXPOSE的端口</li></ul></li><li><p>WORKDIR</p><ul><li>指定工作目录</li></ul></li><li><p>USER</p><ul><li>用于指定执行后续命令的用户和用户组</li></ul></li><li><p>HEALTHCHECK</p><ul><li>用于指定某个程序或者指令来监控docker容器服务的运行状态</li></ul></li><li><p>ONBUILD</p><ul><li>用于延迟构建命令的执行</li><li>其命令内容本此镜像构建不会执行，当被作为引用镜像，参与构建时，该命令会被执行。</li></ul></li></ul><h4 id="docker-compose-yml-内容详解"><a href="#docker-compose-yml-内容详解" class="headerlink" title="docker-compose.yml 内容详解"></a>docker-compose.yml 内容详解</h4><ul><li>image<ul><li>镜像地址，仓库找不到时会尝试进行拉取</li></ul></li><li>build<ul><li>指定Dockerfile所在文件夹路径，Compose会利用该文件自动构建这个镜像</li><li>build构建镜像和image下拉镜像，优先通过build执行Dockerfile构建镜像</li></ul></li><li>command<ul><li>覆盖掉默认的命令</li></ul></li><li>links<ul><li>可以link到其他的容器（同YAM文件中）</li><li>可写应用名，或link别名</li></ul></li><li>depends_on<ul><li>依赖的容器名</li></ul></li><li>external_links<ul><li>可以link到非同YAML内的容器</li><li>确保被link容器要正常运行</li><li>可以直接写应用名，或别名</li></ul></li><li>extra_hosts<ul><li>hostname映射</li><li>相当于Docker Run 中–add-host参数</li></ul></li><li>ports<ul><li>申明主机和容器端口</li><li>也可只声明容器端口，外部端口会随机选择</li></ul></li><li>expose<ul><li>开放端口但不会被映射</li><li>用于被其他的容器link</li><li>只能保留内部端口</li></ul></li><li>volumes<ul><li>支持Mount存储卷</li><li>可指定主机路径和容器路径</li><li>还可以包括只读</li></ul></li><li>volumes_from<ul><li>支持从其他APP和容器Mount</li></ul></li><li>environment<ul><li>添加环境变量</li><li>可以指定YML数组或者字典</li></ul></li><li>env_file<ul><li>从文件中获取文件变量</li><li>通过docker-compose -f FILE 指定模板文件，则路径会基于模板文件路径</li><li>变量名与environment指令冲突，则以后者为准</li></ul></li><li>extends<ul><li>基于已有的服务进行扩展</li></ul></li></ul><h4 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h4><h5 id="Docker容器使用"><a href="#Docker容器使用" class="headerlink" title="Docker容器使用"></a>Docker容器使用</h5><ol><li><p>指定容器执行命令</p><pre class=" language-shell"><code class="language-shell">docker run ubuntu:15.10 /bin/echo "Hellow world"</code></pre></li></ol><ol start="2"><li><p>启动并进入容器终端</p><pre class=" language-shell"><code class="language-shell">docker run -i -t ubuntu:15.10 /bin/bashdocker run -it ubuntu:15.10 /bin/bash</code></pre></li><li><p>容器后台模式（创建进程）</p><pre class=" language-shell"><code class="language-shell">docker run -d ubuntu:15.10 /bin/sh -c ""   ---d  带d会自动进入后台docker run -itd --name ubuntu-test ubuntu /bin/bash</code></pre></li><li><p>​    宿主主机内查看容器标准输出</p><pre class=" language-shell"><code class="language-shell">docker logs 序列号</code></pre></li><li><p>停止容器</p><pre class=" language-shell"><code class="language-shell">docker stop 序列号/名称</code></pre></li><li><p>镜像获取</p><pre class=" language-shell"><code class="language-shell">docker pull ubuntu</code></pre></li><li><p>查看所有容器</p><pre class=" language-shell"><code class="language-shell">docker ps -a</code></pre></li><li><p>启动容器</p><pre class=" language-shell"><code class="language-shell">docker restart 序列号docker start 序列号</code></pre></li><li><p>进入后台容器</p><pre class=" language-shell"><code class="language-shell">docker attach 序列号                        ---------退出会导致容器停止docker exec -it 序列号 /bin/bash             --------退出不会导致容器停止</code></pre></li><li><p>导出容器</p><pre class=" language-shell"><code class="language-shell">docker export 序列号 > ubuntu.tar     导出镜像到指定位置</code></pre></li></ol><ol start="11"><li><p>导入容器快照</p><pre class=" language-shell"><code class="language-shell">cat ubuntu.tar | docker import -test/ubuntu:v1   导入到镜像V1中docker import http://example.com/exampleimage.tgz example/imagerepo   通过URL或目录导入</code></pre></li><li><p>删除容器</p><pre class=" language-shell"><code class="language-shell">docker rm -f 序列号</code></pre></li><li><p>查看docker映射端口</p><pre class=" language-shell"><code class="language-shell">docker port 序列号</code></pre></li><li><p>查看容器内部进程</p><pre class=" language-shell"><code class="language-shell">docker top 实例名</code></pre></li><li><p>检查docker底层信息    </p><pre class=" language-shell"><code class="language-shell">docker inspect 实例名</code></pre></li></ol><h5 id="Docker镜像使用"><a href="#Docker镜像使用" class="headerlink" title="Docker镜像使用"></a>Docker镜像使用</h5><ol><li><p>查看本机镜像</p><pre class=" language-shell"><code class="language-shell">docker images</code></pre></li><li><p>使用镜像运行容器</p><pre class=" language-shell"><code class="language-shell">docker run -it ubuntu:15.10 /bin/bash</code></pre></li><li><p>获取新镜像</p><pre class=" language-shell"><code class="language-shell">docker pull ubuntu:13.10</code></pre></li><li><p>查找镜像</p><pre class=" language-shell"><code class="language-shell">docker search httpd   ---查找httpd镜像</code></pre><h5 id="Docker绑定端口和IP"><a href="#Docker绑定端口和IP" class="headerlink" title="Docker绑定端口和IP"></a>Docker绑定端口和IP</h5><pre class=" language-shell"><code class="language-shell">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py   ---/udp  申明绑定UDP端口，默认绑定TCP接口</code></pre><h5 id="Docker容器互联"><a href="#Docker容器互联" class="headerlink" title="Docker容器互联"></a>Docker容器互联</h5><pre class=" language-shell"><code class="language-shell">创建网络docker network create -d bridge test-net连接容器test1docker run -itd --name test1 --network test-net ubuntu /bin/bash连接容器test2docker run -itd --name test2 --network test-net ubuntu /bin/bashubuntu 安装pingapt-get updateapt install inputils-pingping 测试ping test2</code></pre></li></ol><h3 id="Dockerfile和docker-compose的区别"><a href="#Dockerfile和docker-compose的区别" class="headerlink" title="Dockerfile和docker-compose的区别"></a>Dockerfile和docker-compose的区别</h3><ul><li>Dockerfile：用于构建镜像，包含镜像运行所需要的环境、程序代码等。</li><li>docker-compose：用于启动服务，编排容器，为容器设定启动参数、环境变量、容器命名，指定不同容器的链接参数等等。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka：与SpringBoot集成</title>
      <link href="/2021/03/15/kafka-yu-springboot-ji-cheng/"/>
      <url>/2021/03/15/kafka-yu-springboot-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h4 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1.引入jar包"></a>1.引入jar包</h4><pre class=" language-xml"><code class="language-xml">         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-stream-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h4 id="2-kafka的配置"><a href="#2-kafka的配置" class="headerlink" title="2. kafka的配置"></a>2. kafka的配置</h4><pre class=" language-yaml"><code class="language-yaml">Spring  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>    <span class="token key atrule">bootstrap-servers</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">9092</span>    <span class="token key atrule">producer</span><span class="token punctuation">:</span>      <span class="token key atrule">retries</span><span class="token punctuation">:</span> <span class="token number">3</span>      <span class="token key atrule">acks</span><span class="token punctuation">:</span> all      <span class="token key atrule">batch-size</span><span class="token punctuation">:</span> <span class="token number">16384</span>      <span class="token key atrule">buffer-memory</span><span class="token punctuation">:</span> <span class="token number">33554432</span></code></pre><h4 id="3-Kafka的配置类"><a href="#3-Kafka的配置类" class="headerlink" title="3. Kafka的配置类"></a>3. Kafka的配置类</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableKafka</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KafkaProducerConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.kafka.bootstrap-servers}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String bootstrapServer<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.kafka.producer.retries}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> retries<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.kafka.producer.acks}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String acks<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.kafka.producer.batch-size}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.kafka.producer.buffer-memory}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> bufferMemory<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">producerConfigs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>BOOTSTRAP_SERVERS_CONFIG<span class="token punctuation">,</span> bootstrapServer<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>RETRIES_CONFIG<span class="token punctuation">,</span> retries<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>BATCH_SIZE_CONFIG<span class="token punctuation">,</span> batchSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>LINGER_MS_CONFIG<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>ACKS_CONFIG<span class="token punctuation">,</span> acks<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>BUFFER_MEMORY_CONFIG<span class="token punctuation">,</span> bufferMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>KEY_SERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> LongSerializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>VALUE_SERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> StringSerializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> props<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ProducerFactory<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token function">producerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultKafkaProducerFactory</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">producerConfigs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> KafkaTemplate<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token function">kafkaTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        KafkaTemplate<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span> kafkaTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaTemplate</span><span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">producerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> kafkaTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="4-Kafka数据推送"><a href="#4-Kafka数据推送" class="headerlink" title="4. Kafka数据推送"></a>4. Kafka数据推送</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KafkaSyncEsAccountTask</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String KAFKA_ES_TOPIC <span class="token operator">=</span> <span class="token string">"dataSync"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> KafkaTemplate<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span> kafkaTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token function">KafkaSyncEsAccountTask</span><span class="token punctuation">(</span>KafkaTemplate<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span> kafkaTemplate<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>kafkaTemplate <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 数据推送kafka     * @param jsonString     * @return     */</span>    <span class="token annotation punctuation">@Async</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String jsonString<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ListenableFuture send <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>KAFKA_ES_TOPIC<span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> jsonString<span class="token punctuation">)</span><span class="token punctuation">;</span>            send<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>                    result <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"推送用户数据成功, topic: {}; content: {}"</span><span class="token punctuation">,</span> KAFKA_ES_TOPIC<span class="token punctuation">,</span> jsonString<span class="token punctuation">)</span><span class="token punctuation">,</span>                    ex <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"推送用户数据失败, topic: {}; content: {}"</span><span class="token punctuation">,</span> KAFKA_ES_TOPIC<span class="token punctuation">,</span> jsonString<span class="token punctuation">,</span> ex<span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"推送用户信息失败: "</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//return true;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：@Async与@EnableAsync</title>
      <link href="/2021/03/15/java-async-yu-enableasync/"/>
      <url>/2021/03/15/java-async-yu-enableasync/</url>
      
        <content type="html"><![CDATA[<h4 id="1-EnableAsync"><a href="#1-EnableAsync" class="headerlink" title="1. @EnableAsync"></a>1. @EnableAsync</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过ThreadPoolTaskExecutor可以实现一个基于线程池的TaskExecutor，在开发中实现异步任务。</span><span class="token comment" spellcheck="true">//@EnableAsync用在配置类中，标识对异步任务的支持</span><span class="token comment" spellcheck="true">//1.实现方式一</span><span class="token annotation punctuation">@EnableAsync</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskPoolConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ThreadPoolTaskExecutor <span class="token function">taskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setKeepAliveSeconds</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"taskExecutor-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setWaitForTasksToCompleteOnShutdown</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setAwaitTerminationSeconds</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setWaitForTasksToCompleteOnShutdown</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setAwaitTerminationSeconds</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实现方式二：</span><span class="token annotation punctuation">@EnableAsync</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncConfig</span> <span class="token keyword">implements</span> <span class="token class-name">AsyncConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Executor <span class="token function">getAsyncExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//核心线程数</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//最大线程数</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//队列大小</span>        executor<span class="token punctuation">.</span><span class="token function">setKeepAliveSeconds</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//线程最大空闲时间</span>        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"fsx-Executor-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">////指定用于新创建的线程名称的前缀。</span>        executor<span class="token punctuation">.</span><span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 拒绝策略（一共四种，此处省略）</span>        executor<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 异常处理器：当然你也可以自定义的，这里我就这么简单写了~~~</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> AsyncUncaughtExceptionHandler <span class="token function">getAsyncUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAsyncUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-Async"><a href="#2-Async" class="headerlink" title="2. @Async"></a>2. @Async</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//@Async用来表示开启一个异步的任务，可以添加到类上，表明所有的方法都开启异步</span><span class="token comment" spellcheck="true">//2.1 基于有返回值的异步方法，其结果要通过Future接口进行接收</span><span class="token annotation punctuation">@Async</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Future<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">asyncMethodWithReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Execute method asynchronously - "</span>      <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//采用AsyncResult 进行数据的接收</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AsyncResult</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"hello world !!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAsyncAnnotationForMethodsWithReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span>ExecutionException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Invoking an asynchronous method. "</span>      <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1.调用异步方法,返回Future</span>    Future<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> asyncAnnotationExample<span class="token punctuation">.</span><span class="token function">asyncMethodWithReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//2.这里使用了循环判断，等待获取结果信息</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//3.判断是否执行完毕</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result from asynchronous process - "</span> <span class="token operator">+</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Continue doing something else. "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2.2 异步线程之间事务隔离 </span><span class="token comment" spellcheck="true">//子线程异常抛出不会影响主线程的事务</span><span class="token comment" spellcheck="true">//2.3 在一个类中，当前对象的方法中调用当前对象的异步方法不会生效，是因为没有通过代理对象，而是this的调用，需要通过代理进行调用。</span><span class="token comment" spellcheck="true">//添加注解</span><span class="token annotation punctuation">@EnableAspectAutoProxy</span><span class="token punctuation">(</span>exposeProxy <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取代理对象</span>AsyncAopService service <span class="token operator">=</span> <span class="token punctuation">(</span>AsyncAopService<span class="token punctuation">)</span> AopContext<span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>servcie<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud： Gateway整理</title>
      <link href="/2021/03/15/springcloud-gateway-zheng-li/"/>
      <url>/2021/03/15/springcloud-gateway-zheng-li/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Spring Cloud 推出的二代网关框架，目的是取代Zuul</p></li><li><p>功能如下：</p><ul><li>路由转发</li><li>权限校验</li><li>限流控制</li></ul></li><li><p>网关使用要配合服务注册，像eureka、nacos等</p></li><li><p>所有服务均要注册到服务中心，包括网关服务同样需要注册。</p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul><li><a href="https://blog.csdn.net/qq_38380025/article/details/102968559" target="_blank" rel="noopener">https://blog.csdn.net/qq_38380025/article/details/102968559</a></li></ul></li></ul><h4 id="核心依赖（引入到网关服务模块中）"><a href="#核心依赖（引入到网关服务模块中）" class="headerlink" title="核心依赖（引入到网关服务模块中）"></a>核心依赖（引入到网关服务模块中）</h4><pre class=" language-xml"><code class="language-xml">       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h4 id="转发配置的两种方式"><a href="#转发配置的两种方式" class="headerlink" title="转发配置的两种方式"></a>转发配置的两种方式</h4><ul><li><p>代码配置</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GatewayClientApplication</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//uri 配置：test.uri: lb://service-one</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${test.uri}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String uri<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//代码配置</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RouteLocator <span class="token function">customRouteLocator</span><span class="token punctuation">(</span>RouteLocatorBuilder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//basic proxy</span>                <span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span>r <span class="token operator">-</span><span class="token operator">></span> r<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"/orderApi/**"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span>                <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>GatewayClientApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>// 以上代码保证：<a href="http://localhost:8080/orderApi/order/info" target="_blank" rel="noopener">http://localhost:8080/orderApi/order/info</a> =&gt; <a href="http://localhost:8081/order/info（疑问：是否是http://localhost:8081/orderApi/order/info）" target="_blank" rel="noopener">http://localhost:8081/order/info（疑问：是否是http://localhost:8081/orderApi/order/info）</a></p></li><li><p>配置文件配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 服务在注册中心的名称  lb://开头 表示从注册中心获取服务</span><span class="token key atrule">test</span><span class="token punctuation">:</span><span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//service<span class="token punctuation">-</span>one<span class="token key atrule">spring</span><span class="token punctuation">:</span><span class="token key atrule">application</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway<span class="token punctuation">-</span>client<span class="token key atrule">cloud</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 网关配置</span>  <span class="token key atrule">gateway</span><span class="token punctuation">:</span>    <span class="token key atrule">routes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> route_service_one      <span class="token key atrule">uri</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>test.uri<span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># uri以lb://开头（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称</span>      <span class="token key atrule">predicates</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 通过网关访问时的请求前缀</span>      <span class="token punctuation">-</span> Path=/userApi/**    <span class="token comment" spellcheck="true"># 保证了http://localhost:8080/userApi/user/who => http://localhost:8081/user/who (疑问：是否是http://localhost:8081/userApi/user/who) </span>      <span class="token key atrule">filters</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> StripPrefix=1 <span class="token comment" spellcheck="true"># 表示在转发时去掉首层路径（因此会跳到http://localhost:8081/user/who 中）</span><span class="token key atrule">server</span><span class="token punctuation">:</span><span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">logging</span><span class="token punctuation">:</span><span class="token key atrule">level</span><span class="token punctuation">:</span>  <span class="token key atrule">org.springframework.cloud.gateway</span><span class="token punctuation">:</span> TRACE  <span class="token key atrule">org.springframework.http.server.reactive</span><span class="token punctuation">:</span> DEBUG  <span class="token key atrule">org.springframework.web.reactive</span><span class="token punctuation">:</span> DEBUG  <span class="token key atrule">reactor.ipc.netty</span><span class="token punctuation">:</span> DEBUG<span class="token key atrule">eureka</span><span class="token punctuation">:</span><span class="token key atrule">client</span><span class="token punctuation">:</span>  <span class="token key atrule">service-url</span><span class="token punctuation">:</span>    <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8761/eureka/<span class="token key atrule">instance</span><span class="token punctuation">:</span>  <span class="token key atrule">prefer-ip-address</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre></li></ul><h4 id="网关限流（令牌桶算法）"><a href="#网关限流（令牌桶算法）" class="headerlink" title="网关限流（令牌桶算法）"></a>网关限流（令牌桶算法）</h4><h5 id="引入pom文件"><a href="#引入pom文件" class="headerlink" title="引入pom文件"></a>引入pom文件</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifatId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis-reactive<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> limit_route          <span class="token key atrule">uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//httpbin.org<span class="token punctuation">:</span>80/get          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> After=2019<span class="token punctuation">-</span>02<span class="token punctuation">-</span>26T00<span class="token punctuation">:</span>00<span class="token punctuation">:</span>00+08<span class="token punctuation">:</span>00<span class="token punctuation">[</span>Asia/Shanghai<span class="token punctuation">]</span>          <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 加入限流</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> RequestRateLimiter            <span class="token key atrule">args</span><span class="token punctuation">:</span>              <span class="token key atrule">key-resolver</span><span class="token punctuation">:</span> '<span class="token comment" spellcheck="true">#{@apiKeyResolver}' #用于限流的键的解析器的Bean对象的名字，通过SpEL表达式从容器中进行获取Bean对象</span>              <span class="token key atrule">redis-rate-limiter.replenishRate</span><span class="token punctuation">:</span> <span class="token number">300 </span><span class="token comment" spellcheck="true">#设定每秒填充令牌速率</span>              <span class="token key atrule">redis-rate-limiter.burstCapacity</span><span class="token punctuation">:</span> <span class="token number">500 </span><span class="token comment" spellcheck="true">#设定令牌的最大容量</span>              <span class="token key atrule">redis-rate-limiter.requestedTokens</span><span class="token punctuation">:</span> <span class="token number">1 </span><span class="token comment" spellcheck="true">#设定单请求获取令牌的数量</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway<span class="token punctuation">-</span>limiter  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span></code></pre><h5 id="编写限流解析器"><a href="#编写限流解析器" class="headerlink" title="编写限流解析器"></a>编写限流解析器</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestRateLimiterConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@Primary</span>    KeyResolver <span class="token function">apiKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//按URL限流,即以每秒内请求数按URL分组统计，超出限流的url请求都将返回429状态</span>        <span class="token keyword">return</span> exchange <span class="token operator">-</span><span class="token operator">></span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    KeyResolver <span class="token function">ipKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//按IP来限流(为了获取真实IP，而防止获取代理的IP)</span>        <span class="token keyword">return</span> exchange <span class="token operator">-</span><span class="token operator">></span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"X-Forwarded-For"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> KeyResolver <span class="token function">hostAddrKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//按IP来限流（可能会限制代理IP）</span>        <span class="token keyword">return</span> exchange <span class="token operator">-</span><span class="token operator">></span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud：OpenFeign与Hystrix整合</title>
      <link href="/2021/03/15/springcloud-openfeign-yu-hystrix-zheng-he/"/>
      <url>/2021/03/15/springcloud-openfeign-yu-hystrix-zheng-he/</url>
      
        <content type="html"><![CDATA[<pre><code>Spring Cloud 框架提供了RestTemplate和FeignClient两个方式完成服务间的调用，本文只要记录OpenFeign的使用，即FeignClient的形式调用。</code></pre><p>参考博客：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/105073492" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105073492</a></li><li><a href="https://www.jianshu.com/p/8bca50cb11d8" target="_blank" rel="noopener">https://www.jianshu.com/p/8bca50cb11d8</a></li><li><a href="https://xli1224.github.io/2017/09/22/configure-feign/" target="_blank" rel="noopener">https://xli1224.github.io/2017/09/22/configure-feign/</a></li><li><a href="https://blog.csdn.net/alex_xfboy/article/details/88840491" target="_blank" rel="noopener">https://blog.csdn.net/alex_xfboy/article/details/88840491</a></li><li><a href="https://blog.csdn.net/lizhengyu891231/article/details/107251141?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3" target="_blank" rel="noopener">https://blog.csdn.net/lizhengyu891231/article/details/107251141?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3</a></li><li><a href="https://www.cnblogs.com/crazymakercircle/p/11664812.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazymakercircle/p/11664812.html</a></li><li><a href="https://blog.csdn.net/qq_35387940/article/details/94569189" target="_blank" rel="noopener">https://blog.csdn.net/qq_35387940/article/details/94569189</a></li><li><a href="https://www.jianshu.com/p/59295c91dde7" target="_blank" rel="noopener">https://www.jianshu.com/p/59295c91dde7</a></li><li><a href="https://my.oschina.net/xiaominmin/blog/3033944" target="_blank" rel="noopener">https://my.oschina.net/xiaominmin/blog/3033944</a></li><li><a href="https://zhuanlan.zhihu.com/p/85569972" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85569972</a></li></ul><h4 id="需要引用的包"><a href="#需要引用的包" class="headerlink" title="需要引用的包"></a>需要引用的包</h4><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>//版本取与cloud相对应的版本</code></pre><h4 id="1-对应接口添加-FeignClient"><a href="#1-对应接口添加-FeignClient" class="headerlink" title="1. 对应接口添加@FeignClient"></a>1. 对应接口添加@FeignClient</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// @AliasFor("value")</span><span class="token comment" spellcheck="true">//    String name() default "";</span><span class="token comment" spellcheck="true">//注解中的属性name和value的作用是一样的</span><span class="token comment" spellcheck="true">//额外提醒，只要是传参，请都加上@RequestParam（"XXXX"）;如果传对象就加上@RequestBody； 这样你就不用踩Feign的传参的坑了，不管是使用Feign的服务还是提供接口的client服务，请都加上这些传参注解保持一致</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"captcha-service"</span><span class="token punctuation">,</span> fallbackFactory <span class="token operator">=</span> CaptchaServiceFeignFallbackFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CaptchaServiceFeign</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 图片验证码     * @return     */</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/captcha/feign/imageCaptcha"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    CaptchaVo <span class="token function">imageCaptcha</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-启动类添加注解-EnableFeignClients"><a href="#2-启动类添加注解-EnableFeignClients" class="headerlink" title="2. 启动类添加注解@EnableFeignClients"></a>2. 启动类添加注解@EnableFeignClients</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//@EnableFeignClients(basePackages = "com.tcl.tcloud.base.common.feign")</span><span class="token comment" spellcheck="true">//添加package，指明要使用FeignClient的位置</span><span class="token comment" spellcheck="true">//不需要使用@RestTemplate,feign已经自动集成了Ribbon负载均衡的RestTemplate</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token punctuation">(</span>exclude<span class="token operator">=</span><span class="token punctuation">{</span>DruidDataSourceAutoConfigure<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@EnableRetry</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>AuthApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@LoadBalanced</span>    <span class="token annotation punctuation">@Bean</span>    RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//EnableFeignClients可以指定其配置参数 defaultConfiguration，该配置将会对所有的FeignClient生效，部分版本不行，需要单独配置</span><span class="token comment" spellcheck="true">//关于 Feign Client 的配置还有个比较有趣的现象，尽管对于全局的 Feign Client 已经能够通过配置文件来进行默认属性的配置，但是这个 pull 并没有进入最新 GA 的 Dalston SR3版本。该 pull 在这里 `FeignClient Configuration Properties by khannedy · Pull Request #1942 · spring-cloud/spring-cloud-netflix · GitHub ，可以看到该 pull 被安排进了 Edgware 版本。当前项目使用还是用的 Dalston，所以只能用 configuraiotn 的形式来为每个 FeignClient 单独配置</span><span class="token comment" spellcheck="true">//示例：@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration.class)</span><span class="token comment" spellcheck="true">//feign的配置类</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFeignConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Retryer <span class="token function">feignRetryer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Retryer<span class="token punctuation">.</span>Default</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义日志级别</span>     <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Logger<span class="token punctuation">.</span>Level <span class="token function">feignLoggerLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Logger<span class="token punctuation">.</span>Level<span class="token punctuation">.</span>BASIC<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Feign支持<span class="token number">4</span>种级别：<span class="token operator">-</span> NONE：不记录任何日志信息，这是默认值。<span class="token operator">-</span> BASIC：仅记录请求的方法，URL以及响应状态码和执行时间<span class="token operator">-</span> HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息<span class="token operator">-</span> FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 以上配置均可以通过YAML文件进行配置</span><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span>        <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">5000 </span><span class="token comment" spellcheck="true">#连接超时</span>        <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">5000 </span><span class="token comment" spellcheck="true">#读取超时</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> basic <span class="token comment" spellcheck="true">#日志等级</span>        <span class="token comment" spellcheck="true"># 配置日志级别</span><span class="token key atrule">logging</span><span class="token punctuation">:</span>      <span class="token key atrule">level</span><span class="token punctuation">:</span>        <span class="token key atrule">com.xt.open.jmall.product.remote.feignclients.CartFeignClient</span><span class="token punctuation">:</span> debug        <span class="token comment" spellcheck="true"># 设置cn.figo包下的日志级别为debug</span>        <span class="token key atrule">cn.figo</span><span class="token punctuation">:</span> debug</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 请求压缩</span><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">compression</span><span class="token punctuation">:</span>    <span class="token key atrule">request</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启请求压缩</span>      <span class="token key atrule">mime-types</span><span class="token punctuation">:</span> text/html<span class="token punctuation">,</span>application/xml<span class="token punctuation">,</span>application/json <span class="token comment" spellcheck="true"># 设置压缩的数据类型</span>      <span class="token key atrule">min-request-size</span><span class="token punctuation">:</span> <span class="token number">2048 </span><span class="token comment" spellcheck="true"># 设置触发压缩的大小下限</span>    <span class="token key atrule">response</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启响应压缩</span></code></pre><h4 id="FeignClient的注解参数作用"><a href="#FeignClient的注解参数作用" class="headerlink" title="FeignClient的注解参数作用"></a>FeignClient的注解参数作用</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Source code recreated from a .class file by IntelliJ IDEA</span><span class="token comment" spellcheck="true">// (powered by Fernflower decompiler)</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>openfeign<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AliasFor<span class="token punctuation">;</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FeignClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//指定FeignClient的名称，如果项目使用了Ribbon，name属性使用目标微服务的名称</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** @deprecated */</span>    <span class="token annotation punctuation">@Deprecated</span>    String <span class="token function">serviceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    String <span class="token function">contextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    String <span class="token function">qualifier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//url一般用于调试，可以手动指定@FeignClient的调用地址</span>    String <span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//当发生404时，该字段如果为true，会调用decoder进行解码，否则抛FeignException</span>    <span class="token keyword">boolean</span> <span class="token function">decode404</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Feign的配置类，可自定义Feign的Encoder、Decoder、Loglevel、Contract</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义容错的处理类，当远程调用失败或超时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">fallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用于生成fallback类示例，可实现每个接口通用的容错逻辑</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">fallbackFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义当前FeignClient的统一前缀</span>    String <span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">primary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Feign实现Hystrix的两种方式"><a href="#Feign实现Hystrix的两种方式" class="headerlink" title="Feign实现Hystrix的两种方式"></a>Feign实现Hystrix的两种方式</h4><p>配置内容</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token comment" spellcheck="true"># 开启feign的熔断功能，默认false不会开启</span></code></pre><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>实现被@FeignClient注解标识的接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CaptchaServiceFeignImpl</span> <span class="token keyword">implements</span> <span class="token class-name">CaptchaServiceFeign</span><span class="token punctuation">{</span>     CaptchaVo <span class="token function">imageCaptcha</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//实现代码，即服务熔断之后要做的业务操作等等</span>         <span class="token keyword">return</span> null<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>引用该类到@FeignClient的fallback属性上</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"captcha-service"</span><span class="token punctuation">,</span> fallback <span class="token operator">=</span> CaptchaServiceFeignImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>编写实现FallbackFactory接口的类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//将泛型参数 AppCenterClient 换成 CaptchaServiceFeign 即可</span><span class="token annotation punctuation">@Component</span><span class="token keyword">class</span> <span class="token class-name">ApplicationAuthFeignFallbackFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FallbackFactory</span><span class="token operator">&lt;</span>AppCenterClient<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>ApplicationAuthFeignFallbackFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> AppCenterClient <span class="token function">create</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AppCenterClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> String <span class="token function">checkApp</span><span class="token punctuation">(</span>String appId<span class="token punctuation">,</span> String appSect<span class="token punctuation">,</span> String tenantId<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"verify appId and appSecret into fallback error:{}"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> String <span class="token function">getAppInfo</span><span class="token punctuation">(</span>String appId<span class="token punctuation">,</span> String tenantId<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"get app info into fallback error:{}"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> String <span class="token function">getAppInfos</span><span class="token punctuation">(</span>String appId<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"get app infos into fallback error:{}"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>引用该类到@FeignClient的fallbackFactory属性上</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"base-app-service"</span><span class="token punctuation">,</span> fallbackFactory <span class="token operator">=</span> ApplicationAuthFeignFallbackFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><p>EnableHystrix注解的作用和@EnableCircuitBreaker注解的作用一样，@EnableHystrix注解对 @EnableCircuitBreaker注解进行了封装</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>        <span class="token annotation punctuation">@Documented</span>        <span class="token annotation punctuation">@Inherited</span>        <span class="token annotation punctuation">@EnableCircuitBreaker</span>        <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableHystrix</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span></code></pre></li><li><p>Feign自定义处理返回的异常</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//该类需要在@Configuration修饰的配置类中声明</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StashErrorDecoder</span> <span class="token keyword">implements</span> <span class="token class-name">ErrorDecoder</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Exception <span class="token function">decode</span><span class="token punctuation">(</span>String methodKey<span class="token punctuation">,</span> Response response<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">400</span> <span class="token operator">&amp;&amp;</span> response<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">499</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这里是给出的自定义异常</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StashClientException</span><span class="token punctuation">(</span>                    response<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    response<span class="token punctuation">.</span><span class="token function">reason</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">500</span> <span class="token operator">&amp;&amp;</span> response<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">599</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这里是给出的自定义异常</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StashServerException</span><span class="token punctuation">(</span>                    response<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    response<span class="token punctuation">.</span><span class="token function">reason</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//这里是其他状态码处理方法</span>        <span class="token keyword">return</span> <span class="token function">errorStatus</span><span class="token punctuation">(</span>methodKey<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><ul><li>Feign除了解决微服务之间的调用，里面还囊括了Ribbon负载均衡和Hystrix熔断降级</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>首先，Feign内部已经包含了Ribbon和Hystrix,所以启动类加@EnableFeignClients就已经够用了，无需再加其他多余的相关Hystrix和Ribbon的注解</p></li><li><p>Feign负责调用，其本质是对Ribbon通过RestTemplate进行请求调用的模板化封装</p></li><li><p>Feign、Ribbon和Hystrix的关系是：</p><ul><li>Feign负责发起调用</li><li>Ribbon负责负载均衡，其调用超过超时时间就切换被调用的实例</li><li>Hystrix负责熔断，接口调用时间（实例数 * ribbon的超时时间）大于熔断超时时间时将熔断，返回callback内容。</li></ul></li><li><p>Feign支持全局配置和单个Client配置</p></li><li><p>Feign支持Configuration和YAML两种配置方式</p></li><li><p>Feign可配置的内容包括</p><ul><li><p>日志配置</p><ul><li>使用loggin.level.<feignclient>来开启指定Feign客户端的DEBUG日志</feignclient></li><li><feignclient>要使用完整路径</feignclient></li><li>需要开启日志级别，即Logger.Level，默认为NONE,推荐开启全局日志，通过bean或配置文件均可</li></ul></li><li><p>请求压缩</p><ul><li><p>开启请求和响应压缩</p><pre class=" language-yaml"><code class="language-yaml">feign.compression.request.enabled=truefeign.compression.response.enabled=true</code></pre></li><li><p>可以配置部分参数</p><pre class=" language-yaml"><code class="language-yaml">feign.compression.request.enabled=truefeign.compression.request.nime<span class="token punctuation">-</span>types=text/xml<span class="token punctuation">,</span>application/xml<span class="token punctuation">,</span>application/jsonfeign.compression.requestmin<span class="token punctuation">-</span>request<span class="token punctuation">-</span>size=2048</code></pre></li></ul></li></ul></li><li><p>Feign超时配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#设置所有的微服务 超时配置</span><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span>        <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">50000</span>        <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">50000</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> basic<span class="token comment" spellcheck="true">#单独设置某个微服务的超时配置</span><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">server-A</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 设定server-A 服务调用的超时设置</span>        <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">50000</span>        <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">50000</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> basic <span class="token comment" spellcheck="true"># 如果未配置feign的超时，配置ribbon也会生效，因为feign的底层是使用ribbon。</span></code></pre></li></ol><ol start="8"><li><p>Ribbon已经集成在了Feign中，可以直接在application中进行相关参数配置后使用</p></li><li><p>Ribbon配置支持全局配置和指定服务配置</p><ul><li>全局配置：ribbon.<key> = <value></value></key></li><li>指定服务配置：<client>.ribbon.key=value,client代表服务名称</client></li></ul></li><li><p>Ribbon负载均衡</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 7种负载均衡中的一个（默认采用轮询）</span>ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.ZoneAvoidanceRule</code></pre><p>实例化上述策略</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"com.kyle.client.feign.inter"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//实例化策略</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> IRule <span class="token function">feignRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ZoneAvoidanceRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Feign第一次请求失败</p><ul><li>Spring采用懒加载机制i，熔断时间默认为1s，应该提升熔断超时时间和ribbon超时时间</li></ul></li><li><p>Feign的Http Client</p><ul><li><p>默认采用JDK原生URLConnection</p></li><li><p>声明Apache HTTP Client和feign-httpclient依赖</p></li><li><p>application.properties添加</p><pre class=" language-yaml"><code class="language-yaml">feign.httpclient.enabled=true</code></pre></li></ul></li><li><p>Feign支持请求之前进行操作，可对request进行修改，包括header和body。</p><ul><li><p>实现RequestInterceptor接口，实现apply方法</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenRequestInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">RequestInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span>RequestTemplate template<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String method <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String url <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><ol start="13"><li><p>负载均衡可能存在异常：<a href="https://www.jianshu.com/p/59295c91dde7" target="_blank" rel="noopener">https://www.jianshu.com/p/59295c91dde7</a></p></li><li><p>hystrix配置(feign默认集成了hystrix)</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">hystrix</span><span class="token punctuation">:</span>  <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">execution</span><span class="token punctuation">:</span>        <span class="token key atrule">isolation</span><span class="token punctuation">:</span>          <span class="token key atrule">thread</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#若配置了重试则超时时间= (1 + MaxAutoRetries + MaxAutoRetriesNextServer) * ReadTimeout</span>            <span class="token key atrule">timeoutInMilliseconds</span><span class="token punctuation">:</span> <span class="token number">60000</span>  <span class="token key atrule">threadpool</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#全局配置</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">coreSize</span><span class="token punctuation">:</span> <span class="token number">10</span>      <span class="token key atrule">maxQueueSize</span><span class="token punctuation">:</span> <span class="token number">50</span>      <span class="token key atrule">queueSizeRejectionThreshold</span><span class="token punctuation">:</span> <span class="token number">30</span>      <span class="token key atrule">keepAliveTimeMinutes</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token comment" spellcheck="true">#对某个服务配置，写service-id</span>    <span class="token key atrule">base-rpc</span><span class="token punctuation">:</span>      <span class="token key atrule">coreSize</span><span class="token punctuation">:</span> <span class="token number">10</span>      <span class="token key atrule">maxQueueSize</span><span class="token punctuation">:</span> <span class="token number">30</span>      <span class="token key atrule">queueSizeRejectionThreshold</span><span class="token punctuation">:</span> <span class="token number">20</span>      <span class="token key atrule">keepAliveTimeMinutes</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token comment" spellcheck="true">#对某个接口配置</span>    BaseApiClient<span class="token comment" spellcheck="true">#searchItemSkuList(PosSkuSearch):</span>      <span class="token key atrule">coreSize</span><span class="token punctuation">:</span> <span class="token number">10</span>      <span class="token key atrule">maxQueueSize</span><span class="token punctuation">:</span> <span class="token number">40</span>      <span class="token key atrule">queueSizeRejectionThreshold</span><span class="token punctuation">:</span> <span class="token number">30</span>      <span class="token key atrule">keepAliveTimeMinutes</span><span class="token punctuation">:</span> <span class="token number">1   </span></code></pre></li><li><p>httpclient超时配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">okhttp</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">httpclient</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token comment" spellcheck="true">#连接池最大连接数，默认200</span>    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> <span class="token number">500</span><span class="token comment" spellcheck="true">#每一个IP最大占用多少连接 默认 50</span>    <span class="token key atrule">max-connections-per-route</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token comment" spellcheck="true">#默认连接超时时间：2000毫秒</span>    <span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> <span class="token number">8000</span><span class="token comment" spellcheck="true">#连接池管理定时器执行频率：默认 3000毫秒</span>    <span class="token key atrule">connection-timer-repeat</span><span class="token punctuation">:</span> <span class="token number">6000</span><span class="token comment" spellcheck="true">#连接池中存活时间，默认为5</span>    <span class="token key atrule">time-to-live</span><span class="token punctuation">:</span> <span class="token number">5</span>    <span class="token key atrule">time-to-live-unit</span><span class="token punctuation">:</span> minutes</code></pre></li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> OpenFeign </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源组件 日志组件简介</title>
      <link href="/2021/03/12/kai-yuan-zu-jian-ri-zhi-zu-jian-jian-jie/"/>
      <url>/2021/03/12/kai-yuan-zu-jian-ri-zhi-zu-jian-jian-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="1-SLF4J"><a href="#1-SLF4J" class="headerlink" title="1. SLF4J"></a>1. SLF4J</h4><p>​        slf4j的全称是 Simple Loging Facade For Java(简单日志门面) ，<strong>仅仅是为Java程序提供日志输出的统一接口</strong>，并不是一个具体的日志实现方案，允许最终用户在部署其应用时使用其所希望的日志系统。</p><p>​        slf4j的使用<strong>必须搭配其他具体的日志实现方案</strong>，比如 apache的 org.apache.log4j.Logger, jdk自带的 java.util.logging.Logger 。</p><p>​        从设计模式角度考虑，对于只要使用SLF4J提供的接口，即可隐藏日志的具体实现，类似于Jdbc,实现对于客户端的解耦，因为使用的是接口，所以可以实时根据情况来调整日志的实现类</p><p>​        slf4j在编译时静态绑定真正的Log库，相应桥接包放置后，slf4j可以自动探测具体使用哪种日志系统，即StaticLoggerBinder类的具体实现类，然后就可以找到对应日志系统的日志文件。</p><p>​        不同的日志系统包都会有一个Adapter包，用来在slf4j和不同日志系统之间做转换。</p><p>​        slf4j支持四个日志级别，分别是：debug、info、warn、error。</p><p>​        slf4j与具体日志实现的桥接包如下：</p><ul><li>log4j:</li><li>logback:</li><li>jdk</li></ul><h4 id="2-common-logging"><a href="#2-common-logging" class="headerlink" title="2. common-logging"></a>2. common-logging</h4><p>​        apache提供的一个通用的日志接口，像slf4j一样，用户可自由选择第三方的日志组件</p><h4 id="3-Log4j"><a href="#3-Log4j" class="headerlink" title="3.Log4j"></a>3.Log4j</h4><p>​        具体的日志实现方案，Apache的一个开源项目代码，其日志信息的输送目的地包括：控制台、文件、GUI组件、甚至时套接口服务器、NT的时间记录器、UNIX Syslog守护进程等。</p><p>​        用户可控制每一条日志的输出格式、级别和过程等，支持文件灵活配置，无需代码修改。</p><h4 id="4-Logback"><a href="#4-Logback" class="headerlink" title="4. Logback"></a>4. Logback</h4><p>​        具体的日志实现方案，logback当前分为三个模块：</p><ul><li>logback-core 核心基础</li><li>logback-classic log4j的改良版本，完整实现了SLF4J API,方便替换成其他日志方案</li><li>logback-access 访问模块与servlet容器集成提供通过http访问日记的功能</li></ul><h3 id="日志实现方案比较"><a href="#日志实现方案比较" class="headerlink" title="日志实现方案比较"></a>日志实现方案比较</h3><h4 id="Log4j-VS-LogBack"><a href="#Log4j-VS-LogBack" class="headerlink" title="Log4j VS LogBack"></a>Log4j VS LogBack</h4><p>​        LogBack将作为Log4j的替代和SLF4J组成新的日志系统</p><ul><li>LogBack 判定日志是否需要记录时间更短</li><li>创建记录器logger的速度更快</li><li>获取已存在的记录器的时间更短</li><li>LogBack的文档是全面免费的</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/03/12/kai-yuan-zu-jian-ri-zhi-zu-jian-jian-jie/image-20210312150507561.png" alt=""></p><ol><li><p>apache common-logging和slf4j 都是日志接口，并非具体实现方案</p></li><li><p>log4j、logback、log4j2等都是日志记录器的具体实现</p></li><li><p>common-logging通过动态绑定去查询具体实现，slf4j编译时会静态绑定 org.slf4j.impl.StaticLoggerBinder这个类，其他日志实现中包含了该类的实现。</p></li><li><p>采用slf4j接口时，会涉及绑定器和桥接器</p><ul><li><p>绑定器：slf4j-log4j2-version.jar 就是绑定slf4j到log4j。</p></li><li><p>桥接器：jcl-over-slf4j将jcl（java-common-log）接口的日志都接到slf4j的接口，然后采用slf4j的绑定器中绑定的日志来实现记录日志。</p><p>component -&gt;&gt; Apache Commons Logging -&gt;&gt; jcl-over-slf4j,jar -&gt;&gt; SLF4J -&gt;&gt; slf4j-log4j2-version.jar -&gt;&gt; log4j.jar -&gt;&gt;输出日志 </p></li></ul></li><li><p>slf4j-api 、slf4j-log4j2和logj的关系</p><ul><li><p>slf4j类似于数据线，一段嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录</p></li><li><p>slf4j入口就是众多接口的集合，不负责具体接口实现，只负责编译时寻找合适日志系统进行绑定，具体接口全部定义在slf4j-api中，slf4j-api本质就是一个接口定义。</p><p><img src="/2021/03/12/kai-yuan-zu-jian-ri-zhi-zu-jian-jian-jie/image-20210312162206316.png" alt=""></p></li></ul></li><li><p>jar包介绍</p><ul><li>slf4j-api.jar : slf4j自身接口</li><li>common-logging.jar:  接口</li><li>log4j.jar:  具体实现</li><li>logbacj.jar：具体实现</li><li>log4j2.jar：具体实现</li><li>jcl-over-slf4j.jar: 桥接包</li><li>slf4j-log412.jar: 绑定包</li></ul></li><li><p>jar包配合方案：</p><ul><li>Log4j :   slf4j-api.jar +  log4j.jar + slf4j-log4j12.jar</li><li>Log4j2：log4j-slf4j-impl.jar + log4j-api.jar + log4j-core.jar + slf4j-api.jar</li><li>LogBack：logback-classic + logback-core.jar</li></ul></li><li><p>Class path contains multiple SLF4J bindings</p><p>​    报改错原因就是因为多个包像logback-classic、log4j-slf4j-impl、slf4j-log412、slf4j-jdk 的存在，导致slf4j不能确定该使用哪个框架。</p></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="http://www.360doc.com/content/16/0624/19/1073512_570470152.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/16/0624/19/1073512_570470152.shtml</a></li><li><a href="https://zhuanlan.zhihu.com/p/184943995" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/184943995</a></li><li><a href="https://blog.csdn.net/weixin_42410730/article/details/102645095" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42410730/article/details/102645095</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志管理 </tag>
            
            <tag> SLF4J </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源日志组件 Logback配置详解</title>
      <link href="/2021/03/11/kai-yuan-zu-jian-logback-pei-zhi-xiang-jie/"/>
      <url>/2021/03/11/kai-yuan-zu-jian-logback-pei-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h5 id="1-主要模块"><a href="#1-主要模块" class="headerlink" title="1. 主要模块"></a>1. 主要模块</h5><ul><li>logback-core : 核心代码模块</li><li>logback-classic: log4j的改良版本，同时实现了slf4j的接口</li><li>logback-access: 访问模块与Servlet容器集成，提供通过Http来访问日志的功能</li></ul><h5 id="2-配置详解"><a href="#2-配置详解" class="headerlink" title="2. 配置详解"></a>2. 配置详解</h5><p>​    日志级别分别是 trace、debug、info、warn、error</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>debug,默认值false,是否打印logback内部日志信息，true表示打印scan，默认值true,配置发生改变，是否需要重载scanPeriod 默认值 1 seconds,检测配置发生变化的间隔，无单位时。默认是毫秒&lt;configuration scan="true" debug="true" scanPeriod = "1 seconds">    设置日志上下文，后面可通过定义%contextName来打印上下文名称    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>contextName</span><span class="token punctuation">></span></span>logback<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>contextName</span><span class="token punctuation">></span></span>    变量key-value设置，后面配置文件可使用${log.dir}来访问    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>log.dir<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/data/log/token-center<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- SpringBoot default pattern --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org/springframework/boot/logging/logback/defaults.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    日志输出组件，负责日志输出和格式化    name无默认值，组件名称，后面搭配logger指定appender使用    class无默认值，appender的具体实现类    ConsoleAppender: 向控制台输出日志内容的组件    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>${CONSOLE_LOG_PATTERN}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    RollingFileAppender: 向文件输出日志内容的组件，可配置日志文件滚动策略，达到一定条件后生成一个新的日志文件    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE-FULL<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        定义日志输出路径        若log.dir没有在上面的property中设定，则会使用java启动时配置的值        比如通过 java -D log.dir=/path/to XXXXX配置该属性        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>File</span><span class="token punctuation">></span></span>${log.dir}/full.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>File</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>${FILE_LOG_PATTERN}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        文件滚动策略-大小和时间        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            定义文件滚动时的文件名的格式            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FileNamePattern</span><span class="token punctuation">></span></span>${log.dir}/full.log.%d{yyyyMMdd}.%i.gz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FileNamePattern</span><span class="token punctuation">></span></span>            每个日志的最大量为200MB            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">></span></span>200MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">></span></span>            365天的时间周期            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>365<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>            日志总量最大支持10GB,1.1.6以后支持            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>totalSizeCap</span><span class="token punctuation">></span></span>10GB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>totalSizeCap</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE-ERROR<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>File</span><span class="token punctuation">></span></span>${log.dir}/error.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>File</span><span class="token punctuation">></span></span>        对记录事件进行格式化        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>${FILE_LOG_PATTERN}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        这里定义了ERROR,则比ERROR小的级别不会进行记录        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>ERROR<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        文件滚动策略-时间        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${log.dir}/error.log.%d{yyyyMMdd}.gz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>180<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE-ACCESS<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>File</span><span class="token punctuation">></span></span>${log.dir}/access.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>File</span><span class="token punctuation">></span></span>        默认值true,追加到文件尾，false则清空现存文件        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Append</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Append</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} %level %logger - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${log.dir}/access.log.%d{yyyyMMdd}.gz            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>90<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE-USER<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${log.dir}/%d{yyyy-MM-dd}/user_ops-%d{HH}.log            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    以下设定是确定LoggerFactory.getLogger返回的logger的输出级别和类型    对于指定包的个性化配置    这三个指定的包名，输出级别为自身定义，当输出方式未指定则采用root的输出方式      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.zookeeper<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WARN<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.I0Itec<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WARN<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.alibaba.dubbo<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WARN<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    该包名即指定了输出级别和方式    additivity 默认值true 是否也使用root的输出方式，false,不使用，true使用，为true时会造成控制台输出两次    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.logback<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WARN<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation">=</span>“false”</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">></span></span>    默认的logger，指定输出级别为INFO,未通过logger指定包名的统一采用输出级别和方式    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INFO<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        引用多个appender        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE-FULL<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE-ERROR<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h5 id="3-说明点"><a href="#3-说明点" class="headerlink" title="3. 说明点"></a>3. 说明点</h5><ul><li><p>Spring Boot 默认会集成logback</p></li><li><p><logger>可以理解为针对具体包或类的个性化配置，也可继承默认的配置<root></root></logger></p></li><li><p>totalSizeCap、maxFileSize 在1.1.6以后才开始支持</p></li><li><p>rollingPolicy-maxFileSize的配置方案目前任何版本都不会生效—BUG（争议）</p></li><li><p>triggeringPolicy-maxFileSize配置会生效</p><pre class=" language-xml"><code class="language-xml">triggeringPolicy-maxFileSize能够生效,triggeringPolicy 与rollingPolicy同级<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>triggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--每个日志文件最大100MB--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">></span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>triggeringPolicy</span><span class="token punctuation">></span></span></code></pre></li></ul><ol start="4"><li><p>与SpringBoot集成</p><p>Spring的包中已经自动引入logback所需要的包，具体如下：</p><ul><li><p>找到spring-boot-start，点进去</p><p><img src="/2021/03/11/kai-yuan-zu-jian-logback-pei-zhi-xiang-jie/spring-boot-start.jpg" alt=""></p></li><li><p>找到spring-boot-start-logging，点进去</p><p><img src="/2021/03/11/kai-yuan-zu-jian-logback-pei-zhi-xiang-jie/logging.jpg" alt=""></p></li><li><p>可以看到下面的三个包</p><p><img src="/2021/03/11/kai-yuan-zu-jian-logback-pei-zhi-xiang-jie/logback.jpg" alt=""></p><h5 id="application-yml相关配置-只配置logback配置文件路径即可"><a href="#application-yml相关配置-只配置logback配置文件路径即可" class="headerlink" title="application.yml相关配置(只配置logback配置文件路径即可)"></a>application.yml相关配置(只配置logback配置文件路径即可)</h5><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">config</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>/logback/logback<span class="token punctuation">-</span>dev.xml</code></pre></li></ul></li></ol><h5 id="5-参考内容"><a href="#5-参考内容" class="headerlink" title="5. 参考内容"></a>5. 参考内容</h5><ul><li><a href="https://www.jianshu.com/p/04065d8cb2a9" target="_blank" rel="noopener">https://www.jianshu.com/p/04065d8cb2a9</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logback </tag>
            
            <tag> 日志管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：获取JVM的dump文件</title>
      <link href="/2020/03/17/java-huo-qu-jvm-de-dump-wen-jian/"/>
      <url>/2020/03/17/java-huo-qu-jvm-de-dump-wen-jian/</url>
      
        <content type="html"><![CDATA[<h4 id="获取JVM的dump文件的两种方式"><a href="#获取JVM的dump文件的两种方式" class="headerlink" title="获取JVM的dump文件的两种方式"></a>获取JVM的dump文件的两种方式</h4><ul><li><p>JVM启动时增加两个参数：</p><pre class=" language-shell"><code class="language-shell">#出现 OOME 时生成堆 dump: -XX:+HeapDumpOnOutOfMemoryError#生成堆文件地址：-XX:HeapDumpPath=/home/liuke/jvmlogs/</code></pre></li></ul><ul><li><p>发现程序异常前通过执行指令，直接生成当前JVM的dmp文件，6214是指JVM的进程号</p><pre class=" language-shell"><code class="language-shell">jmap -dump:format=b,file=serviceDump.dat 6214</code></pre><p>解析：</p><ul><li>第一种方式是一种事后方式，需要等待当前JVM出现问题后才能生成dmp文件，实时性不高。</li><li>第二种方式在执行时，JVM是暂停服务的，所以对线上的运行会产生影响，推荐使用第一种。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz：原理介绍与学习</title>
      <link href="/2020/03/16/quartz-yuan-li-jie-shao-yu-xue-xi/"/>
      <url>/2020/03/16/quartz-yuan-li-jie-shao-yu-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        最近公司业务需要引入定时任务，所以决定采用比较成熟的Quartz框架，在此进行整理学习。</p><p>​        Quartz是一个开源的定时调度框架，支持集群部署，可以和Spring进行集成，通过调用Java API来进行使用。</p><h4 id="1-Quartz简介"><a href="#1-Quartz简介" class="headerlink" title="1.Quartz简介"></a>1.Quartz简介</h4><h5 id="1-1-基本元素与关系"><a href="#1-1-基本元素与关系" class="headerlink" title="1.1 基本元素与关系"></a>1.1 基本元素与关系</h5><p>​    <strong>Quartz主要元素：</strong></p><ul><li><p><strong>Trigger</strong>：触发器，用来定义执行指定作业的计划</p></li><li><p><strong>Schedule</strong>：任务调度的控制器</p></li><li><p><strong>Job</strong>：元数据，指定作业</p><p>关系如下：</p><p><img src="/2020/03/16/quartz-yuan-li-jie-shao-yu-xue-xi/1584351179(1).png" alt=""></p></li></ul><h5 id="1-2-Trigger-触发器"><a href="#1-2-Trigger-触发器" class="headerlink" title="1.2 Trigger(触发器)"></a>1.2 Trigger(触发器)</h5><p>​        触发器用于定义任务调度的时间规则，比如每天、没小时，间隔多久等等。</p><p>​        最常用的两种触发器是：<strong>SimpleTrigger和CronTrigger</strong>,两者均继承了<strong>Trigger</strong>接口。</p><ul><li><p><strong>SimpleTrigger</strong></p><p>​        SimpleTrigger是一种最基本的触发器，唯一的实现类是SimpleTriggerImpl，指定从一个时间开始，以一定的时间间隔执行任务。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleTriggerImpl</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTrigger</span><span class="token operator">&lt;</span>SimpleTrigger<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">SimpleTrigger</span><span class="token punctuation">,</span> CoreTrigger <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>SimpleTrigger的实例一般通过TriggerBuilder来实例化，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建triggerBuilder,jobName为作业名，jobGroup为作业组名</span>TriggerBuilder triggerBuilder <span class="token operator">=</span> TriggerBuilder<span class="token punctuation">.</span><span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span>jobName<span class="token punctuation">,</span> jobGroup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设定触发器的调度规则，采用SimpleTrigger</span>SimpleScheduleBuilder ssb <span class="token operator">=</span> SimpleScheduleBuilder<span class="token punctuation">.</span><span class="token function">simpleSchedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设定trigger执行间隔时间为 jobObject.getIntervalInSeconds() 秒             </span>ssb <span class="token operator">=</span> ssb<span class="token punctuation">.</span><span class="token function">withIntervalInSeconds</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getIntervalInSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//入参</span>triggerBuilder<span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span>ssb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定开始执行时间</span>triggerBuilder<span class="token punctuation">.</span><span class="token function">startAt</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建trigger</span>Trigger trigger <span class="token operator">=</span> triggerBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>CronTrigger</strong></p><p>​    CronTrigger适用于复杂的时间表达式，即支持cron表达。其唯一的实现类为CronTriggerImpl。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CronTriggerImpl</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTrigger</span><span class="token operator">&lt;</span>CronTrigger<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">CronTrigger</span><span class="token punctuation">,</span> CoreTrigger <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>​    CronTrigger是实例化也要通过TriggerBuilder。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//同上</span>TriggerBuilder triggerBuilder <span class="token operator">=</span> TriggerBuilder<span class="token punctuation">.</span><span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span>jobName<span class="token punctuation">,</span> jobGroup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通过CronScheduleBuilder设置执行规则,采用CronTrigger，jobObject.getCron()为cron表达式</span>triggerBuilder<span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span>CronScheduleBuilder<span class="token punctuation">.</span><span class="token function">cronSchedule</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定开始执行时间</span>triggerBuilder<span class="token punctuation">.</span><span class="token function">startAt</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建trigger</span>Trigger trigger <span class="token operator">=</span> triggerBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h5 id="1-3-Job-元数据"><a href="#1-3-Job-元数据" class="headerlink" title="1.3 Job(元数据)"></a>1.3 Job(元数据)</h5><p>​        Job是一个接口，其内部只有一个execute()方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Job</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>JobExecutionContext var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> JobExecutionException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​        我们需要实现该接口，编写业务代码，指定定时所要处理的业务。</p><p>​        下面是几个常用的类：</p><ul><li><p><strong>JobDetail</strong>：任务细节，Quartz在执行Job时，需要创建Job实例，但是不能直接操作Job（接口）类，所以通过JobDetail来获取Job的名称、描述信息等。</p></li><li><p><strong>JobKey</strong>：作为JobDetail的标志类，JobDetail在创建时需要指定JobName和GroupName，该类的作用即用来存储这两个字段，作为JobDetail实例的标识ID，作为创建JobDetail的入参。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//jobObject为自建类</span>String jobName <span class="token operator">=</span> jobObject<span class="token punctuation">.</span><span class="token function">getJobName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String jobGroup <span class="token operator">=</span> jobObject<span class="token punctuation">.</span><span class="token function">getJobGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取实现了Job接口的类的class（我们要实现Job的那个类）</span>Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getJobHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建jobKey实例</span>JobKey jobKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JobKey</span><span class="token punctuation">(</span>jobName<span class="token punctuation">,</span> jobGroup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通过jobKey创建JobDetail</span>JobDetail jobDetail <span class="token operator">=</span> JobBuilder<span class="token punctuation">.</span><span class="token function">newJob</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span>jobKey<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h5 id="1-4-Schedule（任务调度）"><a href="#1-4-Schedule（任务调度）" class="headerlink" title="1.4 Schedule（任务调度）"></a>1.4 Schedule（任务调度）</h5><p>​        定时框架Quartz的核心概念，目的是将JobDetail和Trigger注册带scheduler中，保证定时任务的执行。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RootComponent</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SchedulerManager</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationListenerBase</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Spring注入SchedulerFactoryBean</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> SchedulerFactoryBean schedulerFactoryBean<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> Date <span class="token function">loadJob</span><span class="token punctuation">(</span>JobObject jobObject<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取Scheduler实例</span>        Scheduler scheduler <span class="token operator">=</span> schedulerFactoryBean<span class="token punctuation">.</span><span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">//指定Trigger和JobDetail进行注册    </span>        Date nextFireDate <span class="token operator">=</span> scheduler<span class="token punctuation">.</span><span class="token function">scheduleJob</span><span class="token punctuation">(</span>jobDetail<span class="token punctuation">,</span> trigger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nextFireDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-xml"><code class="language-xml">//Spring配置文件中指定Bean<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schedulerFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.scheduling.quartz.SchedulerFactoryBean<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h4 id="2-整合Maven依赖"><a href="#2-整合Maven依赖" class="headerlink" title="2. 整合Maven依赖"></a>2. 整合Maven依赖</h4><p>​    pom配置文件如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.quartz-scheduler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>quartz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.quartz-scheduler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>quartz-jobs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Quartz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 定时作业 </tag>
            
            <tag> Quartz </tag>
            
            <tag> 第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz：Spring的集成与实现</title>
      <link href="/2020/03/16/quartz-spring-de-ji-cheng-yu-shi-xian/"/>
      <url>/2020/03/16/quartz-spring-de-ji-cheng-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="1-代码"><a href="#1-代码" class="headerlink" title="1. 代码"></a>1. 代码</h3><p>​        本次Spring与Quatz的集成采用了<strong>模板设计模式</strong>，省略了大量的业务代码。maven的依赖包引入不再赘述。</p><h4 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h4><ul><li><strong>IJob：</strong>继承了<strong>Job</strong>接口，进行了自定义的扩展，方便在该层做一些所有Job实现类的共有操作。</li><li><strong>JobBase：</strong>实现了<strong>IJob</strong>接口。</li><li><strong>ScheduleManage：</strong>核心类，负责最终的定时加载和卸载。</li><li><strong>JobObject：</strong>自定义JobVo</li></ul><h4 id="1-2-逻辑代码"><a href="#1-2-逻辑代码" class="headerlink" title="1.2 逻辑代码"></a>1.2 逻辑代码</h4><ul><li><strong>IJob接口</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> codedriver<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>scheduler<span class="token punctuation">.</span>core<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>quartz<span class="token punctuation">.</span>Job<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>quartz<span class="token punctuation">.</span>JobExecutionContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>quartz<span class="token punctuation">.</span>JobExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ClassUtils<span class="token punctuation">;</span><span class="token keyword">import</span> codedriver<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>scheduler<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Param<span class="token punctuation">;</span><span class="token keyword">import</span> codedriver<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>scheduler<span class="token punctuation">.</span>dto<span class="token punctuation">.</span>JobObject<span class="token punctuation">;</span><span class="token keyword">import</span> codedriver<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>scheduler<span class="token punctuation">.</span>dto<span class="token punctuation">.</span>JobPropVo<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IJob</span> <span class="token keyword">extends</span> <span class="token class-name">Job</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">executeInternal</span><span class="token punctuation">(</span>JobExecutionContext context<span class="token punctuation">,</span> JobObject jobObject<span class="token punctuation">)</span> <span class="token keyword">throws</span> JobExecutionException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * @Description: 模块全路径     * @param @return     * @return Integer     */</span>    <span class="token keyword">public</span> <span class="token keyword">default</span> String <span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ClassUtils<span class="token punctuation">.</span><span class="token function">getUserClass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @Description: 拿到该实例     * @param @return     * @return IJob     */</span>    <span class="token keyword">public</span> <span class="token keyword">default</span> IJob <span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SchedulerManager<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @Description: 获取分组名称     * @param @return     * @return String     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> String <span class="token function">getGroupName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * @Description: 解析注解参数     * @Param: []     * @return: net.sf.json.JSONObject     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Param<span class="token operator">></span> <span class="token function">initProp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * @Description: 参数类型校验     * @Param: [jobPropVoList]     * @return: boolean     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">valid</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>JobPropVo<span class="token operator">></span> jobPropVoList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Boolean <span class="token function">checkCronIsExpired</span><span class="token punctuation">(</span>JobObject jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *      * @Description: 重新加载单个作业     * @param @param jobObject     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reloadJob</span><span class="token punctuation">(</span>JobObject jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * @Description: 加载当前类的租户作业     * @param tenantUuid     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initJob</span><span class="token punctuation">(</span>String tenantUuid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>JobBase</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 定时任务处理模块基类，所新增的定时任务类必须继承此类，新Job类必须实现接口内的2个方法。 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">JobBase</span> <span class="token keyword">implements</span> <span class="token class-name">IJob</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> SchedulerManager schedulerManager<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//抽象类无法实例化，通过静态属性注入</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">setSchedulerManager</span><span class="token punctuation">(</span>SchedulerManager schManager<span class="token punctuation">)</span> <span class="token punctuation">{</span>        schedulerManager <span class="token operator">=</span> schManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//顶层统一处理块</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>JobExecutionContext context<span class="token punctuation">)</span> <span class="token keyword">throws</span> JobExecutionException <span class="token punctuation">{</span>        JobDetail jobDetail <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JobObject jobObject <span class="token operator">=</span> <span class="token punctuation">(</span>JobObject<span class="token punctuation">)</span> jobDetail<span class="token punctuation">.</span><span class="token function">getJobDataMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"jobObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 检查作业是否需要重新加载</span>        IJob jobHandler <span class="token operator">=</span> SchedulerManager<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jobHandler <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插件不存在，则进行卸载</span>            schedulerManager<span class="token punctuation">.</span><span class="token function">unloadJob</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ScheduleHandlerNotFoundException</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getJobHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//检查表达式是否有效，则加载</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>jobHandler<span class="token punctuation">.</span><span class="token function">checkCronIsExpired</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            jobHandler<span class="token punctuation">.</span><span class="token function">reloadJob</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//开始执行，调用子模块的方法（模板设计模式）</span>            jobHandler<span class="token punctuation">.</span><span class="token function">executeInternal</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 主要定时方法实现区（不同子类的业务逻辑不同，其实现内容不同）     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">executeInternal</span><span class="token punctuation">(</span>JobExecutionContext context<span class="token punctuation">,</span> JobObject jobObject<span class="token punctuation">)</span> <span class="token keyword">throws</span> JobExecutionException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//参数验证</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">valid</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>JobPropVo<span class="token operator">></span> propVoList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//初始化参数</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Param<span class="token operator">></span> <span class="token function">initProp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Param<span class="token operator">></span> paramMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> paramMap<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>JobBaseImpl</strong></p></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProcessTaskSlaNotifyJob</span> <span class="token keyword">extends</span> <span class="token class-name">JobBase</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//自定义子模块的表达式校验</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Boolean <span class="token function">checkCronIsExpired</span><span class="token punctuation">(</span>JobObject jobObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//调用schedulerManager加载定数任务</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reloadJob</span><span class="token punctuation">(</span>JobObject jobObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Date triggerDate <span class="token operator">=</span> schedulerManager<span class="token punctuation">.</span><span class="token function">loadJob</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//自定义数据初始化</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initJob</span><span class="token punctuation">(</span>String tenantUuid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            JobObject jobObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JobObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reloadJob</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//自定义业务处理逻辑</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executeInternal</span><span class="token punctuation">(</span>JobExecutionContext context<span class="token punctuation">,</span> JobObject jobObject<span class="token punctuation">)</span> <span class="token keyword">throws</span> JobExecutionException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//业务逻辑处理</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义该组件组名</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getGroupName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> TenantContext<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTenantUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-PROCESSTASK-SLA-NOTIFY"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>ScheduleManager</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RootComponent</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SchedulerManager</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationListenerBase</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>SchedulerManager<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> IJob<span class="token operator">></span> jobHandlerMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> JobClassVo<span class="token operator">></span> jobClassMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>JobClassVo<span class="token operator">></span> publicJobClassList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> TenantMapper tenantMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> SchedulerFactoryBean schedulerFactoryBean<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>TenantVo<span class="token operator">></span> tenantList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">myInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tenantList <span class="token operator">=</span> tenantMapper<span class="token punctuation">.</span><span class="token function">getAllActiveTenant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> IJob <span class="token function">getHandler</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> jobHandlerMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>JobClassVo<span class="token operator">></span> <span class="token function">getAllPublicJobClassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> publicJobClassList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> JobClassVo <span class="token function">getJobClassByClassName</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        JobClassVo jobClassVo <span class="token operator">=</span> jobClassMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jobClassVo <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> TenantContext<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">containsModule</span><span class="token punctuation">(</span>jobClassVo<span class="token punctuation">.</span><span class="token function">getModuleId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> jobClassVo<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkJobIsExists</span><span class="token punctuation">(</span>String jobName<span class="token punctuation">,</span> String jobGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span>        JobKey jobKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JobKey</span><span class="token punctuation">(</span>jobName<span class="token punctuation">,</span> jobGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>        Scheduler scheduler <span class="token operator">=</span> schedulerFactoryBean<span class="token punctuation">.</span><span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduler<span class="token punctuation">.</span><span class="token function">getJobDetail</span><span class="token punctuation">(</span>jobKey<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SchedulerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *      * @Description: 加载定时作业     * @param jobObject     * @return void     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"rawtypes"</span><span class="token punctuation">,</span> <span class="token string">"unchecked"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Date <span class="token function">loadJob</span><span class="token punctuation">(</span>JobObject jobObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果结束时间比当前时间早，就不加载了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> jobObject<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            String jobName <span class="token operator">=</span> jobObject<span class="token punctuation">.</span><span class="token function">getJobName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String jobGroup <span class="token operator">=</span> jobObject<span class="token punctuation">.</span><span class="token function">getJobGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String className <span class="token operator">=</span> jobObject<span class="token punctuation">.</span><span class="token function">getJobHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            JobKey jobKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JobKey</span><span class="token punctuation">(</span>jobName<span class="token punctuation">,</span> jobGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>            Scheduler scheduler <span class="token operator">=</span> schedulerFactoryBean<span class="token punctuation">.</span><span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduler<span class="token punctuation">.</span><span class="token function">getJobDetail</span><span class="token punctuation">(</span>jobKey<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                scheduler<span class="token punctuation">.</span><span class="token function">deleteJob</span><span class="token punctuation">(</span>jobKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TriggerBuilder triggerBuilder <span class="token operator">=</span> TriggerBuilder<span class="token punctuation">.</span><span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span>jobName<span class="token punctuation">,</span> jobGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> CronExpression<span class="token punctuation">.</span><span class="token function">isValidExpression</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    triggerBuilder<span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span>CronScheduleBuilder<span class="token punctuation">.</span><span class="token function">cronSchedule</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getIntervalInSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> jobObject<span class="token punctuation">.</span><span class="token function">getIntervalInSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    SimpleScheduleBuilder ssb <span class="token operator">=</span> SimpleScheduleBuilder<span class="token punctuation">.</span><span class="token function">simpleSchedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ssb <span class="token operator">=</span> ssb<span class="token punctuation">.</span><span class="token function">withIntervalInSeconds</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getIntervalInSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    triggerBuilder<span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span>ssb<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                Date startTime <span class="token operator">=</span> jobObject<span class="token punctuation">.</span><span class="token function">getBeginTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>startTime <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> startTime<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    triggerBuilder<span class="token punctuation">.</span><span class="token function">startAt</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    triggerBuilder<span class="token punctuation">.</span><span class="token function">startNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                triggerBuilder<span class="token punctuation">.</span><span class="token function">endAt</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getEndTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Trigger trigger <span class="token operator">=</span> triggerBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getJobHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                JobDetail jobDetail <span class="token operator">=</span> JobBuilder<span class="token punctuation">.</span><span class="token function">newJob</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span>jobKey<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                jobDetail<span class="token punctuation">.</span><span class="token function">getJobDataMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"jobObject"</span><span class="token punctuation">,</span> jobObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                Date nextFireDate <span class="token operator">=</span> scheduler<span class="token punctuation">.</span><span class="token function">scheduleJob</span><span class="token punctuation">(</span>jobDetail<span class="token punctuation">,</span> trigger<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> nextFireDate<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *      * @Description: 将定时作业从调度器中删除     * @param jobObject 作业信息     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">unloadJob</span><span class="token punctuation">(</span>JobObject jobObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Scheduler scheduler <span class="token operator">=</span> schedulerFactoryBean<span class="token punctuation">.</span><span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            JobKey jobKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JobKey</span><span class="token punctuation">(</span>jobObject<span class="token punctuation">.</span><span class="token function">getJobName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> jobObject<span class="token punctuation">.</span><span class="token function">getJobGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduler<span class="token punctuation">.</span><span class="token function">getJobDetail</span><span class="token punctuation">(</span>jobKey<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                scheduler<span class="token punctuation">.</span><span class="token function">deleteJob</span><span class="token punctuation">(</span>jobKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SchedulerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>ContextRefreshedEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ApplicationContext context <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> IJob<span class="token operator">></span> myMap <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span>IJob<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>IJob<span class="token operator">></span> tmpJobHandlerList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> IJob<span class="token operator">></span> entry <span class="token operator">:</span> myMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            IJob job <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tmpJobHandlerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>            jobHandlerMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>            JobClassVo jobClassVo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JobClassVo</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jobClassMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> jobClassVo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//采用多线程执行业务逻辑代码</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>TenantVo tenantVo <span class="token operator">:</span> tenantList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            CachedThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ScheduleLoadJobRunner</span><span class="token punctuation">(</span>tenantVo<span class="token punctuation">.</span><span class="token function">getUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmpJobHandlerList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">ScheduleLoadJobRunner</span> <span class="token keyword">extends</span> <span class="token class-name">CodeDriverThread</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> String tenantUuid<span class="token punctuation">;</span>        <span class="token keyword">private</span> List<span class="token operator">&lt;</span>IJob<span class="token operator">></span> jobHandlerList<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">ScheduleLoadJobRunner</span><span class="token punctuation">(</span>String _tenantUuid<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>IJob<span class="token operator">></span> _jobHandlerList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tenantUuid <span class="token operator">=</span> _tenantUuid<span class="token punctuation">;</span>            jobHandlerList <span class="token operator">=</span> _jobHandlerList<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String oldThreadName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"SCHEDULE-JOB-LOADER-"</span> <span class="token operator">+</span> tenantUuid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 切换租户数据源</span>                TenantContext<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">switchTenant</span><span class="token punctuation">(</span>tenantUuid<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setUseDefaultDatasource</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>IJob jobHandler <span class="token operator">:</span> jobHandlerList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    jobHandler<span class="token punctuation">.</span><span class="token function">initJob</span><span class="token punctuation">(</span>tenantUuid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>oldThreadName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Quartz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 定时作业 </tag>
            
            <tag> Quartz </tag>
            
            <tag> 第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案：java实现ZIP、TAR边下载边打包</title>
      <link href="/2020/03/16/jie-jue-fang-an-java-shi-xian-zip-tar-bian-xia-zai-bian-da-bao/"/>
      <url>/2020/03/16/jie-jue-fang-an-java-shi-xian-zip-tar-bian-xia-zai-bian-da-bao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        前一段时间在负责做一个文件管理系统，用来存储系统产生的各种配置文件，在文件导出时，因涉及文件数目庞大，所以先进行打包，再进行下载的方式，会占用一定的磁盘空间，所以决定采用边下载边打包的方式来进行文件的压缩下载。</p><h3 id="2-TAR"><a href="#2-TAR" class="headerlink" title="2. TAR"></a>2. TAR</h3><h4 id="2-1-引入Maven依赖"><a href="#2-1-引入Maven依赖" class="headerlink" title="2.1 引入Maven依赖"></a>2.1 引入Maven依赖</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-csv<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-compress<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h4 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>comons<span class="token punctuation">.</span>compress<span class="token punctuation">.</span>archivers<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>TarArchiveEntry<span class="token punctuation">;</span>imort org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>compress<span class="token punctuation">.</span>archivers<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>TarArchiveOutputStream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Controller</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"tar/export/{}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tarExport</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span><span class="token keyword">throws</span> IOException<span class="token punctuation">{</span>        OutputStream os <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置打包的名称</span>        String tarName <span class="token operator">=</span> <span class="token string">"package.tar"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//所要打包的文件夹路径</span>        String packagePath <span class="token operator">=</span> <span class="token string">"       "</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"octets/stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String agent <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"USER-AGENT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"MSIE"</span><span class="token punctuation">)</span> <span class="token operator">||</span> agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"Trident"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                tarName <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encoder</span><span class="token punctuation">(</span>tarName<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                tarName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>tarName<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>UnsupportedEncodingException e<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//采用log4j进行日志输出</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>getMessage<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Disposition"</span><span class="token punctuation">,</span> <span class="token string">"attachment;fileName=\""</span> <span class="token operator">+</span> tarName <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TarArchiveOutputStream taos <span class="token operator">=</span> null<span class="token punctuation">;</span>        InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            taos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TarArchiveOutputStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> fileNameArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>packagePath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>String fileName <span class="token operator">:</span> fileNameArray<span class="token punctuation">)</span><span class="token punctuation">{</span>                File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>packagePath <span class="token operator">+</span> File<span class="token punctuation">.</span>separator <span class="token operator">+</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>                TarArchiveEntry entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TarArchiveEntry</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>                entry<span class="token punctuation">.</span><span class="token function">setSize</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                taos<span class="token punctuation">.</span><span class="token function">putArchiveEntry</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>                is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//这里采用IOUtils工具类，将输入流写到输出流中</span>                IOUtils<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> taos<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//inputStream创建于for循环内部，所以需要再循环结束时，将其关闭</span>                is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                taos<span class="token punctuation">.</span><span class="token function">closeArchiveEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>getMessage<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//推荐使用try-with-resource 方式进行连接的关闭</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>taos <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                taos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                taos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>os <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                os<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-ZIP"><a href="#3-ZIP" class="headerlink" title="3. ZIP"></a>3. ZIP</h3><p>​        java自身是支持zip类型的压缩下载，位于<strong>java.util.zip.ZipOuputStream</strong>中。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"zip/export/{}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">zipExport</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse reponse<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//zip包的名称</span>    String zipName <span class="token operator">=</span> <span class="token string">"package.zip"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//要打包的文件夹路径</span>    String packagePath <span class="token operator">=</span> <span class="token string">"   "</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"octets/stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String agent <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"USER-AGENT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"MSIE"</span><span class="token punctuation">)</span> <span class="token operator">||</span> agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"Trident"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            zipName <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>zipName<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            zipName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>zipName<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span>， “ISO<span class="token operator">-</span><span class="token number">8859</span><span class="token operator">-</span><span class="token number">1</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>UnsupportedEncodingException e<span class="token punctuation">)</span><span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Disposition"</span><span class="token punctuation">,</span> <span class="token string">"attachment;fileName=\""</span> <span class="token operator">+</span> zipName <span class="token operator">+</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ZipOutputStream zipos <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>            zipos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            zipos<span class="token punctuation">.</span><span class="token function">setMethod</span><span class="token punctuation">(</span>ZipOutputStream<span class="token punctuation">.</span>DEFLATED<span class="token punctuation">)</span><span class="token punctuation">;</span>            zipos<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        DataOutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>        InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> fileNameList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fileNameList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>packagePath<span class="token operator">+</span> File<span class="token punctuation">.</span>separator <span class="token operator">+</span> fileNameList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    zipos<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>fileNameList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>zipos<span class="token punctuation">)</span><span class="token punctuation">;</span>                    is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//输入流转换为输出流</span>                    IOUtils<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> os<span class="token punctuation">)</span><span class="token punctuation">;</span>                    is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    zipos<span class="token punctuation">.</span><span class="token function">closeEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 推荐使用try-with-resource</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>os <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                os<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>zipos <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                zipos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                zipos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> I/O流 </tag>
            
            <tag> ZIP </tag>
            
            <tag> TAR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案：高并发下的接口幂等性</title>
      <link href="/2020/03/13/jie-jue-fang-an-gao-bing-fa-xia-de-jie-kou-mi-deng-xing/"/>
      <url>/2020/03/13/jie-jue-fang-an-gao-bing-fa-xia-de-jie-kou-mi-deng-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        幂等性操作的特点是<strong>任意多次执行所产生的影响均与一次执行的影响相同。</strong>即函数的重复操作对于系统的改变只生效一次。像查询就是天然的幂等性操作，无论查询函数执行多少次，结果都是一致，都不会对系统造成改变和影响。删除操作，多次删除，只会生效一次，尽管返回的结果可能不尽相同。</p><h3 id="2-幂等性实现方式"><a href="#2-幂等性实现方式" class="headerlink" title="2. 幂等性实现方式"></a>2. 幂等性实现方式</h3><h4 id="2-1-Token机制"><a href="#2-1-Token机制" class="headerlink" title="2.1  Token机制"></a>2.1  Token机制</h4><p>​    原理图如下：</p><p>​        <img src="/2020/03/13/jie-jue-fang-an-gao-bing-fa-xia-de-jie-kou-mi-deng-xing/image-20200312163120015.png" style="zoom: 67%;"></p><p>主要流程为：</p><ul><li><p>客户端向服务端请求token </p></li><li><p>服务端产生token之后发送给客户端，并且将token进行缓存</p></li><li><p>客户端发起服务请求，并带上token</p></li><li><p>服务端根据token在缓存中查找，若存在，代表客户端为第一次请求，处理业务逻辑后，将缓存的token进行移除。若不存在，这说明客户端为重复调用请求，则不作任何业务处理。</p><p><strong>这样通过token就可以保证客户端的多次重复请求在后端只会执行一次。</strong></p><p>缺点：要保证接口幂等性，需要每次都要从后端获取token.</p></li></ul><h4 id="2-2-数据库去重表"><a href="#2-2-数据库去重表" class="headerlink" title="2.2 数据库去重表"></a>2.2 数据库去重表</h4><p>​        核心思路是<strong>去重表插入数据时，利用数据库的唯一索引特性，保证唯一的数据逻辑。</strong></p><p>​        数据库防重表的缺点是，系统的容错性不高，数据库或服务器连接异常，均会导致整个系统幂等性校验出问题。</p><p>​        缺点：无法适用于分布式存储系统，需要维护数据库的唯一索引，多的情况不易管理</p><h4 id="2-3-Redis实现"><a href="#2-3-Redis实现" class="headerlink" title="2.3 Redis实现"></a>2.3 Redis实现</h4><p>​        使用Redis作为缓存来实现的唯一方式是将数据的唯一序列号作为key值，将数据存储于缓存之中，并且需要设置过期时间，防止Redis中积累太多无用的数据。</p><h4 id="2-4-状态机"><a href="#2-4-状态机" class="headerlink" title="2.4 状态机"></a>2.4 状态机</h4><p>​        所谓的状态机是指，在业务流转执行的过程中，每个业务请求除了带有现在的状态，并且还带有自身所要流转的变更图。这样在业务执行的过程中，需要进行判断当前业务处理时的前置条件是否都成立，若成立才进行执行操作，否则拒绝操作。</p><h4 id="2-5-MVCC机制"><a href="#2-5-MVCC机制" class="headerlink" title="2.5 MVCC机制"></a>2.5 MVCC机制</h4><p>​        多版本并发控制，在数据更新时需要比较持有数据的版本号，版本号不一致的操作无法更新，更新成功后版本号将会发生变化。</p><p>​        缺点：只适用于更新接口</p><h4 id="2-6-select-insert"><a href="#2-6-select-insert" class="headerlink" title="2.6 select + insert"></a>2.6 select + insert</h4><p>​        该方案的解决思路是，在执行操作之前，先判断操作是否已经发生过，常与业务强关联，所以校验通常在参数校验上。</p><p>​        缺点：针对并发所产生的脏数据问题，无法解决。</p><h4 id="2-7-分布式锁"><a href="#2-7-分布式锁" class="headerlink" title="2.7 分布式锁"></a>2.7 分布式锁</h4><p>​        分布式系统下，难以构建全局的唯一索引，可以通过类似多线程下的锁一样，采用分布式锁，即操作执行之前先获取分布式锁，操作完成之后再将锁进行释放。</p><p>缺点：需配合 select+insert 使用，如果不配合，无法解决表单重复提交的问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂等性 </tag>
            
            <tag> 接口设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：阻塞</title>
      <link href="/2020/03/12/redis-zu-sai/"/>
      <url>/2020/03/12/redis-zu-sai/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        Redis是单线程架构，一旦发生阻塞，所造成的的问题将会很严重，阻塞一般可归于两大类：</p><ul><li><strong>内因：不合理的API或数据结构、CPU饱和，持久化阻塞等</strong></li><li><strong>外因：CPU竞争、内存交换，网络问题</strong></li></ul><h3 id="2-内在原因"><a href="#2-内在原因" class="headerlink" title="2. 内在原因"></a>2. 内在原因</h3><h4 id="2-1-API或数据结构不合理"><a href="#2-1-API或数据结构不合理" class="headerlink" title="2.1 API或数据结构不合理"></a>2.1 API或数据结构不合理</h4><ul><li><p><strong>慢查询诊断与处理</strong></p><ul><li>执行showlog get{n}命令获取最近的n条慢查询命令。</li><li>处理方式：<ul><li>修改为低算法度的命令，如hgetall改为hmget，禁用keys.sort等。</li><li>调整大对象，将大对象数据进行分拆，为多个小对象。</li></ul></li></ul></li><li><p><strong>大对象诊断</strong></p><ul><li><p>调用 redis-cli-h{ip}-p{port} bigkeys</p><pre class=" language-shell"><code class="language-shell">redis-cli --bigkeys</code></pre></li></ul></li></ul><h4 id="2-2-CPU饱和"><a href="#2-2-CPU饱和" class="headerlink" title="2.2 CPU饱和"></a>2.2 CPU饱和</h4><p>​        单线程redis处理命令只能使用一个CPU。</p><pre class=" language-shell"><code class="language-shell">redis-cli --stat  #统计命令获取当前Redis使用情况</code></pre><h4 id="2-3-持久化阻塞"><a href="#2-3-持久化阻塞" class="headerlink" title="2.3 持久化阻塞"></a>2.3 持久化阻塞</h4><p>​        持久化引起的主线程阻塞主要有三种：</p><ol><li><p><strong>fork阻塞</strong></p><p>​        fork操作发生在RDB和AOF重写时，主线会调用fork操作来产生共享内存的子线程，子线程来负责进行持久化文件重写工作。fork操作执行时间过长便会造成阻塞。</p><pre class=" language-shell"><code class="language-shell">info stats #查看latest_fork_usec指标 表示一次fork操作耗时</code></pre></li></ol><ol start="2"><li><p><strong>AOF刷盘阻塞</strong></p><p>​        开启AOF时，文件刷盘每秒执行一次，后台线程做fsync操作。主机如果发现fsync用时超过2s，会阻塞进行等待fsync的完成。这种阻塞主要是硬盘压力引起的。</p><pre class=" language-shell"><code class="language-shell">info persistence #查看aof_delayed_fsync指标 每次发送阻塞主线程时，都会增加</code></pre></li></ol><ol start="3"><li><p><strong>HugePage写操作阻塞</strong></p><p>​    子进程在执行重写期间利用linux写时复制技术降低内存开销，因此只有写操作时Redis才复制要修改的内存页。</p></li></ol><h3 id="3-外在原因"><a href="#3-外在原因" class="headerlink" title="3.外在原因"></a>3.外在原因</h3><h4 id="3-1-CPU竞争"><a href="#3-1-CPU竞争" class="headerlink" title="3.1 CPU竞争"></a>3.1 CPU竞争</h4><ul><li><strong>进程竞争</strong>：Redis不建议和其他多核CPU密集型服务一起部署，其他进程过度消耗CPU时，将严重影响Redis吞吐量。</li><li><strong>绑定CPU</strong>：绑定CPU可以减少CPU切换的开销，但当子进程进行RDB/AOF重写时，会和父进程争夺CPU，影响Redis稳定性，参与复制或开启持久化的主节点不建议绑定CPU.</li></ul><h4 id="3-2-内存交换"><a href="#3-2-内存交换" class="headerlink" title="3.2 内存交换"></a>3.2 内存交换</h4><p>​        操作系统可能会将Redis使用的部分内存换到硬盘，导致性能会急剧下降。</p><p>​        预防内存交换的方法：</p><ul><li>保证机器充足的可用内存</li><li>确保Redis实例设置最大可用内存</li><li>降低系统使用swap优先级</li></ul><h4 id="3-3-网络问题"><a href="#3-3-网络问题" class="headerlink" title="3.3 网络问题"></a>3.3 网络问题</h4><ul><li><p>连接拒绝</p><ul><li><p>网络闪断</p></li><li><p>Redis连接拒绝</p><pre class=" language-shell"><code class="language-shell">info stats #rejected_connections查看统计指标记录所有被拒绝连接的数量</code></pre></li><li><p>连接溢出</p><ul><li>进程限制</li><li>backlog队列溢出</li></ul></li><li><p>网络延迟</p></li><li><p>网卡中断</p></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：哨兵</title>
      <link href="/2020/03/11/redis-shao-bing/"/>
      <url>/2020/03/11/redis-shao-bing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        <strong>Redis</strong>从2.8开始正式推出了<strong>Redis Sentinel（哨兵）</strong>架构，目的是解决主从复制模式下，主节点一旦发生事故，需要<strong>人工将从节点进行晋升，并且还需通知应用方更新主节点地址</strong>这一问题。</p><h3 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2. 主从复制"></a>2. 主从复制</h3><h4 id="2-1-节点作用"><a href="#2-1-节点作用" class="headerlink" title="2.1 节点作用"></a>2.1 节点作用</h4><p>​        在主从复制中，从节点起两种作用：</p><ul><li><p>作为主节点备份，随时顶替主节点，保证数据不丢失。</p></li><li><p>扩展主节点读能力，并发读场景，可减轻主节点压力。</p><h4 id="2-2-存在问题"><a href="#2-2-存在问题" class="headerlink" title="2.2 存在问题"></a>2.2 存在问题</h4><p>主从复制存在的问题：</p></li><li><p>主节点故障不可达，需人工干预</p></li><li><p>应用方无法感知主节点的变化，造成写数据丢失和读数据错误，甚至服务不可用。</p><h4 id="2-3-故障转移"><a href="#2-3-故障转移" class="headerlink" title="2.3 故障转移"></a>2.3 故障转移</h4><p>主从复制模式下故障转移步骤如下：</p><ol><li>主节点故障，与客户端、从节点连接失败。</li><li>若主节点无法正常启动，选从节点，执行slaveof no one成为新主节点。</li><li>从节点变为主节点，更新应用方主节点信息。</li><li>客户端命令从节点去复制新主节点。</li><li>待主节点恢复，去复制新主节点。</li></ol></li></ul><h3 id="3-Redis-Sentinel（哨兵）"><a href="#3-Redis-Sentinel（哨兵）" class="headerlink" title="3. Redis Sentinel（哨兵）"></a>3. Redis Sentinel（哨兵）</h3><p>​        Redis Sentinel 是一个分布式架构，包含若干Sentinel节点和Redis数据节点，每个Sentinel节点会对其他的Sentinel节点和Redis数据节点进行监控，当不可达时，做下线标记。</p><p>​        当Redis数据主节点被标记时，其他的Sentinel节点会协商选出一个Sentinel节点来进行故障迁移工作，同时通知变化给Redis应用方，全程自动，不需人工干预。其结构拓扑图大致如下：</p><p>​                              <img src="/2020/03/11/redis-shao-bing/image-20200311150749964.png" style="zoom:67%;"></p><p>​        故障迁移四个步骤如下：</p><ol><li><p>主节点master出现故障，与从节点失去联系，主从复制失败。</p></li><li><p>每个Sentinel通过定期监控发现主节点故障。</p></li><li><p>多个Sentinel节点对主节点的故障达成一致，选举Sentinel负责故障迁移。</p></li><li><p>Sentinel完成故障迁移。</p></li><li><p>通知Redis应用方。</p><p>Sentinel的功能如下：</p></li></ol><ul><li><strong>监控</strong>：定期检查Redis节点和其他Sentinel节点</li><li><strong>通知</strong>：结果通知应用方</li><li><strong>主节点故障转移</strong></li><li><strong>配置提供者</strong>：客户端连接Sentinel节点集合，从中获取主节点信息。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：缓存设计</title>
      <link href="/2020/03/11/redis-huan-cun-she-ji/"/>
      <url>/2020/03/11/redis-huan-cun-she-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        缓存通常都是全内存的，因而可以有效的加快读写，优化用户体验。并且能减少后端的数据访问量和访问次数，有效降低后端负载。</p><p>​        但加入缓存也有一定成本：</p><ul><li><p><strong>数据不一致性</strong>：缓存数据和后端数据存在一定的时间窗口，可能导致数据在一定时间窗口内有差异。</p></li><li><p><strong>代码维护成本</strong></p></li><li><p><strong>运维成本</strong></p><p>使用场景一般为：<strong>开销大的复杂计算（大量联表查询）</strong>、<strong>加速请求响应</strong>。</p></li></ul><h3 id="2-更新策略"><a href="#2-更新策略" class="headerlink" title="2. 更新策略"></a>2. 更新策略</h3><p>​        更新策略大致包括三种：</p><ul><li><p><strong>LRU/LFU/FIFO算法剔除</strong></p><ul><li>场景：缓存使用量超过预设的最大值</li><li>方式：使用<strong>maxmemory-policy</strong>配置内存到达阈值后的剔除策略</li><li>一致性：清除数据由算法确定，因算法固定，一致性差。</li></ul></li><li><p><strong>超时剔除</strong></p><ul><li>场景：会给数据设置过期时间，过期自动删除。</li><li>方式：<strong>expire</strong> 命令可能导致一定时间内缓存数据和存储数据不一致。</li><li>一致性：一定时间窗口存在数据一致性问题。</li></ul></li><li><p><strong>主动更新</strong></p><ul><li><p>场景：数据一致性要求高，真实数据更新后，缓存立即更新。</p></li><li><p>方式：消息系统或其他方式通知更新。</p></li><li><p>一致性：一致性最高，最好配合超时更新一块使用，防止主动更新出错。</p><p>三种对比图如下：</p><p><img src="/2020/03/11/redis-huan-cun-she-ji/image-20200311104034977.png" alt="更新策略对比"></p><p>因而<strong>低一致性业务</strong>推荐配置最大内存+淘汰策略，<strong>高一致性业务</strong>推荐超时剔除+主动更新</p></li></ul></li></ul><h3 id="3-缓存粒度"><a href="#3-缓存粒度" class="headerlink" title="3. 缓存粒度"></a>3. 缓存粒度</h3><p>​        在使用缓存过程中，需要去判断需要缓存那些数据。即缓存所有字段 还是缓存必须字段数据等等，考虑因素主要有三点：</p><ul><li><strong>通用性</strong>：全数据比部分数据通用，但基本只用部分数据。</li><li><strong>空间占用</strong>：全部数据内存大、网络流量大以及序列化和反序列化CPU开销更大。</li><li><strong>代码维护</strong>：全部数据更方便，部分数据会涉及源码修改。</li></ul><p>三种要素对比如下，视业务均衡取舍：</p><p><img src="/2020/03/11/redis-huan-cun-she-ji/image-20200311110701013.png" alt="缓存粒度的解决方案对比"></p><h3 id="4-问题优化"><a href="#4-问题优化" class="headerlink" title="4. 问题优化"></a>4. 问题优化</h3><p>​        在使用缓存中，常会出现一些问题，除了代码逻辑外，大致包括如下：</p><ul><li><strong>缓存穿透</strong>：查询一个不存在数据，缓存和存储层均为命中。导致查询不存在的数据时会访问存储层，失去缓存保护存储层的意义，<strong>会加大后端存储负载</strong>。</li><li><strong>无底洞</strong></li><li><strong>缓存雪崩</strong></li><li><strong>热点key重建</strong></li></ul><h4 id="4-1-缓存穿透"><a href="#4-1-缓存穿透" class="headerlink" title="4.1 缓存穿透"></a>4.1 缓存穿透</h4><p>​    出现的基本原因如下：</p><ul><li><p>自身业务代码或数据出现问题。</p></li><li><p>恶意攻击、爬虫造成大量空命中。</p><p>解决方案：</p><ol><li><p><strong>缓存空对象</strong></p><p>当存储层未命中后，保留空对象到缓存中，并设置较短过期时间，自动剔除。</p></li><li><p><strong>布隆过滤拦截</strong></p><p>在访问缓存和存储层之前，将存在的key用布隆过滤器提前保存起来，作为第一层拦截。</p></li></ol><p>两种方案分析如下：</p><p><img src="/2020/03/11/redis-huan-cun-she-ji/image-20200311112639829.png" alt="缓存穿透的解决方案对比"></p></li></ul><h4 id="4-2-无底洞"><a href="#4-2-无底洞" class="headerlink" title="4.2 无底洞"></a>4.2 无底洞</h4><p>​        无底洞的意思是，<strong>更多的节点不代表更多的性能</strong>，因为批量操作会涉及多次网络操作，分布式情况下，节点增多意味着网络耗时的增加。</p><p>​        批量操作方式：</p><ul><li><p><strong>串行命令</strong>：n次网络 + n次命令</p></li><li><p><strong>串行IO</strong>： n次网络（node的个数） + n次命令</p></li><li><p><strong>并行IO</strong>：将串行IO的命令改为多线程即n次网络（node的个数） + 1次命令</p></li><li><p><strong>hash_tag</strong> 强制将多个key分配到一个节点上，即1次网络 + n次命令</p><p>四张方式的对比如下：</p><p><img src="/2020/03/11/redis-huan-cun-she-ji/image-20200311114132417.png" alt="无底洞的解决方案对比"></p></li></ul><h4 id="4-3-缓存雪崩"><a href="#4-3-缓存雪崩" class="headerlink" title="4.3 缓存雪崩"></a>4.3 缓存雪崩</h4><p>​        缓存层由于某些原因不能提供服务，大量请求将会到达存储层，导致存储层崩溃。</p><p>​        预防缓存雪崩的三点方式：</p><ul><li><strong>保证缓存层服务高可用性</strong></li><li><strong>依赖隔离组件为后端限流并降级</strong></li><li><strong>提前演练</strong></li></ul><h4 id="4-4-热点key重建"><a href="#4-4-热点key重建" class="headerlink" title="4.4 热点key重建"></a>4.4 热点key重建</h4><p>​        当某个数据的key的并发量非常大时，通常采用的“缓存+过期时间”模式，可能导致重建缓存难以在短时间内完成，大量线程重建缓存造成后端负载加大，甚至应用崩溃。</p><p>​        解决方案：</p><ol><li><p><strong>互斥锁</strong>：只允许一个线程重建缓存，其他线程等待，完成后从缓存中获取数据。</p></li><li><p><strong>永远不过期</strong>：即不设置key的过期时间，或者为value设置过期时间，当超过过期时间时，线程进行重建。</p><p>两种方式比较如下：</p><p><img src="/2020/03/11/redis-huan-cun-she-ji/image-20200311120348107.png" alt="热点key的解决方案对比"></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案：Spring动态数据源管理</title>
      <link href="/2020/03/07/jie-jue-fang-an-spring-dong-tai-shu-ju-yuan-guan-li/"/>
      <url>/2020/03/07/jie-jue-fang-an-spring-dong-tai-shu-ju-yuan-guan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        公司最近搞的新项目SaaS层需要实现多租户功能，因租户都有各自的数据库。所以无论是从实现读写分离角度，还是租户管理，都需要进行动态数据源的切换，所以考虑使用Spring的数据管理方案来解决实现，在此进行整理学习。</p><h3 id="2-原理解析"><a href="#2-原理解析" class="headerlink" title="2.原理解析"></a>2.原理解析</h3><p>​        数据源管理中，涉及两个需要解决的问题：</p><ul><li><p>多数据源切换：项目所需要的不止一个数据库的连接信息，比如同一数据库地址下的不同库等。</p></li><li><p>动态加载：指项目在启动时，并没有加载到数据库的连接信息，只有在项目运行时，依据业务需求才进行数据源的添加。</p><h4 id="2-1-多数据源切换"><a href="#2-1-多数据源切换" class="headerlink" title="2.1 多数据源切换"></a>2.1 多数据源切换</h4><p>​        Spring进行数据源管理的核心类是： <strong>AbstractRoutingDataSource</strong></p><p> 源码解析如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractRoutingDataSource</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractDataSource</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//targetDataSource 暴露给外部，用于进行赋值,存储数据源集合</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> targetDataSources<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置默认的数据源</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">private</span> Object defaultTargetDataSource<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> lenientFallback <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> DataSourceLookup dataSourceLookup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JndiDataSourceLookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> DataSource<span class="token operator">></span> resolvedDataSources<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">private</span> DataSource resolvedDefaultDataSource<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">AbstractRoutingDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//设置数据源集合</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTargetDataSources</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> targetDataSources<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>targetDataSources <span class="token operator">=</span> targetDataSources<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDefaultTargetDataSource</span><span class="token punctuation">(</span>Object defaultTargetDataSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>defaultTargetDataSource <span class="token operator">=</span> defaultTargetDataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLenientFallback</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> lenientFallback<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lenientFallback <span class="token operator">=</span> lenientFallback<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDataSourceLookup</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> DataSourceLookup dataSourceLookup<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dataSourceLookup <span class="token operator">=</span> <span class="token punctuation">(</span>DataSourceLookup<span class="token punctuation">)</span><span class="token punctuation">(</span>dataSourceLookup <span class="token operator">!=</span> null <span class="token operator">?</span> dataSourceLookup <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">JndiDataSourceLookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//初始化的时候会调用该方法，去解析我们的数据源集合targetDataSources,然后put到resolveDataSources中</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>targetDataSources <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Property 'targetDataSources' is required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedDataSources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>targetDataSources<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>targetDataSources<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                Object lookupKey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveSpecifiedLookupKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                DataSource dataSource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveSpecifiedDataSource</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedDataSources<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>lookupKey<span class="token punctuation">,</span> dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultTargetDataSource <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedDefaultDataSource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveSpecifiedDataSource</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultTargetDataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Object <span class="token function">resolveSpecifiedLookupKey</span><span class="token punctuation">(</span>Object lookupKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> lookupKey<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> DataSource <span class="token function">resolveSpecifiedDataSource</span><span class="token punctuation">(</span>Object dataSource<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalArgumentException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dataSource <span class="token keyword">instanceof</span> <span class="token class-name">DataSource</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>DataSource<span class="token punctuation">)</span>dataSource<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dataSource <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dataSourceLookup<span class="token punctuation">.</span><span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal data source value - only [javax.sql.DataSource] and String supported: "</span> <span class="token operator">+</span> dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineTargetDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取数据源连接，determineTargetDataSource的解析如下：</span>    <span class="token keyword">public</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span>String username<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineTargetDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">unwrap</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> iface<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        <span class="token keyword">return</span> iface<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineTargetDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span>iface<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isWrapperFor</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> iface<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        <span class="token keyword">return</span> iface<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineTargetDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isWrapperFor</span><span class="token punctuation">(</span>iface<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//通过我们需要实现的determineCurrentLookUpKey(),返回一个Key值，然后从resolvedDataSources中get到一个数据源，本质就是我们设置的targetDataSources中获取一个数据源</span>    <span class="token keyword">protected</span> DataSource <span class="token function">determineTargetDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolvedDataSources<span class="token punctuation">,</span> <span class="token string">"DataSource router not initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object lookupKey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineCurrentLookupKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DataSource dataSource <span class="token operator">=</span> <span class="token punctuation">(</span>DataSource<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolvedDataSources<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lookupKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dataSource <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lenientFallback <span class="token operator">||</span> lookupKey <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dataSource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedDefaultDataSource<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dataSource <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Cannot determine target DataSource for lookup key ["</span> <span class="token operator">+</span> lookupKey <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//我们需要实现并指定key类型,通过key将决定是用哪一个数据源</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> Object <span class="token function">determineCurrentLookupKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>总结一下：</p><ol><li><p>编写新类继承抽象类<strong>AbstractRoutingDataSource</strong>，实现determineCurrentLookupKey()方法，指定key的类型。</p></li><li><p>项目启动时，拿到所有的数据源信息，以key做键，数据源做值，使用Map进行存储。</p></li><li><p>引入新类的实现，调用setTargetDataSources()方法，将Map赋值给新类。</p></li><li><p>调用setDefaultTargetDataSource(),指定默认的数据源</p></li><li><p>调用afterPropertiesSet(),将赋值的数据进行加载。</p><p>通过以上方式，便可以实现通过指定key实现数据源之间的切换。</p></li></ol></li></ul><h4 id="2-2-动态加载"><a href="#2-2-动态加载" class="headerlink" title="2.2 动态加载"></a>2.2 动态加载</h4><p>​        动态加载的原理就是拿到数据源的集合，将新的数据源添加到其中，并重新赋值给新类的实现类，并进行初始化，即：</p><ol><li>拿到数据源集合，将新的数据源添加到其中。</li><li>重复上述的2,3,4,5步骤。</li></ol><h3 id="3-读写分离的实现"><a href="#3-读写分离的实现" class="headerlink" title="3 读写分离的实现"></a>3 读写分离的实现</h3><p>​        读写分离的代码实现思路如下：</p><ul><li><p>编写新类继承抽象类，重写方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDataSource</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractRoutingDataSource</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>      <span class="token keyword">protected</span> Object <span class="token function">determineCurrentLookupKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> DataSourceContextHolder<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>编写启动类进行预先加载数据源</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DatasourceInitializer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> DatasourceMapper datasourceMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> DynamicDataSource datasource<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> DynamicDataSource instance<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//注入读的数据源信息</span>    <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"dataSourceRead"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> CodeDriverBasicDataSource readDatasource<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> datasourceMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//项目启动加载</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//拿到数据库中存储的数据源信息（写的数据源信息）</span>        List<span class="token operator">&lt;</span>DatasourceVo<span class="token operator">></span> datasourceList <span class="token operator">=</span>               datasourceMapper<span class="token punctuation">.</span><span class="token function">getAllActiveTenantDatasource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datasourceMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_READ<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            datasourceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_READ<span class="token punctuation">,</span>     readDatasource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//遍历数据源信息，封装进Map</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>DatasourceVo datasourceVo <span class="token operator">:</span> datasourceList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datasourceMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>datasourceVo<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//采用的是DBCP的连接方式，该类继承了BasicDataSource类</span>                CodeDriverBasicDataSource source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CodeDriverBasicDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                source<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span>datasourceVo<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              source<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span>datasourceVo<span class="token punctuation">.</span><span class="token function">getDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                source<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>datasourceVo<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                source<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>datasourceVo<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                datasourceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>datasourceVo<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> datasource <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            instance <span class="token operator">=</span> datasource<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datasourceMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//设定数据源集合</span>            datasource<span class="token punctuation">.</span><span class="token function">setTargetDataSources</span><span class="token punctuation">(</span>datasourceMap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设定默认的数据源（读数据源）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>datasourceMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_READ<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                datasource<span class="token punctuation">.</span><span class="token function">setDefaultTargetDataSource</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//将数据源进行加载</span>            datasource<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//动态加载数据源</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addDynamicDataSource</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> CodeDriverBasicDataSource codeDriverBasicDataSource<span class="token punctuation">)</span><span class="token punctuation">{</span>            datasourceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> codeDriverBasicDataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>            instance<span class="token punctuation">.</span><span class="token function">setTargetDataSources</span><span class="token punctuation">(</span>datasourceMap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>datasourceMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_READ<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            instance<span class="token punctuation">.</span><span class="token function">setDefaultTargetDataSource</span><span class="token punctuation">(</span>datasourceMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_READ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            instance<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre></li><li><p>编写存放Key的地方DataSourceContextHolder，为保证线程安全，采用ThreadLocal来进行key的存储。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSourceContextHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOGGER <span class="token operator">=</span>     LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DATA_SOURCE_WRITE <span class="token operator">=</span> <span class="token string">"WRITE"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DATA_SOURCE_READ <span class="token operator">=</span> <span class="token string">"READ"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 线程本地环境</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> contextHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置数据源类型，通过调用该方法，实现不同数据源之间的切换</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setType</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>LOGGER<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            LOGGER<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"==============切换数据源，类型："</span><span class="token operator">+</span>type<span class="token operator">+</span><span class="token string">"================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        contextHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取数据源类型</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>contextHolder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清除数据源类型</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">clearType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        contextHolder<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上就是动态数据源切换和数据源加载的实现方式，但手动进行数据源的切换存在不便性，我们可以通过Spring的AOP方式，实现自动切换。</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDataSourceAspect</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution (* com.potato.orm.mapper.*.select*(..)) || execution (* com.potato.orm.mapper.*.count*(..)) "</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readMethodPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution (* com.potato.orm.mapper.*.insert*(..)) || execution (* com.potato.orm.mapper.*.update*(..)) || execution (* com.potato.orm.mapper.*.delete*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeMethodPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"readMethodPointcut()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">switchReadDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//System.out.println("============切换到读数据源===========");</span>        DataSourceContextHolder<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"writeMethodPointcut()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">switchWriteDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//System.out.println("=============切换到写数据源==========");</span>        DataSourceContextHolder<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span>DataSourceContextHolder<span class="token punctuation">.</span>DATA_SOURCE_WRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样就实现了数据源之间的自动切换。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 数据源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：SQL脚本执行 ScriptRunner</title>
      <link href="/2020/03/01/java-sql-jiao-ben-zhi-xing-scriptrunner/"/>
      <url>/2020/03/01/java-sql-jiao-ben-zhi-xing-scriptrunner/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        最近公司在搞SaaS,涉及到多租户问题，包括租户保存时，需要为租户单独建立新的数据库，其中需要进行数据表的拷贝，公司使用mysql数据库，并且不包含存储过程等其他东西，仅仅是表的结构拷贝。因而最终采用Mybatis包中的ScriptRunner进行SQL脚本的执行，实现数据库的复制操作。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class=" language-java"><code class="language-java">         <span class="token comment" spellcheck="true">//这里采用了Spring的多数据源管理方案，CodeDriverBasicDataSource继承了BasicDataSource</span>         CodeDriverBasicDataSource tenantDatasource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CodeDriverBasicDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tenantDatasource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token function">getTenantUrl</span><span class="token punctuation">(</span>tenantVo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tenantDatasource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span>tenantVo<span class="token punctuation">.</span><span class="token function">getDataSourceParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tenantDatasource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>tenantVo<span class="token punctuation">.</span><span class="token function">getDataSourceParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tenantDatasource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>tenantVo<span class="token punctuation">.</span><span class="token function">getDataSourceParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将租户数据源加入到Spring的数据源管理列表中</span>        DatasourceInitializer<span class="token punctuation">.</span><span class="token function">addDynamicDataSource</span><span class="token punctuation">(</span>tenantVo<span class="token punctuation">.</span><span class="token function">getUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tenantDatasource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//切换到指定租户</span>        TenantContext<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>tenantVo<span class="token punctuation">.</span><span class="token function">getUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//正文</span>        <span class="token comment" spellcheck="true">//获取当前租户数据库连接，（也可以使用JDBC指定url,driver.password,username来创建连接）</span>        Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            conn <span class="token operator">=</span> tenantDatasource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ScriptRunner runner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptRunner</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>            runner<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            runner<span class="token punctuation">.</span><span class="token function">setStopOnError</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Resources<span class="token punctuation">.</span><span class="token function">setCharset</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            runner<span class="token punctuation">.</span><span class="token function">setLogWriter</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            runner<span class="token punctuation">.</span><span class="token function">runScript</span><span class="token punctuation">(</span>Resources<span class="token punctuation">.</span><span class="token function">getResourceAsReader</span><span class="token punctuation">(</span><span class="token string">"test.sql"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            runner<span class="token punctuation">.</span><span class="token function">closeConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e1<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><h3 id="3-属性说明"><a href="#3-属性说明" class="headerlink" title="3. 属性说明"></a>3. 属性说明</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//要执行pl/sql的脚本，需要置为false，否则只执行正常的sql语句</span>    runner<span class="token punctuation">.</span><span class="token function">setEscapeProcessing</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//false 按行读取执行，true则读取所有脚本，若要执行begin end代码块，需要设为true.</span>    runner<span class="token punctuation">.</span><span class="token function">setSendFullScript</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//若.sql文件里没有commit语句，则此处设置为true，使runner执行之后自动提交</span>    runner<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//设置一般日志输出位置，参数为PrintWriter类型</span>    runner<span class="token punctuation">.</span><span class="token function">setLogWriter</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置普通日志</span>    runner<span class="token punctuation">.</span><span class="token function">setErrorLogWriter</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置异常日志 </span>    <span class="token comment" spellcheck="true">//出现error是否中断，设置为true则中断，此处的error是指执行.sql文件中的内容出现错误，如键  值重复等。若是文件不存在导致报错，在此处设置是没有用的，需要先判断文件是否存在，然后执行runScript函数。</span>    <span class="token comment" spellcheck="true">//当为false时，遇见错误不会停止，会继续执行，打印异常信息，并不会抛出异常，在当前方法无法捕捉异常无法进行回滚操作</span>    <span class="token comment" spellcheck="true">//当为true时，遇见错误会停止执行，打印并抛出异常，捕捉异常并进行回滚，保证在一个事务内执行。</span>    runner<span class="token punctuation">.</span><span class="token function">setStopOnError</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置字符集,不然中文乱码插入错误</span>    Resources<span class="token punctuation">.</span><span class="token function">setCharset</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：反射框架 Reflections</title>
      <link href="/2019/11/24/java-fan-she-kuang-jia-reflections/"/>
      <url>/2019/11/24/java-fan-she-kuang-jia-reflections/</url>
      
        <content type="html"><![CDATA[<h3 id="1-类介绍"><a href="#1-类介绍" class="headerlink" title="1. 类介绍"></a>1. 类介绍</h3><p>​        Reflections通过classpath，索引元数据，并且允许在运行时查询这些元数据。</p><h5 id="1-1-maven坐标"><a href="#1-1-maven坐标" class="headerlink" title="1.1 maven坐标"></a>1.1 maven坐标</h5><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>  <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>reflections<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>  <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>reflections<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>  <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">0.9</span><span class="token punctuation">.</span><span class="token number">10</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><h5 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//"cn." 表示会扫描的包的路径，后面的参数指定要扫描的范围，参数是扫描器</span>Reflections reflections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reflections</span><span class="token punctuation">(</span><span class="token string">"cn.*"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MethodAnnotationsScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeAnnotationsScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SubTypesScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MethodParameterScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><strong>SubTypesScanner()</strong> 子类扫描工具</li><li><strong>SubTypesScanner()</strong> 属性注解扫描工具</li><li><strong>MethodAnnotationsScanner()</strong> 方法注解扫描工具</li><li><strong>MethodParameterScanner()</strong> 方法参数扫描工具</li></ul><h5 id="1-3-方法"><a href="#1-3-方法" class="headerlink" title="1.3 方法"></a>1.3 方法</h5><ul><li><p>获取反射出的子类</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Test</span><span class="token operator">>></span> set <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getSubTypesOf</span><span class="token punctuation">(</span> Test<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre></li><li><p>获取反射带有指定注解的类</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> ss <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getTypesAnnotatedWith</span><span class="token punctuation">(</span> TestAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>获取带有特定注解的方法</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> methods <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getMethodsAnnotatedWith</span><span class="token punctuation">(</span> TestMethodAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre></li><li><p>获取带有特定注解的字段</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Field<span class="token operator">></span> fields <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getFieldsAnnotatedWith</span><span class="token punctuation">(</span> TestAutowired<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre></li><li><p>获取带有特定参数的方法</p><pre class=" language-java"><code class="language-java"> Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> someMethods <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getMethodsMatchParams</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>获取带有特定返回类型的方法</p><pre class=" language-java"><code class="language-java">   Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> voidMethods <span class="token operator">=</span> reflections<span class="token punctuation">.</span><span class="token function">getMethodsReturn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>获取带有参数注解的方法</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> pathParamMethods <span class="token operator">=</span>reflections<span class="token punctuation">.</span><span class="token function">getMethodsWithAnyParamAnnotated</span><span class="token punctuation">(</span> PathParam<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong><em>备注：</em></strong>以上方法被调用后有返回值的前提是，创建reflections时，要明确加上对应的扫描器参数。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：基于AOP配合注解的权限验证设计</title>
      <link href="/2019/11/18/java-ji-yu-zhu-jie-de-quan-xian-yan-zheng-she-ji/"/>
      <url>/2019/11/18/java-ji-yu-zhu-jie-de-quan-xian-yan-zheng-she-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        前一段时间负责了一个项目的权限验证方面的设计，主要用于限制不同的角色的不同操作权限，仅限后端控制，前端控制的目的在于隐藏不必要的操作，以达到良好的用户体验，此处暂不涉及前端，进行整理，方便日后回顾。</p><h3 id="2-基于注解的权限设计"><a href="#2-基于注解的权限设计" class="headerlink" title="2. 基于注解的权限设计"></a>2. 基于注解的权限设计</h3><p>​        后端的权限功能代代码采用了<strong>注解</strong>的形式，目的便于理解和解耦，为日后权限功能的扩展留下良好的设计思路。</p><h5 id="2-1-注解"><a href="#2-1-注解" class="headerlink" title="2.1 注解"></a>2.1 注解</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//该注解用于标记方法，标记所要进行权限控制的位置</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ActionCheck</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//该注解用于标记权限控制时，必须传入的入参，后面会对所标记的参数进行校验</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>PARAMETER<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">InputParam</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h5 id="2-2-参数类"><a href="#2-2-参数类" class="headerlink" title="2.2 参数类"></a>2.2 参数类</h5><pre class=" language-java"><code class="language-java">该参数类中参数，是用于封装权限查询时的参数，不同业务参数不同。<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ActionCheckVo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//项目UUID</span>    <span class="token keyword">private</span> String projectUuid<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//模块</span>    <span class="token keyword">private</span> String module<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//当前用于id</span>    <span class="token keyword">private</span> String userId<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getProjectUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> projectUuid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setProjectUuid</span><span class="token punctuation">(</span>String projectUuid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>projectUuid <span class="token operator">=</span> projectUuid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getModule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> module<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setModule</span><span class="token punctuation">(</span>String module<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>module <span class="token operator">=</span> module<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userId<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserId</span><span class="token punctuation">(</span>String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userId <span class="token operator">=</span> userId<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-3-AOP权限验证"><a href="#2-3-AOP权限验证" class="headerlink" title="2.3 AOP权限验证"></a>2.3 AOP权限验证</h4><p>​        权限验证是通过AOP的前置通知注解@Before，业务逻辑在执行@actionCheck所标记的方法时，会先执行AOP前置通知的权限验证，确保此次操作执行有权限进行。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoleActionHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProjectGroupMemberMapper memberMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProjectGroupActionMapper roleMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"@annotation(actionCheck)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ActionCheck</span><span class="token punctuation">(</span>JoinPoint point<span class="token punctuation">,</span> ActionCheck actionCheck<span class="token punctuation">)</span><span class="token punctuation">{</span>        ActionCheckVo checkVo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActionCheckVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> params <span class="token operator">=</span> point<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object param <span class="token operator">:</span> params<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>param <span class="token keyword">instanceof</span> <span class="token class-name">ActionCheckVo</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                checkVo <span class="token operator">=</span> <span class="token punctuation">(</span>ActionCheckVo<span class="token punctuation">)</span> param<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span> auth <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>ProjectGroupMemberVo<span class="token operator">></span> memberVoList <span class="token operator">=</span> memberMapper<span class="token punctuation">.</span><span class="token function">getProjectGroupMember</span><span class="token punctuation">(</span>checkVo<span class="token punctuation">.</span><span class="token function">getProjectUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> checkVo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memberVoList <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> memberVoList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>ProjectGroupMemberVo member <span class="token operator">:</span> memberVoList<span class="token punctuation">)</span><span class="token punctuation">{</span>                ProjectGroupActionVo actionParam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProjectGroupActionVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                actionParam<span class="token punctuation">.</span><span class="token function">setGroupUuid</span><span class="token punctuation">(</span>member<span class="token punctuation">.</span><span class="token function">getGroupUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                actionParam<span class="token punctuation">.</span><span class="token function">setModule</span><span class="token punctuation">(</span>checkVo<span class="token punctuation">.</span><span class="token function">getModule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                actionParam<span class="token punctuation">.</span><span class="token function">setProcessAreaUuid</span><span class="token punctuation">(</span>checkVo<span class="token punctuation">.</span><span class="token function">getProcessAreaUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                List<span class="token operator">&lt;</span>ProjectGroupActionVo<span class="token operator">></span> actionVoList <span class="token operator">=</span> roleMapper<span class="token punctuation">.</span><span class="token function">searchGroupActionByParams</span><span class="token punctuation">(</span>actionParam<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>ProjectGroupActionVo actionVo <span class="token operator">:</span> actionVoList<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>actionCheck<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>actionVo<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        auth <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>auth<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ActionCheckFailedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-4-启动校验"><a href="#2-4-启动校验" class="headerlink" title="2.4 启动校验"></a>2.4 启动校验</h4><p>​        启动校验的目的是保证权限验证的注解被正确使用。</p><p> 启动校验有三种方式：</p><ul><li>实现<strong>WebApplicationInitializer</strong>接口，重写<strong>onStartup()</strong>方法。</li><li>实现<strong>ApplicationListener</strong>接口，重写<strong>onApplicationEvent()</strong>方法。</li><li>编写启动类，代码置于静态块中，使用注解类标记，并进行Spring注入。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ActionCheckInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">WebApplicationInitializer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> roleActionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>ServletContext servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        Reflections reflections <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reflections</span><span class="token punctuation">(</span><span class="token string">"codedriver"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MethodAnnotationsScanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> methods <span class="token operator">=</span>  reflections<span class="token punctuation">.</span><span class="token function">getMethodsAnnotatedWith</span><span class="token punctuation">(</span>ActionCheck<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> methods<span class="token punctuation">)</span><span class="token punctuation">{</span>            ActionCheck check <span class="token operator">=</span> AnnotationUtils<span class="token punctuation">.</span><span class="token function">findAnnotation</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> ActionCheck<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">boolean</span> valid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterAnnotations <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterAnnotations<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> parameterAnnotations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterAnnotations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">InputParam</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        AnnotatedType<span class="token punctuation">[</span><span class="token punctuation">]</span> annotatedTypes <span class="token operator">=</span>  method<span class="token punctuation">.</span><span class="token function">getAnnotatedParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        AnnotatedType annotatedType <span class="token operator">=</span> annotatedTypes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>annotatedType<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ActionCheckVo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            valid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span><span class="token punctuation">{</span>                    String key <span class="token operator">=</span> check<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    String value <span class="token operator">=</span> check<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>roleActionMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>roleActionMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ActionCheckValueConflictException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                        roleActionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ActionCheckParamErrorException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-5-测试类"><a href="#2-5-测试类" class="headerlink" title="2.5 测试类"></a>2.5 测试类</h4><p>​    test方法就是业务方法，通过@ActionCheck可以知道此处进行的是check操作，并且进行了权限判断。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@ActionCheck</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"检查"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"check"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token annotation punctuation">@InputParam</span> ActionCheckVo actionCheckVo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：死锁分析</title>
      <link href="/2019/11/12/java-bing-fa-si-suo-fen-xi/"/>
      <url>/2019/11/12/java-bing-fa-si-suo-fen-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        Java中的加锁机制能够保证线程安全，但是过度使用加锁，可能会导致顺序死锁。当面对一些共享资源时，通过加锁的行为，可能会导致资源死锁。死锁的本质就是。一个线程持有A锁,等待B锁释放，一个线程持有B锁，等待A锁释放，两个线程互相等待对方，从而造成死锁。</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2. 死锁"></a>2. 死锁</h3><p>​        JVM面对死锁没有相应的处理方法，只能等待服务进行重启。</p><p>​        数据库系统在面对死锁时，将会进行检测，并且选择一个牺牲者放弃事务，保证其他事务的能够顺利完成。</p><p>​        死锁的发生存在偶然性，一般存在于高负载情况下，发生 条件大致分为三种情况。</p><ul><li><p><strong>锁顺序死锁</strong></p><p><strong><em>描述</em></strong>：锁顺序死锁一般直接表现在代码中，多个锁进行嵌套调用，并且调用锁的顺序在代码层面上就是不同的，定而肯定会发生死锁，（比如 一个方法逻辑是是先锁A，再锁B，另一个方法是先锁B，再锁A。两线程分别调用时，将造成死锁）。</p><p><strong><em>解决方法：</em></strong>保证在代码编写层面 加锁的顺序一致性。</p></li><li><p><strong>动态的锁顺序死锁</strong></p><p><strong><em>描述</em></strong>：动态死锁是指，如果方法中加的锁用的是形参，如果两个相同类型的形参调换顺序，同样本质上就是锁的顺序不一致，会导致死锁的发生。</p><p><strong><em>解决方法：</em></strong>可以通过System.identityHashCode()方法获取形参的哈希码，通过判断哈希码的大小来控制加锁的顺序，当然如果形参存在可比对性主键，同样也可以。为防止两个对象拥有相同的哈希码，因而造成死锁，可以选择“加时赛”锁，即定义一个属性级别的锁，获取其他锁之前，先获取该锁，这样保证，多线程情况下，只有单个线程会进入顺序锁，防止死锁的发生。</p></li><li><p><strong>协作对象之间发生死锁</strong></p><p><strong><em>描述：</em></strong>这种情况下发生死锁时，多个锁不一定是在同一个方法中获取，而是在不同的类调用中。在外层方法调用过程中，可能出现代码执行顺序的不同，导致获取锁的顺序不同，进而发生了死锁。</p><p>​    <em>如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取其他锁（可能发生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。</em></p><p><strong><em>解决方法</em></strong>：开放调用，即在调用某个方法时，不需要去持有锁，则称为开放调用。针对上述问题，如果代码中存在不同的调用顺序，则可以将其中的一个调用逻辑进行修改调整，对一种顺序中的对象进行拷贝，保证不同顺序的调用不为同一个对象。</p></li></ul><h3 id="3-死锁的诊断和避免"><a href="#3-死锁的诊断和避免" class="headerlink" title="3. 死锁的诊断和避免"></a>3. 死锁的诊断和避免</h3><ul><li><p><strong>支持定时锁</strong></p><p>显示锁不同于内置锁，可以设置锁的获取等待时间，如果发生死锁，定时锁可以保证获取锁的线程不会一直阻塞下去，会进行资源的释放，保证其他线程的顺利执行。</p></li><li><p><strong>通过线程转储信息分析死锁</strong></p><p>对于内置锁，JVM支持通过线程转储来帮助开发者来识别死锁，包括关于死锁发生的详细信息，jdk1.6之后虽然支持显示锁，但返回的相关信息很少。</p></li></ul><h3 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4. 其他问题"></a>4. 其他问题</h3><ul><li><p><strong>饥饿</strong></p><p>在Java程序中，如果对线程的优先级使用不当，或者在持有锁时，执行一些无法结束的结构，像无限循环、无限制等待资源等，导致锁不能释放，其他线程无法获取到该锁。</p><p><em>要避免使用线程优先级，会增加平台依赖性，并导致活跃性问题，大多数并发程序中，都可以使用默认的线程优先级</em></p></li><li><p><strong>糟糕的响应性能</strong></p><p>不良锁的管理，可能导致一个线程长时间占有锁，导致其他线程的阻塞。</p></li><li><p><strong>活锁</strong></p></li></ul><p>​        活锁不会阻塞线程，但也不能继续执行，线程会不断重复相同的动作，并不断失败。通常发生在处理事务消息的机制中，失败回滚，失败回滚，不断重复循环。在并发程序中，通过等待随机长度的时间和回退可以有效避免活锁的发生。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：ReentrantLock</title>
      <link href="/2019/11/03/java-bing-fa-reentrantlock/"/>
      <url>/2019/11/03/java-bing-fa-reentrantlock/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        在并发机制中，我们控制关于共享对象的访问，最常用的机制是synchronized和volatile。但在JDK5.0之后，增加了一种新的机制，ReentrantLock,显示锁。显示锁出现的目的并不是取代内置锁，而是作为内置锁不能满足部门需求时，作为一种可选择的高级功能。</p><h3 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h3><h4 id="2-1-方法介绍"><a href="#2-1-方法介绍" class="headerlink" title="2.1 方法介绍"></a>2.1 方法介绍</h4><p>​        <strong>ReentrantLock</strong>实现了Lock接口，主要的方法如下：</p><ul><li><p>lock()</p><p>获取锁</p></li><li><p>tryLock()</p><p>尝试获取锁，如果拿到锁，则返回true，否则返回false</p></li><li><p>unLock()</p><p>释放锁</p></li><li><p>lockInterruptibly()</p><p>获取锁，除非当前线程被打断</p></li><li><p>isLocked()</p><p>查询此锁当前是否被某个线程所持有</p></li><li><p>getOwner()</p><p>返回当前拥有此锁的线程，如果不拥有，则返回null</p></li></ul><p><strong>注意：</strong> tryLock不管拿到不拿到都会直接返回，lock拿不到锁会阻塞等待。并且tryLock是可以中断的。</p><h4 id="2-2-与内置锁synchronized对比"><a href="#2-2-与内置锁synchronized对比" class="headerlink" title="2.2 与内置锁synchronized对比"></a>2.2 与内置锁synchronized对比</h4><ul><li>内置锁无法中断一个正在等待获取锁的线程</li><li>内置锁无法在请求获取一个锁时，无限等待下去</li><li>显示锁支持轮询锁和定时锁。并且可中断。</li><li>显示锁支持公平锁和非公平锁</li><li>内置锁只支持非公平锁</li><li>性能方面，显示锁5.0版本远远胜出，6.0版本略微胜出。</li></ul><p><strong>备注：</strong>当内置锁无法满足需求时，显示锁作为一种高级工具，功能包括：可定时，可轮询与可中断的锁获取操作，公平队列，以及非块结构的锁，否则还是优先使用synchronized。</p><h3 id="3-读-写锁"><a href="#3-读-写锁" class="headerlink" title="3.读-写锁"></a>3.读-写锁</h3><p>​        ReentrantLock实现的是一种互斥锁，即每次只能有一个线程才能持有。但对于一些读操作来说，应该可以放宽锁的需求，运行多个执行读操作的线程能够同时访问数据结构，并且确保在读取时，不会有线程进行数据的写操作。即：一个资源可以可以被多个操作访问，或者被一个写操作访问，并且两者不能同时进行。这时候就该使用ReadWriteLock, 该接口暴露了两个方法，readLock()返回读锁，writeLock()返回写锁。</p><p>特点：</p><ul><li><p>ReentrantReadWriteLock在构造时也可以选择一个非公平锁和公平锁。</p></li><li><p>公平锁：等待时间最长的线程优先获得锁，但若线程当前被读线程持有，当写线程请求时，其他读线程不能获得读取锁，直到写完释放锁。</p></li><li><p>非公平锁：线程访问顺序不确定，写线程可降级为读线程，但读线程不能升级为写线程，会造成死锁。</p></li><li><p>写入锁只能有唯一的所有者，并只能由获得该锁的线程去释放</p></li><li><p>读取锁类似于Semaphore，维护读线程的数量。</p></li></ul><p>使用读写锁自定义实现线程安全的Map:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReadWriteMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> map<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ReadWriteLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Lock r <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Lock w <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ReadWriteMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> map<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>map <span class="token operator">=</span> map<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span><span class="token punctuation">{</span>        w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">{</span>        r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>​        读-写锁允许多个线程并发地访问被保护的对象，当访问以读取操作为主的数据结构时，可提高程序的可伸缩性。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：Condition解析</title>
      <link href="/2019/10/27/java-bing-fa-condition-jie-xi/"/>
      <url>/2019/10/27/java-bing-fa-condition-jie-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        <strong>Condition</strong>是在JDK1.5之后出现的，主要目的是用来替代传统的Object的<strong>wait()、notify()</strong>等实现线程间的协作，相比于Object的方法，condition的方式在线程间协作方面更加安全和高效。</p><h3 id="2-接口介绍"><a href="#2-接口介绍" class="headerlink" title="2. 接口介绍"></a>2. 接口介绍</h3><h5 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h5><p>​        <strong>Condition</strong>是一个接口，位于<strong>java.util.concurrent.locks</strong>包下，其主要方法如下：</p><ul><li><p><strong><em>await()</em></strong></p><p>暂停当前线程，直到被唤醒或打断。</p></li><li><p><strong><em>await(long time, TimeUnit unit)</em></strong></p><p>暂停当前线程，直到被唤醒或打断，或者已经达到等待时长。</p></li><li><p><strong><em>awaitNanos(long nanosTimeout)</em></strong></p><p>同上，暂停当前线程，直到被唤醒或打断，或者已经达到等待时长。</p></li><li><p><strong><em>awaitUnitterruptibly()</em></strong></p><p>暂停当前线程，直到被唤醒。</p></li><li><p><strong><em>awaitUntil(Date deadline)</em></strong></p><p>暂停当前线程，直到被唤醒或打断，或者达到指定时间点。</p></li><li><p><strong><em>signal()</em></strong></p><p>唤醒一个等待的线程</p></li><li><p><strong><em>signalAll()</em></strong></p><p>唤醒所有等待的线程</p></li></ul><p>​        通过以上方法可以就看出，Condition的await 对应的就是Object的wait，signal对应notify，signalAll 对应notifyAll。</p><p>​        Condition依赖于Lock接口，生成Condition的代码是lock.newCondition(),并且其调用方法必须在lock的保护之内，即在lock.lock()和lock.unlock()之间。</p><h5 id="2-2-内部原理"><a href="#2-2-内部原理" class="headerlink" title="2.2 内部原理"></a>2.2 内部原理</h5><p>​        要了解Condition就必须先对Lock有一定的认识，Lock的本质是AQS，其维护的队列是当前等待资源的队列，AQS在资源释放后会依次从前到后唤醒队列中所有的节点，使其对应的线程恢复执行，直至队列为空。</p><p>​        Condition内部也维护一个队列，用来存放等待signal信号的队列，每个线程要么存在于AQS的队列中，要么存在于Condition的队列中，并且队列的作用各自不相同。</p><ul><li>执行流程如下：</li></ul><ol><li>线程A调用reentrantLock.lock时，尝试获取锁，成功后，AQS将会把该线程从队列中移除，否则线程A会阻塞，存留于AQS的等待队列中。</li><li>线程A调用await()方法，此时线程将会被加入到Condition的队列中，等待其他线程进行释放信号，如signal或signalAll。同时也会释放当前的锁。</li><li>锁被释放，AQS的等待队列中的线程B由阻塞状态拿到锁，并且调用signal，此时Condition的等待队列中的第一个线程将会被取出，比如是线程A，将会被加到AQS的等待队列中，此时线程A并未被唤醒开始进行运行，而是被加入到AQS等待队列中。</li><li>线程B调完signal方法之后，再调用unlock()，进行锁的释放，线程A将会拿到锁，被唤醒开始接着运行。</li></ol><ul><li>await流程如下：<ol><li>将当前线程加入到Condition队列中。</li><li>释放锁。</li><li>自旋挂起，直到被调用signal唤醒加入AQS的等待队列中，或超时，或CACELLED.</li><li>如果被唤醒，尝试获取锁</li></ol></li><li>signal只会唤醒Condition队列中第一个非CANCELLED节点线程，signalAll会唤醒所有的非CANCELLED节点线程，即本质是从Condition队列中取出一个还是所有。但只有一个线程能够拿到锁，其他线程仍旧需要自旋等待。</li></ul><p>示例代码如下：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"   抢到锁了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 准备睡觉"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span><span class="token punctuation">{</span>                    condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"睡醒了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 准备叫醒它"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span><span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"已经叫醒了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>代码运行结果如下：</p><pre class=" language-java"><code class="language-java">线程A   抢到锁了线程A 准备睡觉线程B 准备叫醒它线程B已经叫醒了线程A睡醒了</code></pre><p><strong>备注：</strong>加上CountDownLatch的目的在于保证线程A的执行顺序优于线程B.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIO BIO NIO 笔记整理</title>
      <link href="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/"/>
      <url>/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        本篇文章主要用来记录在开发过程中涉及的IO的一些概念和代码思路，以及对于BIO，NIO，AIO的区分和理解 ，了解如何更好的优化代码。</p><h3 id="2-I-O介绍"><a href="#2-I-O介绍" class="headerlink" title="2.I/O介绍"></a>2.I/O介绍</h3><h5 id="2-1-什么是IO"><a href="#2-1-什么是IO" class="headerlink" title="2.1 什么是IO?"></a>2.1 什么是IO?</h5><p>​        IO的全称是Input/Output的缩写，我们平时大多用的关于一些文件的上传下载，基本都是使用IO下的BIO,BIO是相对于NIO来说的，BIO是Java最早推出的，是BlockingIO的缩写，即阻塞IO.</p><h5 id="2-2-异步-VS-同步"><a href="#2-2-异步-VS-同步" class="headerlink" title="2.2 异步 VS 同步"></a>2.2 异步 VS 同步</h5><table><thead><tr><th>异步</th><th>同步</th></tr></thead><tbody><tr><td>如果A任务依赖B任务，但A任务完成就认为完成了，而不用担心B任务是否完成，以及整体是否真正完成，不可靠的任务序列。</td><td>如果A任务的完成需要依赖B任务，那么它会等，直到B任务完成，A才回去完成任务。B失败，A也会失败，基本步调一致。</td></tr></tbody></table><h5 id="2-3-阻塞-VS-非阻塞"><a href="#2-3-阻塞-VS-非阻塞" class="headerlink" title="2.3 阻塞 VS 非阻塞"></a>2.3 阻塞 VS 非阻塞</h5><table><thead><tr><th>阻塞</th><th>非阻塞</th></tr></thead><tbody><tr><td>CPU会停下来等待一个慢操作的完成，完成之后，CPU才接着完成其他的事。</td><td>在慢操作执行的过程中，CPU并不会等待，而是切换线程去做其他的事情，能提高CPU的利用率，也会导致系统的线程切换成本增加</td></tr></tbody></table><h5 id="2-4-BIO-AIO-NIO的区别？"><a href="#2-4-BIO-AIO-NIO的区别？" class="headerlink" title="2.4 BIO AIO NIO的区别？"></a>2.4 BIO AIO NIO的区别？</h5><table><thead><tr><th>差异类型</th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>名称</td><td>BlockingIO(同步阻塞IO)</td><td>non-BlockingIO（同步非阻塞IO）</td><td>Asynchronous-non-blocking-IO(异步非阻塞IO)</td></tr><tr><td>JDK引入版本</td><td>1.1</td><td>1.4</td><td>1.7</td></tr><tr><td>模型机制</td><td>流模型</td><td>缓冲区模型，单线轮询事件机制</td><td>基于事件和回调机制</td></tr><tr><td>优点</td><td>代码简单、直观</td><td>可以构件多路复用，更接近操作系统底层数据操作方式，在长连接下，数据不多时提升性能很有效</td><td>适用于复杂的分布式环境中，传输数据量不大，但非常频繁的下，性能能达到最高</td></tr><tr><td>缺点</td><td>IO效率和扩展性很低</td><td>会增加CPU的消耗，考虑IO性能能否补偿CPU消耗</td><td>编码较为复杂</td></tr><tr><td>简介</td><td>是最常见的用法，调用是线性顺序，所以大多数时间处于空闲状态，Java的线程是重量级的，所以每次创建线程会造成很高的资源消耗，尤其阻塞在高并发状态下，性能更加明显不足。</td><td>将阻塞改为非阻塞，采用单线程轮询事件机制，通过定位channel来决定做什么，仅仅select阶段会阻塞，避免并发时，线程切换带来的问题</td><td>采用事件和回调机制，反向通知型处理</td></tr></tbody></table><h5 id="2-5-IO的使用"><a href="#2-5-IO的使用" class="headerlink" title="2.5 IO的使用"></a>2.5 IO的使用</h5><p>传统的IO基本可以分为4种：</p><ul><li>InputStream、OuputStream 基于子节操作的IO</li><li>Writer、Reader基于字符操作的IO</li><li>File 基于磁盘的操作IO</li><li>Socket基于网络操作的IO</li></ul><h6 id="2-5-1-InputStream的使用"><a href="#2-5-1-InputStream的使用" class="headerlink" title="2.5.1 InputStream的使用"></a>2.5.1 InputStream的使用</h6><p>​        接口继承关系如下：</p><p><img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227143422595.png" alt="image-20191227143422595"></p><p>​        使用示例：</p><pre class=" language-java"><code class="language-java">InputStream inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>inputStream<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-5-2-OuputStream的使用"><a href="#2-5-2-OuputStream的使用" class="headerlink" title="2.5.2 OuputStream的使用"></a>2.5.2 OuputStream的使用</h6><p>​        接口继承关系如下：</p><p>​                    <img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227143843547.png" alt="image-20191227143843547"></p><p>​    使用示例：</p><pre class=" language-java"><code class="language-java">OutputStream outputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你好，世界"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-5-3-Writer-使用"><a href="#2-5-3-Writer-使用" class="headerlink" title="2.5.3 Writer 使用"></a>2.5.3 Writer 使用</h6><p>​        接口继承关系如下：</p><p>​        <img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227144214989.png" alt="image-20191227144214989"></p><p>​        使用示例：</p><pre class=" language-java"><code class="language-java">Writer writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//采用nio的方式</span>Files<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">,</span> Content<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-5-4-Reader-的使用"><a href="#2-5-4-Reader-的使用" class="headerlink" title="2.5.4 Reader 的使用"></a>2.5.4 Reader 的使用</h6><p>​        类的继承关系如下：</p><p>​        <img src="/2019/10/20/xue-xi-bioaionio-bi-ji-zheng-li/image-20191227145109053.png" alt="image-20191227145109053"> </p><p>​            使用用例：</p><pre class=" language-java"><code class="language-java">Reader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>StringBuffer bf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>str <span class="token operator">=</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    bf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bufferedReader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//采用nio的方式</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-实现Socket"><a href="#3-实现Socket" class="headerlink" title="3. 实现Socket"></a>3. 实现Socket</h3><h5 id="3-1-BIO实现Socket"><a href="#3-1-BIO实现Socket" class="headerlink" title="3.1 BIO实现Socket"></a>3.1 BIO实现Socket</h5><p>​        传统方式实现Socket,每次建立传输连接时，都会创建线程，并发条件下，线程数的激增将会成为瓶颈。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//端口号</span><span class="token comment" spellcheck="true">// Socket 服务器端（简单的发送信息）</span>Thread sThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 等待连接</span>                Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread sHandlerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">(</span>PrintWriter printWriter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            printWriter<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            printWriter<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sHandlerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Socket 客户端（接收信息并打印）</span><span class="token keyword">try</span> <span class="token punctuation">(</span>Socket cSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>InetAddress<span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>cSocket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bufferedReader<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端："</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnknownHostException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="3-2-NIO实现Socket"><a href="#3-2-NIO实现Socket" class="headerlink" title="3.2 NIO实现Socket"></a>3.2 NIO实现Socket</h5><p>​        NIO利用单线程轮询事件的机制，通过定位就绪的Channel来决定做什么，仅仅select阶段是阻塞的。避免并发情况下，线程的频繁切换问题。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建线程池</span>ThreadPoolExecutor threadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span>        60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取选择器 和 通道</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             ServerSocketChannel serverSocketChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//通道绑定地址</span>            serverSocketChannel<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>InetAddress<span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将通道注册到选择器中</span>            serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 阻塞等待就绪的Channel，当有Channel发生接入请求时，会被唤醒</span>                Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    SelectionKey key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">(</span>SocketChannel channel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        channel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"你好，世界"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Socket 客户端（接收信息并打印）</span><span class="token keyword">try</span> <span class="token punctuation">(</span>Socket cSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>InetAddress<span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>cSocket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bufferedReader<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"NIO 客户端："</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="3-3-AIO实现Socket"><a href="#3-3-AIO实现Socket" class="headerlink" title="3.3 AIO实现Socket"></a>3.3 AIO实现Socket</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// AIO线程复用版</span>Thread sThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AsynchronousChannelGroup group <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            group <span class="token operator">=</span> AsynchronousChannelGroup<span class="token punctuation">.</span><span class="token function">withThreadPool</span><span class="token punctuation">(</span>Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            AsynchronousServerSocketChannel server <span class="token operator">=</span> AsynchronousServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>InetAddress<span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token operator">&lt;</span>AsynchronousSocketChannel<span class="token punctuation">,</span> AsynchronousServerSocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span>AsynchronousSocketChannel result<span class="token punctuation">,</span> AsynchronousServerSocketChannel attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 接收下一个请求</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> f <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"你好，世界"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端发送时间："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        result<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> ExecutionException <span class="token operator">|</span> IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span>Throwable exc<span class="token punctuation">,</span> AsynchronousServerSocketChannel attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            group<span class="token punctuation">.</span><span class="token function">awaitTermination</span><span class="token punctuation">(</span>Long<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> InterruptedException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Socket 客户端</span>AsynchronousSocketChannel client <span class="token operator">=</span> AsynchronousSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span>Void<span class="token operator">></span> future <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>InetAddress<span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Void<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span>Integer result<span class="token punctuation">,</span> Void attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端打印："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span>Throwable exc<span class="token punctuation">,</span> Void attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        exc<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于前后端分离的API设计思路整理（三）</title>
      <link href="/2019/10/13/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-san/"/>
      <url>/2019/10/13/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-san/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        上一篇主要记录了接口处理具体的实现类的架构设计，其中使用到了模板模式的设计模式，本篇重点记录一下基于注解的关于接口请求参数的验证机制和基于Spring 的类启动加载机制，为以后开发做好知识储备。</p><h3 id="2-注解接口验证"><a href="#2-注解接口验证" class="headerlink" title="2. 注解接口验证"></a>2. 注解接口验证</h3><p>​        该方法的入参依次是，<strong>具体接口实现类的Class，输入参数，入参的Class</strong>。</p><p>​        原理是通过接口实现类的class文件,拿到对应要解析的方法，将其上的注解进行解析，并与入参进行对比，保证入参和注解标记内容的规范一致性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">validApi</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> apiClass<span class="token punctuation">,</span> JSONObject paramObj<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> classes<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException<span class="token punctuation">,</span> SecurityException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取目标类</span>        Boolean isAuth <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>apiClass <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//AuthAction注解的作用是进行url权限验证</span>            AuthAction action <span class="token operator">=</span> apiClass<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>AuthAction<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> action <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String actionName <span class="token operator">=</span> action<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 判断用户角色是否拥有接口权限</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>AuthActionChecker<span class="token punctuation">.</span><span class="token function">check</span><span class="token punctuation">(</span>actionName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    isAuth <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                isAuth <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAuth<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">PermissionDeniedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 判断参数是否合法，拿到具体接口实现类的“myDoservice”方法</span>            Method method <span class="token operator">=</span> apiClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"myDoService"</span><span class="token punctuation">,</span> classes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//拿到Input注解</span>                Input input <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>Input<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Param<span class="token punctuation">[</span><span class="token punctuation">]</span> params <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>params <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> params<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Param p <span class="token operator">:</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// 判断是否必填，即isRequired的值为true，但参数中没有则抛出异常</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">isRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>paramObj<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ParamNotExistsException</span><span class="token punctuation">(</span><span class="token string">"参数：“"</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"”不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token comment" spellcheck="true">// 参数类型校验</span>                            Object paramValue <span class="token operator">=</span> paramObj<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// xss过滤</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">xss</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> paramObj<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token function">encodeHtml</span><span class="token punctuation">(</span>paramObj<span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token comment" spellcheck="true">// 判断长度</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> paramValue <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> paramValue <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>paramValue<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ParamValueTooLongException</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> paramValue<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>paramValue <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ApiParamFactory<span class="token punctuation">.</span><span class="token function">getAuthInstance</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>paramValue<span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">rule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ParamIrregularException</span><span class="token punctuation">(</span><span class="token string">"参数“"</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"”不符合格式要求"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="3-SpringBean加载"><a href="#3-SpringBean加载" class="headerlink" title="3.  SpringBean加载"></a>3.  SpringBean加载</h3><p>​        在项目启动时，会扫描拿到指定接口的所有实现类，存储在内存中。其原理是在项目启动时拿到上下文，在上下文中拿到指定接口的实现类，将其存储在List或者Map中。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//实现ApplicationListener&lt;ContextRefreshedEvent> 接口，实现 onApplicationEvent 方法</span><span class="token annotation punctuation">@RootComponent</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiComponentFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>ContextRefreshedEvent<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>ContextRefreshedEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//拿到启动上下文</span>        ApplicationContext context <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取指定接口的BeanMap</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ApiComponent<span class="token operator">></span> myMap <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span>ApiComponent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ApiComponent<span class="token operator">></span> entry <span class="token operator">:</span> myMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//拿到具体的实现类，作相应的处理</span>            ApiComponent component <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>component<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>​        可将其存储到Map中，通过工厂模式，后期的获取只需要根据主键ID去获取响应的实体Bean。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于前后端分离的API设计思路整理（二）</title>
      <link href="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/"/>
      <url>/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        前一篇主要介绍了接口的顶层分派器的设计思路，但本质上业务逻辑的处理还是要由底层的接口具体实现类来进行处理，这篇主要记录一下具体接口实现类的架构体系。</p><h3 id="2-接口实现类架构"><a href="#2-接口实现类架构" class="headerlink" title="2. 接口实现类架构"></a>2. 接口实现类架构</h3><ul><li><p>接口继承与实现关系</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p><ul><li><p><strong>ApiComponent（interface）</strong>作为最顶层的接口定义了具体接口所要实现的方法</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/%E9%A1%B6%E5%B1%82%E6%8E%A5%E5%8F%A3.png" alt=""></p></li><li><p><strong>MyAPiComponent（interface）</strong>继承了接口<strong>ApiComponent</strong>,扩展了方法,其目的是为了保证基类<strong>ApiComponentBase</strong>内部方法的干净。</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/MyApiComponent.png" alt=""></p></li><li><p><strong>ApiValidateAndHelpBase</strong>类的作用主要包括提供 <strong>登陆权限验证</strong>，<strong>接口入参格式验证</strong>等功能。</p></li><li><p><strong>ApiComponentBase（abstract）</strong> 是所有接口类的基类，继承了<strong>ApiValidateAndHelpBase</strong>实现了<strong>ApiComponent 和 MyApiComponent</strong>的部分方法：</p><ul><li><strong>doService()</strong>  在该方法的主要目的在具体的接口实现类(<strong>myDoService</strong>)的上一层做一些公共的操作和处理</li><li><strong>getId()</strong> 返回具体实现类的类路径作为唯一主键ID</li><li><strong>help()</strong> 通过调用功能类(<strong>ApiValidateAndHelpBase</strong>)的方法  返回对应具体实现类的注解帮助</li></ul></li><li><p><strong>ProjectSaveApi</strong> 对应具体的接口业务处理层，内部方法结构如下：</p><p><img src="/2019/10/06/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-er/%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt=""></p><p><strong>getToken()</strong>是用来设置接口实现类的唯一主键路径</p><p><strong>myDoService()</strong>用于进行业务处理 </p><p><strong>总结</strong>： <strong>整套接口的架构使用了设计模式–模板模式，通过子类父调的方式实现了对公共层的抽取和处理。</strong></p></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于前后端分离的API设计思路整理（一）</title>
      <link href="/2019/10/01/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-yi/"/>
      <url>/2019/10/01/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        年初公司开始启动新的项目开发，决定新项目不再采用旧的传统的MVC一体系模式，要做到前后端分离。以往的后端接口都是以一个controller类为单位进行集成，即对应不同接口的处理方式都是该controller类的方法，现将处理方法统一抽出，作为单独的类，为前端提供数据接口。</p><p>​        涉及的知识点：</p><ul><li><p><strong>接口转发器的架构设计（接口请求分配）</strong></p></li><li><p><strong>接口参数的校验设计（采用注解，解析校验）</strong></p></li><li><p><strong>接口参数类型的架构设计（支持JSON, IO流等横向扩展）</strong></p></li></ul><h3 id="2-接口转发器架构设计"><a href="#2-接口转发器架构设计" class="headerlink" title="2. 接口转发器架构设计"></a>2. 接口转发器架构设计</h3><ul><li><strong>核心转发器</strong>（ApiDispatcher）</li></ul><p><img src="/2019/10/01/qian-hou-duan-fen-chi-de-api-she-ji-si-lu-zheng-li-yi/image-20191225114538526.png" alt=""></p><p>​        该类的作用是接受前端的接口请求，然后进行中转处理。</p><p>​        目前所支持的接口访问类型包括四种，<strong>Post,Get, PostStream, PostBinary</strong>，其中<strong>PostStream</strong> 和<strong>PostBinary</strong>的作用是通过接口进行文件类型数据的传输。</p><ul><li>以最常用的<strong>Post</strong>类型为例，该方法用于接收post类型的普通接口请求，解析请求中的接口token和参数，以便分配给具体的接口处理类：</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/rest/**"</span><span class="token punctuation">,</span>            method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//接口传递的参数是以JSONObject</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatcherForPost</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span>    String jsonStr<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获取接口前缀的定义规则，即 api/rest/**（依赖于spring-webmvc）</span>        String pattern <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> request<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>HandlerMapping<span class="token punctuation">.</span>BEST_MATCHING_PATTERN_ATTRIBUTE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据接口请求规则获取接口的token值，即pattern之后的接口请求路径</span>        String token <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AntPathMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">extractPathWithinPattern</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getServletPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取参数值</span>        JSONObject paramObj <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                paramObj <span class="token operator">=</span> JSONObject<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"参数不是json格式,错误信息为："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            paramObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Enumeration<span class="token operator">&lt;</span>String<span class="token operator">></span> paraNames <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>paraNames<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String p <span class="token operator">=</span> paraNames<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> vs <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterValues</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>vs<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                paramObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> vs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                paramObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        JSONObject returnObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//调用转发方法，上层的代码目的是提取参数，以及token</span>            <span class="token function">doIt</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> token<span class="token punctuation">,</span> ApiVo<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>OBJECT<span class="token punctuation">,</span> paramObj<span class="token punctuation">,</span> returnObj<span class="token punctuation">,</span> <span class="token string">"doservice"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ApiRuntimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Status"</span><span class="token punctuation">,</span> <span class="token string">"ERROR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Status"</span><span class="token punctuation">,</span> <span class="token string">"ERROR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">,</span> ExceptionUtils<span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span><span class="token function">isCommitted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span>Config<span class="token punctuation">.</span>RESPONSE_TYPE_JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>returnObj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ul><li>doIt方法的目的在于根据接口token调用对应的接口处理类，并将处理结果进行统一封装，接口对象实体以及对应Vo对象，会在项目启动时扫描进Map中进行存储，三种不同的接口类型对应三种不同的基类。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doIt</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> String token<span class="token punctuation">,</span> ApiVo<span class="token punctuation">.</span>Type apiType<span class="token punctuation">,</span> JSONObject paramObj<span class="token punctuation">,</span> JSONObject returnObj<span class="token punctuation">,</span> String action<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//项目启动时，会预先将所有接口类实体和其信息Vo扫描进Map中，再通过token在工厂中进行获取</span>        ApiVo interfaceVo <span class="token operator">=</span> ApiComponentFactory<span class="token punctuation">.</span><span class="token function">getApiByToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>interfaceVo <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从表中获取接口类对应Vo</span>            interfaceVo <span class="token operator">=</span> apiService<span class="token punctuation">.</span><span class="token function">getApiByToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>interfaceVo <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>interfaceVo<span class="token punctuation">.</span><span class="token function">getIsActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApiNotFoundException</span><span class="token punctuation">(</span><span class="token string">"token为“"</span> <span class="token operator">+</span> token <span class="token operator">+</span> <span class="token string">"”的接口不存在或已被禁用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>apiType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ApiVo<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>OBJECT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取接口类实体对象</span>            ApiComponent restComponent <span class="token operator">=</span> ApiComponentFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>interfaceVo<span class="token punctuation">.</span><span class="token function">getComponentId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>restComponent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"doservice"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Long starttime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//调用实体类的doService方法进行参数的处理</span>                    Object returnV <span class="token operator">=</span> restComponent<span class="token punctuation">.</span><span class="token function">doService</span><span class="token punctuation">(</span>interfaceVo<span class="token punctuation">,</span> paramObj<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//封装最终返回值</span>                    Long endtime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"TimeCost"</span><span class="token punctuation">,</span> endtime <span class="token operator">-</span> starttime<span class="token punctuation">)</span><span class="token punctuation">;</span>                    returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Return"</span><span class="token punctuation">,</span> returnV<span class="token punctuation">)</span><span class="token punctuation">;</span>                    returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Status"</span><span class="token punctuation">,</span> <span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//返回接口的帮助文档</span>                    returnObj<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>restComponent<span class="token punctuation">.</span><span class="token function">help</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ComponentNotFoundException</span><span class="token punctuation">(</span><span class="token string">"接口组件:"</span> <span class="token operator">+</span> restComponent<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//采用流类型的处理方式</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>apiType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ApiVo<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>STREAM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JsonStreamApiComponent restComponent <span class="token operator">=</span> ApiComponentFactory<span class="token punctuation">.</span><span class="token function">getStreamInstance</span><span class="token punctuation">(</span>interfaceVo<span class="token punctuation">.</span><span class="token function">getComponentId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>restComponent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"doservice"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Object returnV <span class="token operator">=</span> restComponent<span class="token punctuation">.</span><span class="token function">doService</span><span class="token punctuation">(</span>interfaceVo<span class="token punctuation">,</span> paramObj<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">JSONReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Return"</span><span class="token punctuation">,</span> returnV<span class="token punctuation">)</span><span class="token punctuation">;</span>                    returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Status"</span><span class="token punctuation">,</span> <span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    returnObj<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>restComponent<span class="token punctuation">.</span><span class="token function">help</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ComponentNotFoundException</span><span class="token punctuation">(</span><span class="token string">"接口组件:"</span> <span class="token operator">+</span> restComponent<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//采用二进制类型的处理方式</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>apiType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ApiVo<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>BINARY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            BinaryStreamApiComponent restComponent <span class="token operator">=</span> ApiComponentFactory<span class="token punctuation">.</span><span class="token function">getBinaryInstance</span><span class="token punctuation">(</span>interfaceVo<span class="token punctuation">.</span><span class="token function">getComponentId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>restComponent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"doservice"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Object returnV <span class="token operator">=</span> restComponent<span class="token punctuation">.</span><span class="token function">doService</span><span class="token punctuation">(</span>interfaceVo<span class="token punctuation">,</span> paramObj<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>                    returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Return"</span><span class="token punctuation">,</span> returnV<span class="token punctuation">)</span><span class="token punctuation">;</span>                    returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Status"</span><span class="token punctuation">,</span> <span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    returnObj<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>restComponent<span class="token punctuation">.</span><span class="token function">help</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ComponentNotFoundException</span><span class="token punctuation">(</span><span class="token string">"接口组件:"</span> <span class="token operator">+</span> restComponent<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ul><li><p>restHelp方法的目的在于返回接口类的接口帮助说明</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/help/rest/**"</span><span class="token punctuation">,</span>            method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resthelp</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String pattern <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> request<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>HandlerMapping<span class="token punctuation">.</span>BEST_MATCHING_PATTERN_ATTRIBUTE<span class="token punctuation">)</span><span class="token punctuation">;</span>        String token <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AntPathMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">extractPathWithinPattern</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getServletPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject returnObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//标明是“help”类型请求</span>            <span class="token function">doIt</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> token<span class="token punctuation">,</span> ApiVo<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>OBJECT<span class="token punctuation">,</span> null<span class="token punctuation">,</span> returnObj<span class="token punctuation">,</span> <span class="token string">"help"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ApiRuntimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"ErrorCode"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Status"</span><span class="token punctuation">,</span> <span class="token string">"ERROR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"ErrorCode"</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Status"</span><span class="token punctuation">,</span> <span class="token string">"ERROR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            returnObj<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">,</span> ExceptionUtils<span class="token punctuation">.</span><span class="token function">getStackFrames</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span>Config<span class="token punctuation">.</span>RESPONSE_TYPE_JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>returnObj<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul><ul><li><p>总结整理：</p><p>​    这一层算是作为所有的请求接口的分配器（dispatcher），通过截取接口请求，拿到请求的唯一token值，根据token拿到具体的接口处理器，对参数进行处理，返回的结果再进行统一包装作为最终结果 进行返回。通过增加方法的方式，支持多种不同数据类型接口的处理。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程：Java并发编程实战学习（二）</title>
      <link href="/2019/09/21/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-er/"/>
      <url>/2019/09/21/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-er/</url>
      
        <content type="html"><![CDATA[<h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h3><p>​        一句话，一个状态值具有可见性，那么当一个线程修改这个状态值之后，其他线程要立刻看到，并且如果要取的话，肯定是取的最新的值（当然属性a确保自己被A线程修改之后，B立马能看到，但是如果A还没去修改，B就去看，依旧会有问题，但a属性确实是“可见性”的，B能提前看，说明不是原子性，有点绕，但线程安全就是<strong>原子性+可见性</strong>）。</p><p>​        A修改属性，B去看的时候，A还没进行同步，导致B看到是旧数据，造成这种现象的问题的本质是“重排序”。</p><h5 id="1-1-失效数据"><a href="#1-1-失效数据" class="headerlink" title="1.1 失效数据"></a>1.1 失效数据</h5><p>​        提前看了，看到了假数据，这就是失效数据。</p><h5 id="1-2-非原子的64位操作"><a href="#1-2-非原子的64位操作" class="headerlink" title="1.2 非原子的64位操作"></a>1.2 非原子的64位操作</h5><p>​            <strong>JVM内存模型要求，变量的读取操作和写入都必须是原子操作</strong>。但非volatile 的long 和double会分为两次，即不能保证原子性，所以不安全，触发加锁或者使用volatile声明，或者使用原子属性AtomicLong类型。</p><h5 id="1-3-加锁与可见性"><a href="#1-3-加锁与可见性" class="headerlink" title="1.3 加锁与可见性"></a>1.3 加锁与可见性</h5><p>​        加锁 = 可见性 + 原子性 = 线程安全 = synchronized</p><p>​        <strong>原话就是</strong>：<em>加锁的含义不仅仅局限于互斥行内，还包括内存可见性，为了确保所有的线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步</em>。</p><p>​        翻译一下就是：执行的时候相关变量要全部修改到位（原子性），并且要让其他的线程都要看到（可见性）。</p><h5 id="1-4-volatile"><a href="#1-4-volatile" class="headerlink" title="1.4 volatile"></a>1.4 volatile</h5><p>​        volatile = 可见性</p><h3 id="2-发布与逸出"><a href="#2-发布与逸出" class="headerlink" title="2. 发布与逸出"></a>2. 发布与逸出</h3><p>​        <strong>发布</strong>：发布一个对象，指的是整个对象可以在当前作用域之外的代码使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Publish</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> pubList<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pubList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//pubList 的作用域是initialize方法,但是作为静态属性它已经发布了。</span></code></pre><p>​        <strong>逸出</strong>：同样发布一个对象，但是对象还没创建好（或者该对象内部的其他对象没创建好）就发布了，即可以被调用了，比较复杂的是隐式使用this逸出。(个人认为逸出是发布中的一个问题点，不是同级或互斥关系)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThisEscape</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ThisEscape</span><span class="token punctuation">(</span>EventSource source<span class="token punctuation">)</span><span class="token punctuation">{</span>        source<span class="token punctuation">.</span><span class="token function">registerListener</span><span class="token punctuation">(</span>            <span class="token keyword">new</span> <span class="token class-name">EventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span>Event e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">doSomething</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逸出的原因是source调用了注册方法，这里隐式的调                                        //用了this。doSomething</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Event e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所以，切记 <strong>不要在构造过程中使用this引用逸出</strong>。</p><p>正确的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeListener</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> EventListener listener<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SafeListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span>Event e<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">doSomething</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SafeListener <span class="token function">newInstance</span><span class="token punctuation">(</span>EventSource source<span class="token punctuation">)</span><span class="token punctuation">{</span>        SafeListener safe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SafeListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        source<span class="token punctuation">.</span><span class="token function">registerListener</span><span class="token punctuation">(</span>safe<span class="token punctuation">.</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建好对象之后才进行注册</span>        <span class="token keyword">return</span> safe<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-线程封闭"><a href="#3-线程封闭" class="headerlink" title="3.线程封闭"></a>3.线程封闭</h3><h5 id="3-1-Ad-hoc线程封闭"><a href="#3-1-Ad-hoc线程封闭" class="headerlink" title="3.1 Ad-hoc线程封闭"></a>3.1 Ad-hoc线程封闭</h5><p>​        Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。</p><p>​        当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程程子系统。</p><p>​        由于Ad-hoc线程封闭技术的脆弱性，因此程序中尽量少用它。</p><p>​        我承认，确实不理解这是个什么玩意。。。</p><h5 id="3-2-栈封闭"><a href="#3-2-栈封闭" class="headerlink" title="3.2 栈封闭"></a>3.2 栈封闭</h5><p>​        局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。直译就是，局部变量是属于栈的，一个线程有自己的栈，所以就是线程安全的。</p><p>​        维持对象引用的栈封闭性时，要确保被引用的对象不会逸出（即确保方法内部定义的对象不会在该方法外部被使用，比如被返回，或者加入公共集合属性中等都算逸出）。</p><h5 id="3-3-ThreadLocal-类"><a href="#3-3-ThreadLocal-类" class="headerlink" title="3.3 ThreadLocal 类"></a>3.3 ThreadLocal 类</h5><p>​        ThreadLocal使得线程中的某个值能与保存值的对象关联起来。提供了getter setter方法为每个使用该变量的线程都存有一份独立的副本。保证get总是返回set的最新值。</p><p>​        当某个频繁执行的操作需要一个临时对象时，如缓冲区，又想避免每次执行都重新分配该临时对象，就可以使用该技术。ThreadLocal内部的实现，特定于线程的值保存在Thread对象中，线程终止会被回收。缺点是，降低代码的可重用性，并会在类之间引入隐含的耦合性。</p><h3 id="4-不变性"><a href="#4-不变性" class="headerlink" title="4. 不变性"></a>4. 不变性</h3><p>​        满足同步需求的另一种方法是使用不可变对象，即在被创建之后就不能被修改，并且不可变对象一定是线程安全的。</p><p>​        当满足以下条件时，对象才是不可变的。</p><ul><li><p>对象创建以后其状态就不能修改</p></li><li><p>对象的所有域都是final类型</p></li><li><p>对象是正确创建的，即创建期间没有this引用逸出</p><p>即使对象的所有域均为final 也不一定是不可变的，final类型的域中可以保存可变对象的引用,但只要保证可变对象只有在被初始化的时候才能被修改即可。</p><h5 id="4-1-Final域"><a href="#4-1-Final域" class="headerlink" title="4.1 Final域"></a>4.1 Final域</h5><p>​    将于声明为final类型，等于告诉维护人员这些域是不会变的。</p><h5 id="4-2-使用Volatile类型发布不可变对象"><a href="#4-2-使用Volatile类型发布不可变对象" class="headerlink" title="4.2 使用Volatile类型发布不可变对象"></a>4.2 使用Volatile类型发布不可变对象</h5><pre><code>     对于访问和更新多个相关变量时出现的竞争条件问题，可以将这些**变量封装到一个不可变对象中**。如果是一个可变对象，需要**用锁来保证原子性**。都要使用volatile字段来声明对象，**保证可见性。**</code></pre></li></ul><h3 id="5-安全发布"><a href="#5-安全发布" class="headerlink" title="5. 安全发布"></a>5. 安全发布</h3><p>​                任何线程都可以在<strong>不需要额外同步的情况下安全的访问不可变对象</strong>，即使在发布这些对象时没有使用同步。延伸一下，就是对象的域如果是<strong>非对象类型的final域</strong>，也是可以安全访问的，但是final域的引用所指的对象时依旧<strong>需要同步</strong>。</p><p>​                <strong>可变对象必须通过安全的方式发布，即发布和使用该对象的线程都必须使用同步。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> java </tag>
            
            <tag> Java并发编程实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程：Java并发编程实战学习（一）</title>
      <link href="/2019/09/15/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-yi/"/>
      <url>/2019/09/15/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  本篇博客是根据《Java并发编程实战》的第二章<strong>线程安全性</strong>进行的学习总结。<br>  结构思维导图如下：</p><p><img src="/2019/09/15/xue-xi-bi-ji-java-bing-fa-bian-cheng-shi-zhan-yi/1567741434309.png" alt="1567741434309"></p><h3 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h3><p>  作者认为，线程的安全与否的核心是“正确性”，即，<strong>当多个线程访问某个类，这个类始终能表现出正确的行为，那么称这个类就是线程安全的。</strong></p><p>​        对于一个线程安全的类，自己的内部已经是线程安全的，所以当外部多线程来调用时，依旧是安全的。即使调用的这个动作没有采用线程安全的方式。</p><p>​        <strong>无状态的对象一定是线程安全的</strong>。这句话的意思是对象不会涉及公共数据的变更与读取时候，即内部只有对数据进行加工的方法，没有任何属性。那么多个线程的访问，本质上是在各自的实例上进行数据处理，互相不会影响其他线程操作的正确性。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//该类只是将参数数据进行处理，不涉及自身任何属性（字段）</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoUtil</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doing</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2.原子性"></a>2.原子性</h3><p>​        提到原子性也有必要提及一下并发的三个概念：</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><p><img src="https://img-blog.csdnimg.cn/20190806182211114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxkb25fX0xlZQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​        解释一下：</p><p>​        <strong>原子性</strong>，指的是一系列动作是不可分割，这一系列操作中，只能有当前线程独立去进行，其他线程不能参与，要么由一个线程全部执行搞定，要么全不做，类似于<strong>事务</strong>。像++a 这种操作实质是是三个动作，取值，加1，赋值。所以并不具备原子性。</p><h5 id="2-1-竞态条件"><a href="#2-1-竞态条件" class="headerlink" title="2.1 竞态条件"></a>2.1 竞态条件</h5><p>​        竞态条件是指在多线程场景下，<strong>代码的正确性依赖于多个线程的交替执行时序时</strong>，便会发生竞态条件，最常见的场景就是<strong>“先检查后执行（Check-Then-Act）”</strong>.<strong>即先以观察到的数据为依据，然后再去做别的计算，但在观察数据完毕到准备计算这段时间内，所观察的数据已经发生了改变，也就是意为着之前的参考数据是无效的，如果根据无效数据计算，则会出现问题*。</strong></p><h5 id="2-2-延迟初始化的竞态条件"><a href="#2-2-延迟初始化的竞态条件" class="headerlink" title="2.2 延迟初始化的竞态条件"></a>2.2 延迟初始化的竞态条件</h5><p>​        使用“先检查后执行”的一种常见情况就是延迟初始化，比如不安全的单例模式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleTest</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> SingleTest <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> SingleTest <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>singTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            singleTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleTest<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//A线程进来判断没有对象,正准备new的时候，B也进来，发现没有，也会new，导致出现两个对象。</span></code></pre><h5 id="2-3-复合操作"><a href="#2-3-复合操作" class="headerlink" title="2.3 复合操作"></a>2.3 复合操作</h5><p>​        思路很简单，一系列动作不是原子性的，那就加锁，保证其原子性。并且提及到java自带的一些已经实现原子性的变量（java.util.concurrent.atomic）,其内部本质上还是使用<strong>voliate保证可见性，使用CAS算法保证原子性</strong>，这样原子性+可见性 就是实现了变量的线程安全。</p><p>​        单个状态变量时，使用原子变量可以保证安全，但是多个变量时不是由0到1 那么简单，。</p><h3 id="3-加锁机制"><a href="#3-加锁机制" class="headerlink" title="3. 加锁机制"></a>3. 加锁机制</h3><p>​        <strong>要保持状态的一致性，就需要在单个原子操作上保证更新所有的相关变量</strong>，翻译过来，就是接了个盘就得全部干完，并且一个子都不能少。</p><h5 id="3-1-内置锁"><a href="#3-1-内置锁" class="headerlink" title="3.1 内置锁"></a>3.1 内置锁</h5><p>​        内置锁就是所谓java的Synchronized关键字，是一种互斥锁，即锁住后只能单线程进入，其他线程阻塞。加锁位置和作用详见我的CSDN博客<a href="https://blog.csdn.net/Sheldon__Lee/article/details/100015597" target="_blank" rel="noopener">并发系列（五）Synchronized 和volatile</a></p><h5 id="3-2重入锁"><a href="#3-2重入锁" class="headerlink" title="3.2重入锁"></a>3.2重入锁</h5><p>​        重入的一种实现方法就是，为每一个锁关联一个计数器和线程持有者，0表示该锁没有被持有，线程持有之后为1，同一个线程再获取该锁，变为2，依次递增，退出时又递减，0时，锁将被释放。</p><p>​        重入的颗粒度是线程，不是调用，即线程可以持有一个锁好几次。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token keyword">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">son</span> <span class="token keyword">extends</span> <span class="token class-name">father</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token keyword">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果锁不支持重入，线程在son已经拿到了锁，要进入father的do（）方法，又需要锁，但锁已经用来进son了，那么就会出现进入son后等father的锁进入father，而father在等son的锁释放，陷入死锁。</span></code></pre><h1 id="4-用锁来保护状态"><a href="#4-用锁来保护状态" class="headerlink" title="4. 用锁来保护状态"></a>4. 用锁来保护状态</h1><p>​        用锁很重要，但记得用的是同一把锁哦！</p><h1 id="5-活跃性和性能"><a href="#5-活跃性和性能" class="headerlink" title="5. 活跃性和性能"></a>5. 活跃性和性能</h1><p>​        简单性就是编写代码简单不考虑太多，直接在外层加个大锁，不管该锁不该锁，反正锁了代码不会错。并发性就是代码要有效率，开销低，所以两者是要进行平衡，在保证代码”正确性”的情况下，尽可能的做到并发性。这个就算吃个人编码技能经验了，慢慢来呗，先写对，再优化。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> java </tag>
            
            <tag> Java并发编程实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：对象模型</title>
      <link href="/2019/09/08/git-dui-xiang-mo-xing/"/>
      <url>/2019/09/08/git-dui-xiang-mo-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-SHA"><a href="#1-SHA" class="headerlink" title="1. SHA"></a>1. SHA</h3><p>​        所有表示项目历史信息的文件，都是由40个字符的“对象名”来索引的,每一个对象名都是对对象内容做SHA1哈希计算得来的。</p><pre><code>6ff87c4664981e4397625791c8ea3bbb5f2279a3</code></pre><p>优势：</p><ul><li>只比较对象名，可快速判断对象是否相同</li><li>可以通过检查对象内容的SHA1的哈希值和“对象名”是否相同，来判断对象内容是否正确。</li></ul><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2.  对象"></a>2.  对象</h3><p>​        对象由三部分构成：</p><ul><li>类型<ul><li><strong>blob：</strong>存储文件数据，表示一个文件</li><li><strong>tree：</strong>类似目录，存储子目录（tree）和文件（blob）</li><li><strong>commit：</strong>只指向一个“tree”，标记项目某一个特定时间点的状态。</li><li><strong>tag：</strong>用来标记一个提交（commit）</li></ul></li><li>大小</li><li>内容</li></ul><h5 id="2-1-Blob对象"><a href="#2-1-Blob对象" class="headerlink" title="2.1 Blob对象"></a>2.1 Blob对象</h5><p>​            <img src="/2019/09/08/git-dui-xiang-mo-xing/object-blob.png" alt=""></p><ul><li><p>一个blob就是一块二进制数据，没有指向任何东西和任何其他属性，甚至没有文件名。</p></li><li><p>如果两个文件在同一个目录树中有相同的数据内容，它们将会共享同一个blob对象，与其对应的所在路径、文件名是否被更改完全没有关系。</p></li></ul><h5 id="2-2-Tree对象"><a href="#2-2-Tree对象" class="headerlink" title="2.2 Tree对象"></a>2.2 Tree对象</h5><p>​        一个tree对象拥有一串指向blob对象或是其他tree 对象的指针，一般表示内容之间的目录层次关系。</p><p>​        <img src="/2019/09/08/git-dui-xiang-mo-xing/object-tree.png" alt=""></p><p>​        tree对象的名称同样也是通过SHA1哈希值来命名的，当其两个tree对象的内容完全相同时，名称才会一样。</p><p>​        一个tree对象包括一串条目，条目包括：</p><ul><li>mode</li><li>对象类型</li><li>SHA1值</li><li>名字</li></ul><h5 id="2-3-Commit对象"><a href="#2-3-Commit对象" class="headerlink" title="2.3 Commit对象"></a>2.3 Commit对象</h5><p>​        commit对象指向一个tree对象，并且带有相关的描述信息。</p><p>​        <img src="/2019/09/08/git-dui-xiang-mo-xing/object-commit.png" alt=""></p><p>​        commit的组成部分：</p><ul><li><p><strong>tree</strong> ：tree对象的SHA1签名，代表着目录在某一时间点的内容</p></li><li><p><strong>parent：</strong>父对象，合并的提交可能会不止一个父对象，如果没有父对象，则称为“根提交”，代表项目的最初一个版本，每个项目至少一个根提交。</p></li><li><p><strong>author:</strong>本次修改的修改人，以及日期</p></li><li><p><strong>commiter：</strong>实际创建提交的人</p></li><li><p><strong>注释：</strong>用来描述此次提交</p><p>​        <strong>一个提交本身并没有任何信息来说明其做了哪些修改，所有的修改都是通过与父提交的内容比较得出的。</strong></p><p>​        <strong>一般用git commit来创建一个提交，这个提交的父对象一般是当前分支，同时把存储在当前索引（index）的内容全部提交。</strong></p><h5 id="2-4-标签对象"><a href="#2-4-标签对象" class="headerlink" title="2.4 标签对象"></a>2.4 标签对象</h5><p>​        一个标签对象包括一个对象名，对象类型，标签名，标签创建人的名字。</p><p>​    <img src="/2019/09/08/git-dui-xiang-mo-xing/object-tag.png" alt=""></p></li></ul><h3 id="3-对象模型"><a href="#3-对象模型" class="headerlink" title="3. 对象模型"></a>3. 对象模型</h3><p>​        项目的层次结构如下：</p><pre class=" language-shell"><code class="language-shell">$>tree.|-- README`-- lib    |-- inc    |   `-- tricks.rb    `-- mylib.rb2 directories, 3 files</code></pre><p>​        在Git中的存储层次如下：</p><p><img src="/2019/09/08/git-dui-xiang-mo-xing/image/objects-example.png" alt=""></p><h3 id="4-Git目录"><a href="#4-Git目录" class="headerlink" title="4. Git目录"></a>4. Git目录</h3><pre class=" language-shell"><code class="language-shell">$>tree -L 1.|-- HEAD         # 这个git项目当前处在哪个分支里|-- config       # 项目的配置信息，git config命令会改动它|-- description  # 项目的描述信息|-- hooks/       # 系统默认钩子脚本目录|-- index        # 索引文件|-- logs/        # 各个refs的历史信息|-- objects/     # Git本地仓库的所有对象 (commits, trees, blobs, tags)`-- refs/        # 标识你项目里的每个分支指向了哪个提交(commit)。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo：集群容错模式-负载均衡模式</title>
      <link href="/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/"/>
      <url>/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        Dubbo本身是一个开源的分布式服务框架，我们可以很容易的用来构建分布式服务，并根据实际业务场景选择合适的集群容错模式。</p><h3 id="2-Dubbo服务集群容错"><a href="#2-Dubbo服务集群容错" class="headerlink" title="2. Dubbo服务集群容错"></a>2. Dubbo服务集群容错</h3><p>采用集群容错模式的意义在于，当服务消费方发起调用申请之后，针对不同的错误情况，要有一套合理的配置架构来应对。</p><h5 id="2-1-Dubbo架构组件"><a href="#2-1-Dubbo架构组件" class="headerlink" title="2.1 Dubbo架构组件"></a>2.1 Dubbo架构组件</h5><p>Dubbo的架构组件图如下：</p><p><img src="/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/137084-20180507104753924-755727985.png" alt="img"></p><p>各组件关系如下：</p><ul><li>Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址以及Service接口信息。</li><li>Directory代表多个Invoker,可以将其看成List,但其值是动态变化的，比如注册中心的推送变更。</li><li>Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，但内部包含了容错逻辑。</li><li>Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等。</li><li>LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。</li></ul><h5 id="2-2-Dubbo支持的集群模式"><a href="#2-2-Dubbo支持的集群模式" class="headerlink" title="2.2 Dubbo支持的集群模式"></a>2.2 Dubbo支持的集群模式</h5><p>​    <strong>Dubbo 支持6中集群模式</strong></p><ul><li><p><strong><em>Failover Cluster</em></strong>模式</p><p>配置为failover,容错集群默认的选择，调用失败时，会自动切换，重新尝试调用其他节点上的可用服务，适用于一些幂等性操作，每次调用的副作用是相同的。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.shirdrn.dubbo.api.ChatRoomOnlineUserCounterService<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0.0<span class="token punctuation">"</span></span>     <span class="token attr-name">cluster</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>failover<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chatRoomOnlineUserCounterService<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryRoomUserCount<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>80<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>service</span><span class="token punctuation">></span></span></code></pre><ul><li>retries : 重试次数</li><li>timeout：服务级别调用超时时间</li><li>如果该服务中有其他方法，没有显示配置，则会继承服务级别的配置</li></ul></li><li><p><strong><em>Failfast Cluster</em></strong>模式</p><p>配置为failfast，称为快速失败模式，调用只执行一次，失败立即报错。适用于非幂等性操作，每次调用的副作用是不同的。</p></li><li><p><strong><em>Failsafe Cluster</em></strong>模式</p><p>配置为failsafe，失败安全模式，如果调用失败，则直接忽略失败的调用，而是要记录下失败的调用到日志文件，以便后续审计。</p></li><li><p><strong><em>Failback Cluster</em></strong>模式</p><p>配置为failback，失败自动恢复，后台记录失败请求，定时重发，常用于消息通知。</p></li><li><p><strong><em>Forking Cluster</em></strong>模式</p><p>配置为forking，并行调用多个服务器，只要一个成功即返回。常用于实时性要求较高的操作，但需要浪费更多资源。</p></li><li><p><strong><em>Broadcast Cluster</em></strong>模式</p><p>配置为broadcast，广播调用所有提供者，逐个调用，任意一台报错则错，常用于通知所有提供者更新缓存或日志等。</p></li><li><p><strong><em>定制化集群容错模式可以通过扩展Cluster接口实现</em></strong></p></li></ul><h5 id="2-3-Dubbo服务负载均衡"><a href="#2-3-Dubbo服务负载均衡" class="headerlink" title="2.3 Dubbo服务负载均衡"></a>2.3 Dubbo服务负载均衡</h5><p>​    <strong>Dubbo支持4种负载均衡策略</strong></p><ul><li><p><strong>Random LoadBalance:</strong>随机策略，配置值为random，可以设置权重。利于充分利用服务器资源，高配调大，低配调小。</p></li><li><p><strong>RoundRobin LoadBalance:</strong>轮询策略，配置值为roundrobin</p></li><li><p><strong>LeastActive LoadBalance:</strong>配置值为leastactive，根据请求调用的次数计数，处理请求更慢的节点会受到更少的请求。</p></li><li><p><strong>ConsistentHash LoadBalance:</strong>一致性Hash策略。相同调用参数的请求会发送到同一个服务提供的节点上，如果某个节点发生故障无法提供服务，则会基于一致性Hash算法映射到虚拟节点上。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.shirdrn.dubbo.api.ChatRoomOnlineUserCounterService<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0.0<span class="token punctuation">"</span></span>     <span class="token attr-name">cluster</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>failover<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>random<span class="token punctuation">"</span></span>     <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chatRoomOnlineUserCounterService<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryRoomUserCount<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>80<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>leastactive<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>service</span><span class="token punctuation">></span></span></code></pre><p><strong>loadbalance也存在继承关系，即子类策略会覆盖父级策略。自定义的策略要实现LoadBalance接口。</strong></p><h5 id="2-4-Dubbo服务管理和监控"><a href="#2-4-Dubbo服务管理和监控" class="headerlink" title="2.4 Dubbo服务管理和监控"></a>2.4 Dubbo服务管理和监控</h5><ul><li><p>Dubbo服务管理中心</p></li><li><p>Dubbo监控中心</p><p>​    </p></li></ul></li></ul><p><img src="/2019/09/01/dubbo-ji-qun-rong-cuo-mo-shi-fu-zai-jun-heng-mo-shi/137084-20180507104907461-623468070.png" alt="img"></p><p>管理中心和监控中心都可以通过安装的方式部署在tomcat上，这样就可以通过管理中心和监控中心来查看对应的详细情况。管理中心和注册中心是两个概念，管理中心可以调整提供者和消费者的状态以及其他设置，注册中心则用来提供注册，保证提供者的可见性，以及后续动态扩展的维护管理。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo：服务治理（入门篇）</title>
      <link href="/2019/08/31/dubbo-fu-wu-zhi-li/"/>
      <url>/2019/08/31/dubbo-fu-wu-zhi-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        <strong>Dubbo</strong>是阿里巴巴开源的一个高性能优秀的服务框架，采用非常简单的模型，将服务的提供方和消费方抽象为两个角色，可实现软负载均衡，并且还可选性的支持监控中心和调用管理中心，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和Spring框架无缝集成。</p><p>​        <strong>RPC</strong>（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p><p>​        相对于<strong>Http请求</strong>，良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。</p><h3 id="2-产生背景"><a href="#2-产生背景" class="headerlink" title="2. 产生背景"></a>2. 产生背景</h3><p><img src="/2019/08/31/dubbo-fu-wu-zhi-li/dubbo-architecture-1577678816466.png" alt=""></p><h5 id="2-1-架构演变"><a href="#2-1-架构演变" class="headerlink" title="2.1 架构演变"></a>2.1 架构演变</h5><p>​        随着互联网的发展，系统的架构也应业务需求和技术在不停的演变。</p><ul><li><p>单一应用架构（ORM）</p><ul><li>小网站，流量小，所有功能集中部署，节省节点和成本</li><li>数据访问框架（ORM）简化增删改查工作</li></ul></li><li><p>垂直应用架构（MVC）</p><ul><li>访问量增大时，将应用拆分为不相干的几个应用，以提升效率</li><li>Web框架加速前端页面开发</li></ul></li><li><p>分布式服务架构（RPC）</p><ul><li>垂直应用增多时，应用交互不可避免，将核心业务抽出，作为独立的服务，使前端更快速的响应需求变更</li><li>分布式服务框架（RPC）提高业务复用及整合</li></ul></li><li><p>流动计算架构</p><ul><li>服务增多时，容量评估和小服务资源浪费出现，需要调度中心基于访问压力实时管理集群容量，提高集群利用率。</li><li>资源调度和治理中心（SOA）提高机器利用率</li></ul></li></ul><h5 id="2-2-解决问题"><a href="#2-2-解决问题" class="headerlink" title="2.2 解决问题"></a>2.2 解决问题</h5><p><img src="/2019/08/31/dubbo-fu-wu-zhi-li/dubbo.png" alt="dubbo"></p><ul><li><p>服务增多，URL配置管理难度增加，F5硬件负载均衡器的单点压力增大</p><p>​    解决方案：</p><ul><li>配置服务注册中心，动态注册和发现服务，使服务位置透明</li><li>在消费方提供服务地址列表，实现负载均衡，降低F5硬件负载器的依赖，减少成本。</li></ul></li><li><p>服务间依赖关系错综复杂</p></li><li><p>服务调用的激增，无法正确预知服务容量，规划硬件配置</p><p>​    解决方案：</p><ul><li>配置服务监控，实时获取服务调用数据，合理规划硬件配置信息</li></ul></li></ul><h3 id="3-Dubbo"><a href="#3-Dubbo" class="headerlink" title="3. Dubbo"></a>3. Dubbo</h3><h5 id="3-1-架构"><a href="#3-1-架构" class="headerlink" title="3.1 架构"></a>3.1 架构</h5><p><img src="/2019/08/31/dubbo-fu-wu-zhi-li/1573544852818.png" alt="1573544852818"></p><p>架构特点：**</p><ul><li>基于透明接口的RPC</li><li>智能负载平衡</li><li>自动服务注册和发现</li><li>高扩展性</li><li>运行时流量路由</li><li>可视化服务治理</li><li><strong>远程通讯“：</strong>提供多种基于长连接的NIO框架抽象封装框架，包括多线程模型，序列化，以及请求-响应模式的信息交换方式。</li><li><strong>集群容错：</strong>提供基于接口方法的透明远程过程调用，包括多协议支持，软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>自动发现：</strong>基于注册中心目录服务，使服务消费方能动态查找服务提供方，使地址透明。</li><li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有API侵入。</li><li>软负载及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册和发现，不需写死服务提供方地址，注册中心基于接口查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><p><strong>节点介绍：</strong></p><ul><li><strong>Provider</strong> 暴露服务的服务提供方</li><li><strong>Consumer</strong> 调用远程服务的服务消费方</li><li><strong>Registry</strong>  服务注册与发现的注册中心 </li><li><strong>Monitor</strong> 统计服务的调用次数和调用时间的监控中心</li><li><strong>Container</strong>  服务运行容器</li></ul><p><strong>调用逻辑说明</strong>：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选一台进行调用。</li><li>服务消费者和服务提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p><strong>注册中心：</strong></p><p>​        注册中心用来进行服务的注册和进行负载均衡，dubbo提供了集中实现注册中心的方式：</p><ul><li>Multicast 注册中心</li><li><strong>Zookeeper 注册中心 （官方推荐）</strong></li><li>Redis 注册中心</li><li>Simple 注册中心</li></ul><h5 id="3-2-dubbo的简单使用（整合Spring）"><a href="#3-2-dubbo的简单使用（整合Spring）" class="headerlink" title="3.2 dubbo的简单使用（整合Spring）"></a>3.2 dubbo的简单使用（整合Spring）</h5><ol><li><p>导入POM文件</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dubbo.version</span><span class="token punctuation">></span></span>2.7.4.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dubbo.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.dubbo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>dubbo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${dubbo.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.dubbo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>dubbo-dependencies-zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${dubbo.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>这里使用了zookeeper注册中心。</p></li><li><p>定义服务层接口</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//service接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GreetingService</span> <span class="token punctuation">{</span>    String <span class="token function">sayHi</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对应实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GreetingsServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">GreetingsService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">sayHi</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"hi, "</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>服务容器加载服务提供者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String zookeeperHost <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"zookeeper.address"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ServiceConfig<span class="token operator">&lt;</span>GreetingsService<span class="token operator">></span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceConfig</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">setApplication</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ApplicationConfig</span><span class="token punctuation">(</span><span class="token string">"first-dubbo-provider"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">setRegistry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegistryConfig</span><span class="token punctuation">(</span><span class="token string">"zookeeper://"</span> <span class="token operator">+</span> zookeeperHost <span class="token operator">+</span> <span class="token string">":2181"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">setInterface</span><span class="token punctuation">(</span>GreetingsService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">setRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GreetingsServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"dubbo service started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>从服务容器中获取服务</p></li></ol><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String zookeeperHost <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"zookeeper.address"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceConfig<span class="token operator">&lt;</span>GreetingsService<span class="token operator">></span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceConfig</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reference<span class="token punctuation">.</span><span class="token function">setApplication</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ApplicationConfig</span><span class="token punctuation">(</span><span class="token string">"first-dubbo-consumer"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reference<span class="token punctuation">.</span><span class="token function">setRegistry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegistryConfig</span><span class="token punctuation">(</span><span class="token string">"zookeeper://"</span> <span class="token operator">+</span> zookeeperHost <span class="token operator">+</span> <span class="token string">":2181"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reference<span class="token punctuation">.</span><span class="token function">setInterface</span><span class="token punctuation">(</span>GreetingsService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        GreetingsService service <span class="token operator">=</span> reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String message <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"dubbo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Dubbo-与SpringCloud的差异与关系"><a href="#Dubbo-与SpringCloud的差异与关系" class="headerlink" title="Dubbo 与SpringCloud的差异与关系"></a>Dubbo 与SpringCloud的差异与关系</h3><p><a href="https://cloud.tencent.com/developer/article/1406001" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1406001</a></p><p><a href="https://segmentfault.com/a/1190000038320266" target="_blank" rel="noopener">https://segmentfault.com/a/1190000038320266</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper：分布式管理</title>
      <link href="/2019/08/24/zookeeper-fen-bu-shi-guan-li/"/>
      <url>/2019/08/24/zookeeper-fen-bu-shi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>  随着公司业务的不断增长，单机模式已经不足以处理当下的业务量，所以不得不采用多台服务器构成集群，来处理激增的业务量。集群在一定程度上能够分解单个服务器的处理压力，打破单机的性能瓶颈，提高系统服务的可用性。但分布式集群往往存在一些问题：</p><ul><li>不同于单机下，多个进程或线程在日志信息的保证下能够安全的处理同一资源，多台服务器处理属于不同的物理机,如何能够保证事务安全性，即比如如何保证多台服务器对于一个文件的写操作。</li><li>多台服务器下，如果一台宕机，如何保证其他服务器能接受其任务，如果保证业务激增时进行服务器扩展，能在不重启的情况下进行业务数据的迁移。</li><li>如何保证任务的均匀分配，保证任务执行的效率，实现负载均衡。</li><li>程序运行依赖于配置文件，不同物理机如何实现像数据库地址，黑名单控制，服务地址列表等这些配置文件的共享，并且修改后能即时达到数据一致。</li></ul><h1 id="2-Zookeeper简介"><a href="#2-Zookeeper简介" class="headerlink" title="2.Zookeeper简介"></a>2.Zookeeper简介</h1><p>  Zookeeper是一个<strong>分布式协调服务</strong>。单机上的协调都是进程内的协调，在进行内进行协调可以使用语言，平台，操作系统等提供的同步机制，保证单机内部多线程访问同一资源时的同步，实现多线程的协调。但分布式集群环境下，程序可能在不同的机器，机器可能不在同一个机房，机房又在不同的地域分布，这时候需要类似Zookeeper这类分布式协调服务来进行对集群的协调。</p><h2 id="2-1-存储结构"><a href="#2-1-存储结构" class="headerlink" title="2.1 存储结构"></a>2.1 存储结构</h2><p><img src="/2019/08/24/zookeeper-fen-bu-shi-guan-li/1567479565493-1574416654648.png" alt=""><br>zookeeper的数据是按照<strong>树</strong>的结构进行存储的，节点分为四种类型：</p><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td>PERSISTENT-持久化节点</td><td>在创建该节点的客户端与zookeeper断开后，该节点也不会被删除</td></tr><tr><td>PERSISTENT-SEQUENTIAL-持久化顺序编号节点</td><td>在请求创建节点时，会根据parent-znode的zxid状态，为该节点编写全目录唯一的编号，即使客户端断开，该节点不会被删除</td></tr><tr><td>EPHEMERAL-临时znode节点</td><td>客户端断开后，节点会被删除掉</td></tr><tr><td>EPHEMERAL_SEQUENTIAL-临时顺序编号znode节点</td><td>在请求创建节点时，会根据parent-znode的zxid状态，为该节点编写全目录唯一的编号，客户端断开时，该节点会被删除</td></tr></tbody></table><h2 id="2-2-znode"><a href="#2-2-znode" class="headerlink" title="2.2 znode"></a>2.2 znode</h2><ul><li>每一个znode默认存储1MB的数据</li><li>登陆zookeeper，可以通过ls、create、delete、sync等命令去操作这些节点<br>znode结构</li></ul><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td>zxid</td><td>时间戳，每次修改znode都会产生新的zxid</td></tr><tr><td>version</td><td>对节点的每次修改都会使得节点的版本号加1</td></tr><tr><td>data</td><td>每一个znode默认能够存储1MB的数据，对data的修改会引起两种的变化</td></tr><tr><td>tick</td><td>租约协议的具体体现，如果当前节点是“临时节点”，在trick时间周期内没有收到新的客户端租约，则视为无效</td></tr></tbody></table><h1 id="2-3-选举FastLeaderElection"><a href="#2-3-选举FastLeaderElection" class="headerlink" title="2.3 选举FastLeaderElection"></a>2.3 选举FastLeaderElection</h1><h1 id="2-4-监听机制"><a href="#2-4-监听机制" class="headerlink" title="2.4 监听机制"></a>2.4 监听机制</h1><p>  zookeeper的主要目的是统一分布式系统中各个节点的工作状态，在资源冲突的情况下协调提供节点资源抢占，给每个节点提供了解集群所处状态的途径，这都依赖于zookeeper中的时间监听和通知机制。</p><h2 id="2-4-1事件和状态"><a href="#2-4-1事件和状态" class="headerlink" title="2.4.1事件和状态"></a>2.4.1事件和状态</h2><p>  <strong>事件和状态构成了zookeeper客户端连接描述的两个维度。</strong></p><ul><li>事件：指zookeeper监听某一个znode节点，一但触发，就执行该事件所绑定的事情。</li><li>状态：指zookeeper与所连接的服务器之间的状态。</li><li>zookeeper客户端与server连接的状态</li></ul><table><thead><tr><th>连接状态</th><th>状态含义</th></tr></thead><tbody><tr><td>KeeperState.Expired</td><td>客户端和服务器在ticktime的时间周期内，要进行发送心跳通知，这是租约协议的一个实现，客户端发送request，告知服务器上一个租约时间，服务器接受之后，告知客户端下一个续租时间，当客户端到达最后一个续租时间事，没有收到服务端发来的新租约时间，即认为自己下线，这个过期状态即为Expired状态</td></tr><tr><td>KeeperState.Disconnected</td><td>当客户端断开一个连接（租约期满或者客户端主动离开），这时客户端和服务器的状态就是Disconnected</td></tr><tr><td>KeeperState.SynConnected</td><td>一旦客户端和服务器的一个节点建立连接，并完成一次version、zxid的同步。该状态就是这个</td></tr><tr><td>KeeperState.AuthFailed</td><td>zookeeper客户端进行连接认证失败时，发生该状态</td></tr><tr><td><strong>备注：这些状态触发时，所记录的事件类型都是：EventType.Node.</strong></td><td></td></tr></tbody></table><p>-zookeeper中的事件，当zookeeper客户端监听某个znode节点时：<br>|zookeeper事件|含义|<br>|—|—|<br>|EventType.NodeCreated|当这个节点被创建时，事件触发|<br>|EventType.NodeChildrenChanged|当这个节点的直接子节点被创建、删除、子节点数据被变更时，触发该事件|<br>|EventType.NodeDataChange|当这个节点的数据发生变更时，该事件被触发|<br>|EventType.NodeDeleted|当这个节点被删除时，该事件被触发|<br>|EventType.None|当zookeeper的客户端连接状态发生变更时，即上述几个状态之间互相切换时|</p><h2 id="2-5-watcher机制"><a href="#2-5-watcher机制" class="headerlink" title="2.5 watcher机制"></a>2.5 watcher机制</h2><p>  zookeeper建立节点监听可采用的方法有：</p><ul><li>zk.getChilren(path,watch)</li><li>zk.exists(path, watch)</li><li>zk.getData(path,watch,stat)</li><li>zk.register(watcher)注册默认监听</li></ul><p>  <strong>以上的注册方式，都可以对Event.Type事件进行监听，如果注册多个监听器，则它们都会收到Event.Node事件。</strong></p><ul><li>注册方法与监听事件间的关系</li></ul><table><thead><tr><th>注册方式</th><th>NodeCreated</th><th>NodeChildrenChanged</th><th>NodeDataChanged</th><th>NodeDeleted</th></tr></thead><tbody><tr><td>zk.getChildren(“”,watcher)</td><td></td><td>可监控</td><td></td><td>可监控</td></tr><tr><td>zk.exists(“”,watcher)</td><td>可监控</td><td></td><td>可监控</td><td>可监控</td></tr><tr><td>zk.getData(“”,watcher)</td><td>悖论</td><td></td><td>可监控</td><td>可监控</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><p>当一个watcher实例多次注册一个节点时，zkClient只通知一次，当多个不同watcher实例注册同一个节点时，zkClient会依次进行通知。</p></li><li><p>监控同一个节点的一个watcher实例，通过exist、getData等多种注册方式注册时，zkClient也只会通知一次。</p><h1 id="3-作用"><a href="#3-作用" class="headerlink" title="3. 作用"></a>3. 作用</h1></li><li><p><strong>配置管理</strong><br>  程序中往往存在众多的配置信息，众多服务器依赖于该配置文件，zookeeper的作用就是对这些配置文件进行集中管理，将配置文件提取放置一个地方，对其进行监听，当配置信息发生改变时，受zookeeper管理的服务器将会受到通知，然后服务器获取新的配置信息。zookeeper使用了Zab这种一致性协议来保证配置在集群中的一致性。</p></li><li><p><strong>命名服务</strong><br>  在集群和分布式环境下，zookeeper能够简化子项目之间的调用关系，不至于出现不知道哪个调哪个，可以集中精力去处理业务逻辑。在集群中，相同的一个服务有很多个提供者，当提供者启动时，其相关信息（接口，地址，端口等）会注册到zookeeper中，当消费者需要消费时，再依据负载均衡机制选择一个服务者提供服务。</p></li><li><p><strong>分布式锁</strong><br>  zookeeper可以用来协调多个分布式进程之间的活动，一件事情交给多个服务器进行处理时，就需要进行分布式的同步，某个时刻只让一个服务去干活，出现问题时，立马释放分布式锁，交由其他服务器进行处理。其处理策略一般被称为<strong>选举机制</strong>。</p></li><li><p><strong>集群管理</strong><br>  分布式集群中，处于各种原因，节点总是在变化，集群中的其他机器需要动态的感知当前集群中的状态。像在一个分布式存储系统中，存在一个中央控制节点负责存储的分配，其依赖于感知集群节点的变化。</p></li></ul><p>参考博客：<a href="https://blog.csdn.net/tang06211015/article/details/51850516" target="_blank" rel="noopener">Zookeeper场景分析及实例代码</a><br>    <a href="https://blog.csdn.net/yinwenjie/article/details/47361419" target="_blank" rel="noopener">  zookeeper单点和集群安装</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring：异步通知</title>
      <link href="/2019/08/16/spring-yi-bu-tong-zhi/"/>
      <url>/2019/08/16/spring-yi-bu-tong-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        公司最近给主模块搞一个系统通知的功能，要求设计并对接各大分模块的消息通知，要求是分模块业务执行过程中会触发消息插件，将消息推送到系统通知的消息存储区域，但是一旦业务执行失败，业务会进行回滚，但是消息已经发出去了，显然不合理。因此配合事务，最后采用Spring事务异步进行发送的方式搞定，即业务执行完毕之后事务提交，则进行消息的异步推送。</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>​            直接上代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SystemRemindMessageHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//采用log4j进行日志保存</span>    <span class="token keyword">static</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>SystemRemindMessageHandler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//采用ThreadLocal为每个线程保存相关的 异步线程集合</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Runnable<span class="token operator">>></span> RUNNABLES <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> RealTimeRemindMapper realTimeRemindMapper<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> RemindMapper remindMapper<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Spring注入</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">setRealTimeRemindMapper</span><span class="token punctuation">(</span>RealTimeRemindMapper realTimeRemindMapper<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SystemRemindMessageHandler<span class="token punctuation">.</span>realTimeRemindMapper <span class="token operator">=</span> realTimeRemindMapper<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//Spring注入</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">setRemindMapper</span><span class="token punctuation">(</span>RemindMapper remindMapper<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SystemRemindMessageHandler<span class="token punctuation">.</span>remindMapper <span class="token operator">=</span> remindMapper<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//使用锁保证并行消息发送的安全性</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>RemindMessageVo messageVo<span class="token punctuation">,</span> String className<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建线程</span>        SystemRemindMessageHandler<span class="token punctuation">.</span>MessageRunner runner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SystemRemindMessageHandler<span class="token punctuation">.</span>MessageRunner</span><span class="token punctuation">(</span>messageVo<span class="token punctuation">,</span> className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果当前不存在事务，则直接进行消息的保存</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>TransactionSynchronizationManager<span class="token punctuation">.</span><span class="token function">isSynchronizationActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            CommonThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runner<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//获取当前线程的异步线程集合</span>        List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> runnables <span class="token operator">=</span> RUNNABLES<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果没有当前线程的异步线程集合，则创建</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>runnables <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            runnables <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//创建好的集合加入ThreadLocal</span>            RUNNABLES<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>runnables<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置事务触发的动作</span>            TransactionSynchronizationManager<span class="token punctuation">.</span><span class="token function">registerSynchronization</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionSynchronizationAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//重写事务提交后的动作</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//拿到当前线程的异步线程集合，遍历全部执行，消息推送</span>                    List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> runnables <span class="token operator">=</span> RUNNABLES<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> runnables<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        Runnable runnable <span class="token operator">=</span> runnables<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        CommonThreadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//重写完成方法，移除当前线程的异步线程集合</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">{</span>                    RUNNABLES<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果当前线程存在异步线程集合，则加入</span>        runnables<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>runner<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//静态内部类</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MessageRunner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> RemindMessageVo mess<span class="token punctuation">;</span>        <span class="token keyword">private</span> String className<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">MessageRunner</span><span class="token punctuation">(</span>RemindMessageVo _mess<span class="token punctuation">,</span> String _className<span class="token punctuation">)</span><span class="token punctuation">{</span>            mess <span class="token operator">=</span> _mess<span class="token punctuation">;</span>            className <span class="token operator">=</span> _className<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String oldName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//修改线程名，以便于日志打印问题</span>            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"SYSTEMREMIND-MESSAGEHANDLER-"</span> <span class="token operator">+</span> mess<span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span><span class="token punctuation">{</span>                Long systemRemindId <span class="token operator">=</span> remindMapper<span class="token punctuation">.</span><span class="token function">getRemindIdByClassName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>systemRemindId <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> systemRemindId <span class="token operator">!=</span>0L<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//此处进行省略，为消息发送业务代码</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"找不到动态消息组件："</span> <span class="token operator">+</span> className<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span><span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//恢复线程名称</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>oldName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>参考博客：<a href="https://segmentfault.com/a/1190000004235193" target="_blank" rel="noopener">如何在数据库事务提交成功后进行异步操作</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
            <tag> 框架 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring：事务</title>
      <link href="/2019/08/10/spring-shi-wu/"/>
      <url>/2019/08/10/spring-shi-wu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据库知识点"><a href="#1-数据库知识点" class="headerlink" title="1. 数据库知识点"></a>1. 数据库知识点</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><ul><li>数据库管理系统一般采用重执行日志保证原子性，一致性和持久性</li><li>和java程序采用对象锁进行线程同步类似，数据库管理系统采用数据库锁机制保证事务的隔离性，多个事务修改数据，只有持有锁的事务才可以。</li></ul><h4 id="1-2-数据并发问题"><a href="#1-2-数据并发问题" class="headerlink" title="1.2 数据并发问题"></a>1.2 数据并发问题</h4><h4 id="1-2-1-读数据"><a href="#1-2-1-读数据" class="headerlink" title="1.2.1 读数据"></a>1.2.1 读数据</h4><table><thead><tr><th>类型</th><th>介绍</th></tr></thead><tbody><tr><td>脏读</td><td>A事务读取B事务未提交的更改数据，B事务选择回撤。</td></tr><tr><td>不可重复读</td><td>一个事务范围内，两次相同的查询，返回了不同的值，这是由于查询系统时，其他事务修改了行数据导致的，使用行级锁可以解决。</td></tr><tr><td>幻象读</td><td>两次读取之间，其他事务添加了一行数据，表级锁可以解决。</td></tr></tbody></table><p>​        <strong>幻读指读到新增的数据（数据是一行一行的新增），不可重复读指读到了已提交事务的更改数据（变更删除针对行数据的某些字段）</strong></p><h4 id="1-2-2-更新数据"><a href="#1-2-2-更新数据" class="headerlink" title="1.2.2 更新数据"></a>1.2.2 更新数据</h4><table><thead><tr><th>类型</th><th>介绍</th></tr></thead><tbody><tr><td>第一类丢失更新</td><td>A事务撤销时，将B事务提交的数据覆盖掉了。</td></tr><tr><td>第二类丢失更新</td><td>A事务提交时，将B事务提交的数据覆盖掉了。</td></tr></tbody></table><h4 id="1-3-数据库锁机制"><a href="#1-3-数据库锁机制" class="headerlink" title="1.3 数据库锁机制"></a>1.3 数据库锁机制</h4><p><img src="/2019/08/10/spring-shi-wu/Screenshot1520500121%5B1%5D.png" alt=""></p><table><thead><tr><th>标题</th><th>解释</th></tr></thead><tbody><tr><td>悲观锁</td><td>认为自身在修改数据时，一定会有人来修改，所以要加锁保证不被修改</td></tr><tr><td>乐观锁</td><td>一般指用户自己实现的一种锁机制，假定数据不会冲突，在数据提交更新的时候才会进行检测，如果发现冲突，就返回用户错误的信息。</td></tr><tr><td>表级锁</td><td>整个表加锁</td></tr><tr><td>页级锁</td><td>BerkeleyDB存储引擎，开销、加锁和粒度介于表锁和行锁之间，会出现死锁，并发度一般。</td></tr><tr><td>行级锁</td><td>整行数据加锁</td></tr><tr><td>共享锁</td><td>数据库<strong>查询</strong>一条数据时，数据库系统会对该行进行锁定，读操作中允许其他事务同时更新表中未锁定的行<br>    资源上放置共享锁，还能再放置共享锁和更新锁<br>    具有良好的并发性，被放置共享锁之后，还可以再放置共享锁和更新锁，并发性较好。</td></tr><tr><td>排他锁</td><td>当更新数据库数据时，系统会为变更资源添加独占锁，如果该资源被锁定，就无法再对其放置独占锁。<br>    独占锁不能与其他锁兼容，即只能放一个独占锁<br>    并发性最差，运行单事务访问，其他事务访问要等待。</td></tr><tr><td>更新锁</td><td>更新sql，会对资源先进行加共享锁，用于数据查询，之后进行数据更新时，共享锁升级为独占锁。<br>    两个事务都获取了同一数据资源的共享锁，然后升级为独占锁时，需要等待共享锁的解除，这就造成了死锁。<br>    更新锁和共享锁是兼容的额，资源可同时放更新锁和共享锁，但最多放置一把更新锁<br>    允许多个事务同时读锁定的资源，但不允许其他事物修改它。</td></tr><tr><td></td><td>意向锁的目的是保证表锁和行锁的共存<br>    当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁，如果需要的是某行的排他锁定，则申请一个意向排他锁。<br>   意向锁是表级别锁<br><a href="https://blog.csdn.net/zcl_love_wx/article/details/82015281" target="_blank" rel="noopener"><strong>一分钟深入Mysql的意向锁——《深究Mysql锁》</strong></a></td></tr></tbody></table><h4 id="1-4-数据库事务隔离机制"><a href="#1-4-数据库事务隔离机制" class="headerlink" title="1.4 数据库事务隔离机制"></a>1.4 数据库事务隔离机制</h4><ul><li>Read Uncommitted 读写均不使用锁，拥有最高的并发性和吞吐性</li><li>Read Committed 使用写锁，保证不会出现脏读，但会造成不可重复读，即读不加锁时，中间会有事务去改变读的数据（行级），造成两次读取不一致。</li><li>Repeatable Read 使用读锁和写锁，解决不可重复读的问题，但会有幻读（表级）。</li><li>Serializable 使用事务串形化调度，避免出现因为插入数据没法加锁导致的不一致的情况</li></ul><h3 id="2-Spring事务"><a href="#2-Spring事务" class="headerlink" title="2.Spring事务"></a>2.Spring事务</h3><h4 id="2-1-Spring对事务的支持"><a href="#2-1-Spring对事务的支持" class="headerlink" title="2.1 Spring对事务的支持"></a>2.1 Spring对事务的支持</h4><ul><li><p>Spring事务提供了事务模板类TransactionTemplate，通过该模板配合事务回调TransactionCallback指定具体的持久化操作就可以通过编程方式，实现事务管理。</p></li><li><p>面对单数据源情况下，Spring直接使用底层额数据源管理事务。</p></li><li><p>面对多数据源的应用时，Spring寻求JavaEE应用服务器的支持。通过引用应用服务器中的JNDI资源完成JTA事务。</p></li><li><p>Spring事务管理的优势在于，都采用相同事务管理模型，用户可以抛开事务管理的问题编写程序。</p></li></ul><h4 id="2-2-事务管理关键抽象"><a href="#2-2-事务管理关键抽象" class="headerlink" title="2.2 事务管理关键抽象"></a>2.2 事务管理关键抽象</h4><h5 id="2-2-1-PlatformTransactionManager"><a href="#2-2-1-PlatformTransactionManager" class="headerlink" title="2.2.1 PlatformTransactionManager"></a>2.2.1 PlatformTransactionManager</h5><ul><li><p>getTransaction(TransactionDefinition definition) 返回或者创建一个新事务，通过TransactionStatus描述事务的状态。</p></li><li><p>commit（TransactionStatus status）根据事务状态提交事务</p></li><li><p>rollback（TransactionStatus status） 将事务回滚，commit抛出异常时，rollback被隐式调用</p></li></ul><h5 id="2-2-2-TransactionDefinition"><a href="#2-2-2-TransactionDefinition" class="headerlink" title="2.2.2 TransactionDefinition"></a>2.2.2 TransactionDefinition</h5><p>​        用于描述事务的隔离机制，超时时间，是否为只读事务，传播规则等具体控制事务的事务属性，通过xml配置或者注解提供</p><ul><li><p>事务隔离级别</p><table><thead><tr><th>级别</th><th>解释</th></tr></thead><tbody><tr><td>ISOLOCATION_DEFAULT</td><td>数据库默认级别</td></tr><tr><td>ISOLOCATION_READ_UNCOMMITTED</td><td>允许读取未提交的读， 可能导致脏读，不可重复读，幻读</td></tr><tr><td>ISOLOCATION_READ_COMMITTED</td><td>允许读取已提交的读，可能导致不可重复读，幻读</td></tr><tr><td>ISOLOCATION_REPEATABLE_READ</td><td>不能更新另一个事务修改单尚未提交(回滚)的数据，可能引起幻读</td></tr><tr><td>ISOLOCATION_SERIALIZABLE</td><td>序列执行效率低</td></tr></tbody></table></li><li><p>传播级别</p><table><thead><tr><th>级别</th><th>解释</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>当前没有事务就新建，有事务就加入</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，没有就以非事务方式执行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前事务，没有就抛出异常</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，当前存在事务，就将其挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操纵，如果当前存在事务，就将当前事务挂起</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果存在事务，则抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>当前有事务，就嵌套事务内执行，若没有，则执行PROPAGATION_REQUIRED类似的操作</td></tr></tbody></table></li><li><p>事务超时</p><p>​    事务在超时前能运行多久，超过时间后，事务被回滚</p></li><li><p>只读状态</p><p>​    只读事务不修改任何数据</p><h5 id="2-2-3-TransactionStatus"><a href="#2-2-3-TransactionStatus" class="headerlink" title="2.2.3 TransactionStatus"></a>2.2.3 TransactionStatus</h5><p>​      代表一个事务的运行状态，事务管理器通过该接口获取事务运行器的状态信息，可以间接通过该接口回滚事务。</p><pre><code>           -  继承于SavepointManager接口</code></pre><ul><li>Object createSavePoint()</li><li>void rollbackToSavepoint(Object savepoint)  被回滚的保存点将会自动释放</li><li>void releaseSavepoint(Object savepoint) 事务提交后，将会自动释放保存点</li></ul></li><li><p>TransactionStatus扩展</p><ul><li>boolean hasSavepoint()  是否有保存点</li><li>Boolean isNewTransaction 当前事务是否为新事务</li><li>boolean isCompleted 当前事务是否已经提交/回滚</li><li>Boolean i是Rollback Only 是否识为rollback-only<ul><li>setRollbackOnly 将当前事务设置为rollback-only,该事务将只能进行回滚</li></ul></li></ul></li><li><p>底层资源不支持保存点时，会抛出Nested Transaction NotSupported Exception</p></li></ul><h4 id="2-3-配置事务（针对注解）"><a href="#2-3-配置事务（针对注解）" class="headerlink" title="2.3 配置事务（针对注解）"></a>2.3 配置事务（针对注解）</h4><h5 id="2-3-1-使用注解配置事务"><a href="#2-3-1-使用注解配置事务" class="headerlink" title="2.3.1 使用注解配置事务"></a>2.3.1 使用注解配置事务</h5><ul><li>可对需要事务增强的Bean接口，实现类，方法进行标注。</li><li>注解只提供元数据，不能完成事务切面织入功能</li><li>配置文件增加 <ul><li>&lt;tx:annotation-driven /&gt; 以织入事务管理切面</li><li>proxy-target-class:  Spring  将创建子类来代替业务类，即采用CGLib动态代理,动态字节码技术， false 则采用基于接口的代理，即jdk动态代理</li><li>order ： 除了事务切面外，如果加其他切面，该项用于控制织入顺序</li></ul></li></ul><h5 id="2-3-2-Transactional"><a href="#2-3-2-Transactional" class="headerlink" title="2.3.2 @Transactional"></a>2.3.2 @Transactional</h5><ul><li><p>默认属性</p><table><thead><tr><th>内容</th><th>设置</th></tr></thead><tbody><tr><td>事务传播行为</td><td>PROPAGATION_REQUIRED</td></tr><tr><td>事务的隔离机制</td><td>ISOLATION_DEFAULT</td></tr><tr><td>读写事务属性</td><td>读/写事务</td></tr><tr><td>超时时间</td><td>依赖底层事务系统的默认值</td></tr><tr><td>回滚设置</td><td>运行期异常引发回滚，检查型异常不会引发回滚</td></tr></tbody></table><ul><li>事务只有在发生未捕获的RuntimeException时才回滚</li><li>默认情况下aop只捕获RuntimeException的异常，但可以通过配置来捕获特定的异常并回滚<ul><li>通过 throw new RuntimeException() 抛出运行时异常</li><li>TransactionAspectSupport.currentTransactionStatus.setRollbackOnly(); 手动回滚</li><li>@Transactional（readyOnly = true, rollbaclFor = Exception.class）</li></ul></li></ul></li><li><p>属性说明</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>枚举方式提供事务传播行为</td></tr><tr><td>isolation</td><td>枚举方式，提供事务隔离机制</td></tr><tr><td>readOnly</td><td>事务读写性 boolean 类型</td></tr><tr><td>timeout</td><td>超时时间 int 秒</td></tr><tr><td>rollbackFor</td><td>一组异常类，遇到回滚，逗号隔开 Class&lt;? extends Throwable&gt;[]类型, 默认[]</td></tr><tr><td>rollbackForClassName</td><td>一组异常类。遇到回滚，类型为String[]</td></tr><tr><td>noRollbackForClassName</td><td>同上</td></tr><tr><td>noRollBackFor</td><td>同上</td></tr></tbody></table></li><li><p>位置说明</p><ul><li>基于JDK动态代理 ，可以将@Transactional放置在接口和具体类上，jdk动态代理的实现方式是基于接口实现的，大概流程是。<ul><li>为接口创建代理类的字节码文件</li><li>使用ClassLoader将字节码文件加载到JVM中</li><li>创建代理类实例对象，执行对象的目标方法。</li><li>使用的是反射技术</li></ul></li><li>基于CGLIB类代理，只能将@Transactional放置在具体类上，cglib可以直接代理类，使用的是字节码技术。</li><li>Spring默认用的是基于jdk动态代理。</li><li>注解不能被继承，如果采用CGLib类代理，即proxy-target-class 为true，如果事务注解加到接口上，业务类不会添加事务增强。</li></ul></li><li><p>除有public之外的方法，均不能被事务增强，包括 public static 也不能被增强</p></li><li><p>对于final static private 修饰的方法不能被子类覆盖，相应的无法实施AOP</p></li><li><p>这些不能被Spring事务增强的方法，并非不工作在事务中，只要被外部事务调用，由于Spring的传播机制，内部方法也可以工作在外部方法所启动的事务上下文中。</p></li><li><p>能被增强和不能被增强的唯一区别在于，是否可以主动启动一个新事务，前者可以，后者不能。 针对事务传播行为来说，两者是一样的。 即，如果这些方法被无事务上下文调用，则工作在无事务上下文中，否则，就工作在事务上下文中</p><h4 id="2-4-常见问题汇总"><a href="#2-4-常见问题汇总" class="headerlink" title="2.4 常见问题汇总"></a>2.4 常见问题汇总</h4><ol><li><p>在AOP增强过程中，一个类的两个方法A,B都通过AOP进行了增强，但当A调用B时，不会触发B的增强代码。</p><p><strong>原因</strong>：通过AOP进行增强时，所本质是基于动态代理技术，当外部调用方法A时，本质是代理对象进行调用，所以A方法会得到增强，当A调用B方法时，当前的对象并非代理对象，所以要重新获取代理对象。</p><pre class=" language-java"><code class="language-java">Object proxy <span class="token operator">=</span> AopContent<span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//补充：获取当前的被代理类</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> AopUtils<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span></code></pre><p><strong>注意：</strong> 在Spring的配置文件中要进行一下设置，目的是可以通过AopContent拿到代理</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span> <span class="token attr-name">expose-proxy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">></span></span></code></pre></li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring：抽象类的依赖Bean注入</title>
      <link href="/2019/08/03/spring-chou-xiang-lei-de-yi-lai-bean-zhu-ru/"/>
      <url>/2019/08/03/spring-chou-xiang-lei-de-yi-lai-bean-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​            抽象类在Spring启动时并不会被实例化，固不能采用@Service等注解将其注入，保证其他依赖Bean的注入。所以要采用set方法注入依赖Bean中。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> FlowMapper flowMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFlowMapper</span><span class="token punctuation">(</span>FlowMapper _flowMapper<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>flowMapper <span class="token operator">=</span> _flowMapper<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：并发类与接口概述</title>
      <link href="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/"/>
      <url>/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        学习和使用多线程的过程中，遇到很多的类和接口，以下将其进行梳理做概括性描述，方便后期回顾。</p><h3 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h3><h5 id="2-1-Thread"><a href="#2-1-Thread" class="headerlink" title="2.1 Thread"></a>2.1 Thread</h5><p>​        线程类，实现了Runnable接口， 常用于多个线程做多个任务，各做各的（通过static可以实现多个线程做一个任务）。</p><p>​        该类在jdk1.0的时候就已经存在，是创建线程的方式之一，它实现了Runnable接口。可以通过继承Thread类，重写run方法来创建一个线程，实现类调用start()方法便可以启动一个新的线程，同样它的构造方法也可以接受一个Runnable类型的参数创建一个线程。</p><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805144649941%5B1%5D.png" alt=""></p><h5 id="2-2-FutureTask"><a href="#2-2-FutureTask" class="headerlink" title="2.2 FutureTask"></a>2.2 FutureTask</h5><p>​        该类直接实现了RunnableFuture接口，间接实现了Runnble和Future接口。因为实现了Runnbale接口，因此其对象可以作为参数被传递给Thread类启动一个线程，作为Future的一个实现类，调用get()方法拿到线程的执行结果。<br>​        其构造函数可以接受一个Callable类型的参数。</p><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805153659851%5B1%5D.png" alt=""></p><h5 id="2-3-Executors"><a href="#2-3-Executors" class="headerlink" title="2.3 Executors"></a>2.3 Executors</h5><p>​        该类是一个工具类，通过静态方法可以获取到java自带的几种线程池。</p><h5 id="2-4-ExecutorCompletionService"><a href="#2-4-ExecutorCompletionService" class="headerlink" title="2.4 ExecutorCompletionService"></a>2.4 <strong>ExecutorCompletionService</strong></h5><p>​        该类是接口CompletionService的唯一实现类，总的来说，相对于ExecutorService，该类内部会有一个队列，每当任务提交时，该类会调用Executor进行执行，如果任务执行完毕，其结果future对象便会加入到该队列之中，确保该队列获取到的future对象都是已经完成的，以便于进行后续的工作。但是ExecutorServiece执行完毕的之后的Future有可能只是一个空的壳子，内部线程未执行完毕，这时调用get（）方法可能会阻塞，阻碍获取后续已经完成的Future的对象。</p><h3 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h3><h5 id="3-1-Runnable"><a href="#3-1-Runnable" class="headerlink" title="3.1 Runnable"></a>3.1 <strong>Runnable</strong></h5><p>​        该接口也是一个顶层接口，只有一个run方法,创建线程的方式之一就是实现该类，重写run方法，将实现类作为参数，传递给Thread的构造方法启动一个新的线程，同样在jdk1.0中就已经出现。</p><p>​    <strong>备注：通过继承Thread类型实现的多线程，大多是多个线程去做多件事情。而通过实现Runnale接口的多线程，一般是多个线程去做同一件事情，即将一个实现类交给多个线程去运行。</strong></p><h5 id="3-2-Callable"><a href="#3-2-Callable" class="headerlink" title="3.2 Callable"></a>3.2 <strong>Callable</strong></h5><p>​        该接口出现于jdk1.5，目的是作为Runnable的替换类，该类支持执行方法call()返回执行结果，而Runnable方法的run()的返回类型为void。</p><pre class=" language-java"><code class="language-java">V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span></code></pre><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805151420132.png" alt=""></p><h5 id="3-3-Future"><a href="#3-3-Future" class="headerlink" title="3.3 Future"></a>3.3 Future</h5><p>​        该接口同样出现在jdk1.5，配合与Callable使用，Callable的作用是产生结果，而Future的作用则是获取结果。并且该接口设计一种新的模式。</p><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805151901429%5B1%5D.png" alt=""></p><h5 id="3-4-Executor"><a href="#3-4-Executor" class="headerlink" title="3.4 Executor"></a>3.4 <strong>Executor</strong></h5><p>​        多线程的顶层接口，仅有一个方法，接受的是Runnable类型的参数，像ThreadPoolExecutor, ExecutorService 等都是继承或实现了该接口。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="3-5-ExecutorService"><a href="#3-5-ExecutorService" class="headerlink" title="3.5 ExecutorService"></a>3.5 <strong>ExecutorService</strong></h5><p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805154624625%5B1%5D.png" alt=""></p><p>​        该接口是对Executor接口的扩展，其submit()方法支持接受Callable类型参数，运行后的结果将会返回到Future中。</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//支持callable集合的传递，将会返回一个Future的list</span><span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                                  <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">;</span><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">,</span>                    <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException<span class="token punctuation">;</span></code></pre><h5 id="3-6-CompletionService"><a href="#3-6-CompletionService" class="headerlink" title="3.6 CompletionService"></a>3.6 <strong>CompletionService</strong></h5><p>​        该接口仅有一个实现类，该接口作用类似于ExecutorService，但是不同于ExecutorServic</p><img src="/2019/07/20/java-bing-fa-bing-fa-lei-yu-jie-kou/20190805155750310.png" style="zoom:150%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：安全队列</title>
      <link href="/2019/07/13/java-bing-fa-an-quan-dui-lie/"/>
      <url>/2019/07/13/java-bing-fa-an-quan-dui-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        多线程编程中很多地方都是用到了安全队列，故简单做一个总结概括，方便后面查阅。</p><p>​        队列这种数据结构不必做过多解释，安全队列的目的在于在多线程中存在消费者生产者模式，即多个生产者（生产者线程）生产东西，多个消费者（消费者线程）进行消费，这时需要一个中间空间去暂存，这时就需要考虑使用安全队列，保证其流程的安全性。</p><p>​        线程安全的类是指，类内共享的全局变量的访问必须保证是不收多线程形式的影响。</p><h3 id="2-阻塞算法"><a href="#2-阻塞算法" class="headerlink" title="2. 阻塞算法"></a>2. 阻塞算法</h3><h5 id="2-1-方法介绍"><a href="#2-1-方法介绍" class="headerlink" title="2.1 方法介绍"></a>2.1 方法介绍</h5><ul><li><p><strong>可能抛异常</strong>：不满足约束条件时抛异常，如队列满了继续加，会抛异常</p><ul><li>add(e)</li><li>remove()</li><li>element()</li></ul></li><li><p><strong>返回布尔值</strong>:不阻塞，不抛异常，满了继续加返回false</p><ul><li>offer(e)</li><li>poll()</li><li>peek()</li></ul></li><li><p><strong>阻塞方法：</strong> 不满足约束条件，会发生阻塞</p><ul><li>put()</li><li>take()</li></ul></li><li><p><strong>设定等待时间：</strong></p><ul><li>offer(e, timeout, unit)</li><li>poll(timeout, unit)</li></ul></li></ul><p><img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20191009173338129%5B1%5D.png" alt=""></p><h5 id="2-2-阻塞队列（BlockingQueue）"><a href="#2-2-阻塞队列（BlockingQueue）" class="headerlink" title="2.2 阻塞队列（BlockingQueue）"></a>2.2 阻塞队列（BlockingQueue）</h5><ul><li><p><strong>ArrayBlockingQueue</strong></p><p>​    <img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20190805172222378%5B1%5D.png" alt=""></p></li><li><p><strong>LinkedBlockingQueue</strong></p><p><img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20190805172336321%5B1%5D.png" alt=""></p><p>​    <strong>备注： 阻塞算法虽然使用了锁机制，但底层实质上还是CAS算法。</strong></p></li></ul><h5 id="2-3-非阻塞队列（ConcurrentLinkedQueue-）"><a href="#2-3-非阻塞队列（ConcurrentLinkedQueue-）" class="headerlink" title="2.3 非阻塞队列（ConcurrentLinkedQueue ）"></a>2.3 非阻塞队列（<strong>ConcurrentLinkedQueue</strong> ）</h5><p><img src="/2019/07/13/java-bing-fa-an-quan-dui-lie/20190805172704363.png" alt=""></p><h5 id="2-4-补充"><a href="#2-4-补充" class="headerlink" title="2.4 补充"></a>2.4 补充</h5><p>​        在消费者生产者模式下，有可能消费者不知道什么时候生产者会生产完毕，如果选择阻塞队列通过阻塞方法获取，如果队列中没有元素存在，可能消费者会被一直阻塞，进而无法下面的系列操作。之前查询获得一种解决办法，被称为“毒丸”策略。<br>​        在生产者生产结束后，可以加一个特殊的对象（“毒丸”）到队列中，当消费者获取到该对象时，表明队列中已经没有了对象，这时该消费者进行线程结束，并且将该对象加入到队列之中，等待其他消费者线程获取，这样就能依次关闭所有的消费者线程。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：CountDownLatch、CyclicBarrier、Semaphore实现分析</title>
      <link href="/2019/07/10/java-bing-fa-countdownlatch-cyclicbarrier-semaphore-shi-xian-fen-xi/"/>
      <url>/2019/07/10/java-bing-fa-countdownlatch-cyclicbarrier-semaphore-shi-xian-fen-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        最近在刷LeeCode多线程相关题目时，经常会遇到一些优质的解答使用了J.U.C包中的三个同步工具类配合。所以在此进行整理，方便日后开发中使用。</p><h3 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="2. CountDownLatch"></a>2. CountDownLatch</h3><p>​        示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Foo foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            foo<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestRunner</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">" 我是第 "</span> <span class="token operator">+</span> i <span class="token operator">+</span><span class="token string">" 个"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finished"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">TestRunner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> CountDownLatch countDownLatch<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">TestRunner</span><span class="token punctuation">(</span>CountDownLatch countDownLatch<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>countDownLatch <span class="token operator">=</span> countDownLatch<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" start execute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行结果如下：</p><pre class=" language-java"><code class="language-java">我是第 <span class="token number">0</span> 个 start execute 我是第 <span class="token number">9</span> 个 start execute 我是第 <span class="token number">8</span> 个 start executefinished 我是第 <span class="token number">7</span> 个 start execute 我是第 <span class="token number">6</span> 个 start execute 我是第 <span class="token number">4</span> 个 start execute 我是第 <span class="token number">5</span> 个 start execute 我是第 <span class="token number">3</span> 个 start execute 我是第 <span class="token number">2</span> 个 start execute 我是第 <span class="token number">1</span> 个 start execute</code></pre><p>​        <strong>CountDownLatch</strong>是一个倒计时式的计数器，在初始化的时候可以通过构造参数指定所要统计的线程的数量，每当线程执行一次countDown()方法，计数器减一，当计数器的内部值变为0时，将会开始执行await()方法之后的代码，即允许指定数量的线程执行完毕之后才开始执行。</p><p>​        <strong>CountDownLatch</strong>基于AQS，是一个共享锁，await()使当前线程阻塞等待。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// CountDownLatch aqs源码：</span>‘’<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span>                 <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>    <span class="token function">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//加锁</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//解锁</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>await()调用tryAcquireShared(1)方法获取锁，根据共享锁的实现返回值小于0时线程会被阻塞等待，也就是只有当state==0,才会成功解锁。</li><li>countDown()调用tryReleaseShared(1)方法进行解锁，当state为0时，共享锁才算完全释放，会唤醒队列等待的线程。</li><li>CountDownLatch没有复位操作，当state的值为0时，再调用await()就不会阻塞线程了，所以CountDownLatch只能使用一次。</li></ul><h3 id="3-CyclicBarrier"><a href="#3-CyclicBarrier" class="headerlink" title="3. CyclicBarrier"></a>3. CyclicBarrier</h3><p>​        示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Foo foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            foo<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        CyclicBarrier barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestRunner</span><span class="token punctuation">(</span>barrier<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">" 我是第 "</span> <span class="token operator">+</span> i <span class="token operator">+</span><span class="token string">" 个"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finished"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">TestRunner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> CyclicBarrier barrier<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">TestRunner</span><span class="token punctuation">(</span>CyclicBarrier barrier<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>barrier <span class="token operator">=</span> barrier<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" start execute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我朋友他好了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果如下：</p><pre class=" language-java"><code class="language-java">finished 我是第 <span class="token number">0</span> 个 start execute 我是第 <span class="token number">1</span> 个 start execute 我是第 <span class="token number">2</span> 个 start execute我朋友他好了我朋友他好了我朋友他好了 我是第 <span class="token number">3</span> 个 start execute 我是第 <span class="token number">4</span> 个 start execute 我是第 <span class="token number">5</span> 个 start execute我朋友他好了我朋友他好了我朋友他好了 我是第 <span class="token number">6</span> 个 start execute 我是第 <span class="token number">7</span> 个 start execute 我是第 <span class="token number">8</span> 个 start execute我朋友他好了我朋友他好了我朋友他好了 我是第 <span class="token number">9</span> 个 start execute</code></pre><p>​        <strong>CyclicBarrier</strong>是可循环的同步屏障，如上示例，构造函数赋值为3，所以每次屏障会拦截三个线程，待三个线程同时抵达屏障时，屏障被打破，线程执行后面逻辑代码。与此同时，循环截取后面的三个线程，依次循环。</p><p>​        <strong>CyclicBarrier</strong>使用一个重入锁实现。</p><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>​        示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Foo foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            foo<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestRunner</span><span class="token punctuation">(</span>semaphore<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">" 我是第 "</span> <span class="token operator">+</span> i <span class="token operator">+</span><span class="token string">" 个"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finished"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">TestRunner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> Semaphore semaphore<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">TestRunner</span><span class="token punctuation">(</span>Semaphore _semaphore<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>semaphore <span class="token operator">=</span> _semaphore<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" start execute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行结果如下：</p><pre class=" language-java"><code class="language-java">finished 我是第 <span class="token number">0</span> 个 start execute 我是第 <span class="token number">1</span> 个 start execute 我是第 <span class="token number">2</span> 个 start execute 我是第 <span class="token number">3</span> 个 start execute 我是第 <span class="token number">4</span> 个 start execute 我是第 <span class="token number">5</span> 个 start execute 我是第 <span class="token number">7</span> 个 start execute 我是第 <span class="token number">8</span> 个 start execute 我是第 <span class="token number">6</span> 个 start execute 我是第 <span class="token number">9</span> 个 start execute</code></pre><p>​        <strong>Semaphore</strong>是一个计数信号量，常用于限制可以访问某些资源线程数目。</p><p>​        以上示例代码，每个2s,打印三行数据，即第1,2,3线程，执行semaphore.acquire()先进来，然后置于睡眠状态，4进来时，semaphore并未执行release（）方法，故而会阻塞，接着1,2,3线程依次执行release(),4,5,6线程进入睡眠状态，依此循环，保证限制线程执行的数目为3条。</p><p>​        <strong>注意：</strong>当semaphore的值为0时，表明当前资源已经耗尽，需要先进行release才能再acquire。故当初始值设为0时，需要先执行release，否则线程将会一直阻塞。经典案例，Leecode的交替打印，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">private</span> Semaphore foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Semaphore bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Runnable printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// printFoo.run() outputs "foo". Do not change or remove this line.</span>            <span class="token comment" spellcheck="true">//获取后foo变0，所以下次不能重复执行</span>            foo<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//执行后，bar变1</span>            bar<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>Runnable printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// printBar.run() outputs "bar". Do not change or remove this line.</span>            <span class="token comment" spellcheck="true">//只有当bar变1的时候才能执行，故在首次后执行，执行后变0，所以下次不能重复执行</span>            bar<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//执行后，foo变1</span>            foo<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行结果如下：</p><pre class=" language-java"><code class="language-java">foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobar</code></pre><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>CountDownLatch</strong>为计数器，设定初始值，当数值内所有线程执行完毕，才是执行接下来的逻辑。</li><li><strong>CyclicBarrier</strong>为屏障，设定初始值，当数值内所有线程到达指定位置，才进行屏障移除，但可重复。</li><li><strong>Semaphone</strong>为计数信号量，设定初始值，每次线程获取减一，释放加一，其他线程要执行，必须等待令牌释放，即固定了同时只能有指定值个线程在处理资源任务。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：Synchronized 和 volatile</title>
      <link href="/2019/07/07/java-bing-fa-synchronized-he-volatile/"/>
      <url>/2019/07/07/java-bing-fa-synchronized-he-volatile/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        <strong>synchronized</strong>作为Java的线程安全相关的关键字可以修饰的地方包括：代码块、对象、方法、类以及静态方法。</p><p>​        <strong>volatile</strong>则一般用来修饰属性。</p><h3 id="2-Synchronized"><a href="#2-Synchronized" class="headerlink" title="2. Synchronized"></a>2. Synchronized</h3><h5 id="2-1-代码块"><a href="#2-1-代码块" class="headerlink" title="2.1 代码块"></a>2.1 代码块</h5><ul><li>一个线程访问一个对象中的Synchronized（this）同步代码块时，其他试图访问该对象的线程将会被阻塞，例如，起两个thread，使用同一个Runnable对象实例，将会阻塞一个。</li><li>如果启动两个线程，两个Runnable实例，则因为锁对象不同，不会造成阻塞</li><li>当一个对象包含同步块代码和非同步快代码时，同步块代码会阻塞线程，但是非同步代码块将不会造成阻塞</li></ul><h5 id="2-2-对象加锁"><a href="#2-2-对象加锁" class="headerlink" title="2.2 对象加锁"></a>2.2 对象加锁</h5><ul><li><p>即Runnable对象将会接受一个对象参数进去，以此对象参数作为锁对象，可以保证线程对该对象参数的修改保证同步和阻塞</p></li><li><p>如果没有明确的锁对象，只想让一段代码同步，可以创建一个特殊的对象来当锁</p><p>private byte[] = new byte[0]    内部只要三行代码实现</p></li></ul><h5 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h5><ul><li>类似于代码块，但是范围作用域不一样</li><li>Synchronized不可被继承</li><li>父类加了同步锁，子类如果需要，要自行加同步锁</li><li>但子类调用父类方法，想当于加同步锁</li><li>定义接口不能使用synchronized关键字</li><li>构造方法不能使用synchronized，但是代码块可以</li></ul><h5 id="2-4-类"><a href="#2-4-类" class="headerlink" title="2.4 类"></a>2.4 类</h5><ul><li>修饰一个类，对于该类的所有对象而言都是同一把锁，类似于修饰一个静态方法，synchronized(Test.class)。</li></ul><h5 id="2-5-静态方法"><a href="#2-5-静态方法" class="headerlink" title="2.5 静态方法"></a>2.5 静态方法</h5><ul><li>因为静态方法属于类，所以加的同步锁将会对该类的所有对象而言，是同一把锁，前提是这些对象内部都调用了该静态方法。</li></ul><h3 id="3-Volatile"><a href="#3-Volatile" class="headerlink" title="3. Volatile"></a>3. Volatile</h3><ul><li>不能保证原子性，volatile提供的可见性，是说每一个线程访问使用volatile修饰的变量，都会直接从主存区中读到最新的值。</li><li>反之，线程修改后同步到主存的值，也要保证对其他线程的可见。</li><li>因为非原子性，不能保证线程安全，简单的一次性读写操作是允许的，但是 i++就不行，因为这是一次读加一次写。</li><li>可以用的场景：对一个变量，跟新其值的时候不依赖于当前的值。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><strong><em>两者的差异：</em></strong></p><ul><li>synchronized获得并释放监视器，如果两个线程使用一把对象锁，监视器能强制保证代码块同时只被一个线程执行</li><li>synchronized也会同步内存，在“主”内存区域会同步整个线程的内存</li><li>synchronize的步骤：<ul><li>线程请求获得见识this对象的对象锁</li><li>线程内存的数据被消除，从“主”内存区域中读取</li><li>代码块被执行</li><li>对于变量的任何改变，安全的写入到“主”内存区域中</li><li>线程释放监视this对象的对象锁</li></ul></li></ul><p><strong><em>补充：并发的三个概念</em></strong></p><ul><li><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就不会被执行。</li><li><strong>可见性</strong>：多线程修改一个变量，该变量的变化，对于其他的线程都是可见的。</li><li><strong>有序性</strong>：处理器为了提升程序运行效率，会进行指令重排序，单线程情况下可能两个结果不会相互影响，顺序调换不会导致出现问题，但是多线程情况下，调换顺序，可能导致程序运行失败。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：线程池</title>
      <link href="/2019/06/28/java-bing-fa-xian-cheng-chi/"/>
      <url>/2019/06/28/java-bing-fa-xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        线程池是由很多线程组成，来一个任务，取一个线程处理这个任务。</p><p>​        线程池的线程数目取决于两个参数：</p><ul><li><strong>核心池大小</strong><ul><li>当前线程小于核心池大小时，当任务来临，优先创建新的线程执行任务</li><li>如果当前线程达到了核心池的大小，则任务会被置到队列中，队列是存在上限的。</li></ul></li><li><strong>最大池大小</strong><ul><li>当队列达到上限时，若当前线程数小于最大线程数，则创建线程执行任务。</li><li>若当前线程已经达到了最大线程数，则考虑丢弃任务。</li></ul></li></ul><h3 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2.ThreadPoolExecutor"></a>2.ThreadPoolExecutor</h3><p>​        ThreadPoolExecutor的实现的顶层接口是Executor，自身继承了抽象类AbstractExecutorService,该抽象类实现了ExecutorService接口。</p><h5 id="2-1-构造函数参数"><a href="#2-1-构造函数参数" class="headerlink" title="2.1 构造函数参数"></a>2.1 构造函数参数</h5><table><thead><tr><th>参数</th><th>介绍</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心池大小，不会随线程池的创建而启动，直到有任务提交才开始启动线程。若一开始想创建所有核心线程需调用prestartAllCoreThreads方法</td></tr><tr><td>maximumPoolSize</td><td>最大池大小，当前核心池满，且队列阻塞，才会判断是否要产生新的线程</td></tr><tr><td>keepAliveTime</td><td>线程数大于核心时，多余的空闲线程最多存活时间</td></tr><tr><td>unit</td><td>keppAliveTime参数的时间单位</td></tr><tr><td>workQueue</td><td>线程数目超过核心池大小时，存放任务的队列</td></tr><tr><td>threadFactory</td><td>创建线程时使用的工厂</td></tr><tr><td>handler</td><td>队列阻塞，且线程池达到最大值所要采取的饱和策略</td></tr></tbody></table><ul><li><p><strong>workQueue</strong>包含三种类型：</p><ul><li>无界队列</li></ul><p><img src="/2019/06/28/java-bing-fa-xian-cheng-chi/1573457063835.png" alt="1573457063835"></p><ul><li><p>有界队列</p><p>​                <img src="/2019/06/28/java-bing-fa-xian-cheng-chi/1573457116805.png" alt="1573457116805"></p></li><li><p>同步移交</p><p>​    <img src="/2019/06/28/java-bing-fa-xian-cheng-chi/1573457206470.png" alt="1573457206470"></p></li></ul></li><li><p><strong>handler</strong>包括四种类型：</p><ul><li><em>终止（AbortPolicy)</em>：饱和时会抛出RejectedExecutionException。</li><li><em>抛弃（DiscardPolicy）</em>：不做任何处理，直接抛弃。</li><li><em>抛弃最旧（DiscardOldestPolicy）</em>：<ul><li>抛弃旧任务策略</li><li>优先队列，优先级最高的任务会被抛弃</li><li>普通队列，头元素将会被抛弃</li></ul></li><li><em>调用者运行(CallerRunsPolicy)</em>：不抛弃任务，也不抛异常，线程饱和之后，将由线程池的主线程自己来执行任务，这段是时间主线程无法提交新的任务，从而使其他线程有时间将正在处理的任务处理完成。</li></ul><p>​         <strong><em>ThreadPoolExecutor有四个构造器,区别在于是否采用了默认的处理策略和工厂，以下为Java自带的四种线程池所采用的默认策略的构造器。</em></strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//这个构造器采用了默认的工厂和处理器</span> <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这个构造器仅仅采用了默认的处理器</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             threadFactory<span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这个构造器仅仅采用了默认的工厂</span>   <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//标准构造器，一般创建线程池均采用该构造器</span> <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>                null <span class="token operator">:</span>                AccessController<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>使用实例：</p><pre class=" language-java"><code class="language-java">BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>                t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>threadName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>  <strong>其他的预留方法</strong>：</p><p>  ​        预留方法用以实现监控、日志等功能。</p><ul><li>beforeExecute(Thread t, Runnable r)</li><li>afterExecute(Thread t, Runnable r)</li><li>terminated()</li></ul><h5 id="2-2-线程池中线程的任务状态"><a href="#2-2-线程池中线程的任务状态" class="headerlink" title="2.2 线程池中线程的任务状态"></a>2.2 线程池中线程的任务状态</h5><table><thead><tr><th>状态</th><th>简介</th></tr></thead><tbody><tr><td>running</td><td>初始状态，接受新任务并且处理已经在队列中的任务，shutdown（）进入shutdown状态，shutdownNow()进入stop状态</td></tr><tr><td>shutdown</td><td>不接受新任务，但处理队列中的任务，shutdownNow()进入stop状态</td></tr><tr><td>stop</td><td>不接受新任务，不处理排队的任务，并中断正在进行的任务</td></tr><tr><td>tidying</td><td>所有任务已终止，workerCount为零，线程转换到状态tidying，回调terminate（）方法</td></tr><tr><td>terminated</td><td>终态，terminated（）执行完成</td></tr></tbody></table><h5 id="2-3-Java自带的四种线程池"><a href="#2-3-Java自带的四种线程池" class="headerlink" title="2.3 Java自带的四种线程池"></a>2.3 Java自带的四种线程池</h5><ul><li><strong>newCachedThreadPool</strong>：<ul><li>提供了无界线程池，可以进行自动线程回收</li><li>内部采用SynchronousQueue</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要指定工厂</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li><strong>newFixedThreadPool</strong>:<ul><li>线程数量固定，使用无限大的队列</li><li>内部采用LinkedBlockingQueue</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定核心线程池大小和最大池大小</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//指定核心线程池大小和最大池大小，以及工厂</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>newScheduleThreadPool</strong>:<ul><li>创建一个定长线程池，支持定时，以及周期性任务执行</li><li>内部采用 DelayedWorkQueue</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span>            <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>newSingleThreadExecutor</strong>：<ul><li>内部使用ScheduledThreadPoolExecutor（1）</li><li>使用装饰器模式，确保只有一个线程顺序执行任务，保证线程意外终止后会创建一个线程继续执行任务</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//可以看到该线程池的内部实质返回的是一个FinalizableDelegatedExecutorService的对象</span></code></pre><p>补充：</p><ul><li><p><strong>ScheduledThreadPoolExecutor</strong></p><p>​        这个线程池继承了ThreadPoolExecutor类，实现了ScheduledExecutorService接口, 其中该接口的作用和Timer/TimerTask类似，目的是解决那些需要任务重复执行的问题。而实现该接口之后，便可以进行周期性任务调度。</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledThreadPoolExecutor</span>        <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span>        <span class="token keyword">implements</span> <span class="token class-name">ScheduledExecutorService</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p><strong>注意：Java部分自带的线程池的实现方式采用了无界队列，即比如LinkedBlockingQueue没有设置大小，在部分场景下可能会造成一些严重问题，因此在使用线程池时，优先推荐自行对线程池的实现。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：锁</title>
      <link href="/2019/06/22/java-bing-fa-suo/"/>
      <url>/2019/06/22/java-bing-fa-suo/</url>
      
        <content type="html"><![CDATA[<h3 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1. 悲观锁和乐观锁"></a>1. 悲观锁和乐观锁</h3><h5 id="1-1-悲观锁"><a href="#1-1-悲观锁" class="headerlink" title="1.1 悲观锁"></a>1.1 悲观锁</h5><ul><li>线程会锁住同步资源</li><li>认为自身在修改数据时，一定会有人来修改，所以要加锁保证不会被修改。</li><li>synchronized和Lock的实现都是悲观锁</li><li>适合写操作多的场景，加锁保证写数据的正确性</li></ul><h5 id="2-1-乐观锁"><a href="#2-1-乐观锁" class="headerlink" title="2.1 乐观锁"></a>2.1 乐观锁</h5><ul><li>线程不会锁住同步资源</li><li>使用数据时，别的线程不会进行修改，在更新数据是需要判断是否有别的线程跟新了数据，如果发生了更新，则根据不同的实现方式执行不同的操作。如果为更新，将自己修改的数据重新写入。</li><li>使用无锁编程，最常用的就是CAS算法</li><li>Java原子类的递增就是通过CAS自旋实现的</li><li>适合读操作多的场景，不加锁提升读操作的性能</li></ul><h3 id="2-自旋锁和适应性自旋锁"><a href="#2-自旋锁和适应性自旋锁" class="headerlink" title="2. 自旋锁和适应性自旋锁"></a>2. 自旋锁和适应性自旋锁</h3><h5 id="2-1-自旋锁"><a href="#2-1-自旋锁" class="headerlink" title="2.1 自旋锁"></a>2.1 自旋锁</h5><ul><li><p>锁住同步资源，线程不会阻塞</p></li><li><p>自旋锁的目的在于，部分场景下，同步资源锁定的时间很短，线程挂起和恢复的代价可能很高，采用自旋锁，可以让线程自旋稍等一下，等到前面锁定同步资源的线程已经释放锁，线程就不必阻塞，直接获取资源，避免线程切换。</p></li><li><p>缺点：不能代替阻塞，如果锁被占用时间很长，自旋只会浪费处理器资源，所以自旋有一定的限度，默认10次，没有获取到锁，就挂起。</p></li><li><p>自旋锁的实现同样也是CAS</p></li><li><p>自旋锁只出现在轻量级锁中，重量级中不使用，线程会阻塞</p></li></ul><h5 id="2-2-适应性自旋锁"><a href="#2-2-适应性自旋锁" class="headerlink" title="2.2 适应性自旋锁"></a>2.2 适应性自旋锁</h5><ul><li><p>自旋时间和次数不再固定，由前一次所上的自旋时间和锁的拥有者的状态来决定</p></li><li><p>在一个锁对象上，自旋等待成功，并且持有锁的线程正在运行，虚拟机会认为自旋有可能再次成功，允许自旋等待更长时间</p></li><li><p>如果一个锁很少成功，后面的尝试可能会省掉自旋过程，直接阻塞线程，避免浪费处理器资源</p></li></ul><h3 id="3-无锁"><a href="#3-无锁" class="headerlink" title="3. 无锁"></a>3. 无锁</h3><ul><li>不锁住资源，多个线程只有一个能修改资源成功，其他线程会重试</li><li>没有对资源进行锁定，所有线程访问一个资源，只有一个会修改成功</li><li>特点在于，修改操作在循环内进行，不断尝试修改资源，没有冲突就改完退出，否则继续尝试，直至修改成功</li><li>CAS的应用就是无锁的实现</li></ul><h3 id="4-偏向锁"><a href="#4-偏向锁" class="headerlink" title="4. 偏向锁"></a>4. 偏向锁</h3><ul><li>同一个线程执行同步资源时自动获取资源</li><li>指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价</li><li>出现的原因在于，不存在多线竞争，锁总是由一个线程多次获得，目标就是在只有一个线程同步代码块时能够提升性能，尽量减少不必要的轻量级执行路径</li><li>只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放锁，撤销偏向锁之后，恢复到无锁或轻量级锁的状态</li><li>JDK6以后的JVM里是默认启动的，可以通过JVM参数进行关闭</li></ul><h3 id="5-轻量级锁和重量级锁"><a href="#5-轻量级锁和重量级锁" class="headerlink" title="5.轻量级锁和重量级锁"></a>5.轻量级锁和重量级锁</h3><h5 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5.1 轻量级锁"></a>5.1 轻量级锁</h5><ul><li>多个线程竞争同步资源时，没有获取资源的线程自旋等待释放锁</li><li>当锁是偏量级锁的时候，被另外的线程访问，偏向锁会自动升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能</li><li>若当前只有一个等待线程，则该线程通过自旋等待，但当自旋超过一定的次数，或一个线程在持有锁，一个在自旋，又来第三个访问者，轻量级锁自动升级为重量级的锁</li></ul><h5 id="5-2-重量级锁"><a href="#5-2-重量级锁" class="headerlink" title="5.2 重量级锁"></a>5.2 重量级锁</h5><ul><li>多个线程竞争同步资源时，没有获取资源的线程等待唤醒</li><li>将除了拥有锁的线程之外的线程都阻塞</li></ul><h3 id="6-公平锁和非公平锁"><a href="#6-公平锁和非公平锁" class="headerlink" title="6. 公平锁和非公平锁"></a>6. 公平锁和非公平锁</h3><h5 id="6-1-公平锁"><a href="#6-1-公平锁" class="headerlink" title="6.1 公平锁"></a>6.1 公平锁</h5><ul><li>多个线程按照申请锁的顺序来获取锁，线程直接进入队列排队，第一个线程才能获得锁</li><li>优点：等待锁的线程不会饿死</li><li>缺点：整体的吞吐效率相比非公平锁要低，等待队列中，除了第一个线程之外，所有的线程都会阻塞，CPU唤醒阻塞线程的开销要比非公平锁大</li></ul><h5 id="6-2-非公平锁"><a href="#6-2-非公平锁" class="headerlink" title="6.2 非公平锁"></a>6.2 非公平锁</h5><ul><li>先尝试插队，插队失败再排队</li><li>多个线程加锁时，直接获取锁，获取不到才到队列的队尾等待，若锁刚好可用，线程无需阻塞，可直接获取锁</li><li>所有非公平锁可能出现后申请锁的线程先获取锁的场景</li><li>优点：减少唤起线程的开销，整体的吞吐效率高，线程有几率不阻塞直接获取锁，CPU不必唤醒所有线程</li><li>缺点：等待队列中的线程可能会饿死，或等很久才会获取锁</li></ul><h3 id="7-可重入锁和不可重入锁"><a href="#7-可重入锁和不可重入锁" class="headerlink" title="7. 可重入锁和不可重入锁"></a>7. 可重入锁和不可重入锁</h3><h5 id="7-1-可重入锁"><a href="#7-1-可重入锁" class="headerlink" title="7.1 可重入锁"></a>7.1 可重入锁</h5><ul><li>一个线程中多个流程可以获取同一把锁。</li><li>又名递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响</li><li>ReentranLock和synchronized都是可重入锁</li><li>优点是，一定程度上避免死锁</li></ul><h5 id="7-2-不可重入锁"><a href="#7-2-不可重入锁" class="headerlink" title="7.2 不可重入锁"></a>7.2 不可重入锁</h5><ul><li>和重入锁相反</li></ul><h3 id="8-共享锁和排他锁"><a href="#8-共享锁和排他锁" class="headerlink" title="8. 共享锁和排他锁"></a>8. 共享锁和排他锁</h3><h5 id="8-1-共享锁"><a href="#8-1-共享锁" class="headerlink" title="8.1 共享锁"></a>8.1 共享锁</h5><ul><li>多线程能共享同一把锁</li><li>指该锁可被多个线程所持有，线程对数据加上锁之后，其他线程只能给数据加共享锁，不能加其他锁，获得共享锁的线程只能读数据，不能写数据</li></ul><h5 id="8-2-排他锁"><a href="#8-2-排他锁" class="headerlink" title="8.2 排他锁"></a>8.2 排他锁</h5><ul><li><p>多线程不能共享同一把锁</p></li><li><p>指该锁一次只能被一个线程所持有，线程对数据加上锁之后，其他线程不能再对A加任何类型的锁，获得排他锁的线程既能读又能修改数据</p></li></ul><p><strong>排他锁和共享锁也是通过AQS来实现的。</strong></p><h3 id="9-其他锁"><a href="#9-其他锁" class="headerlink" title="9. 其他锁"></a>9. 其他锁</h3><h5 id="9-1-读写锁"><a href="#9-1-读写锁" class="headerlink" title="9.1 读写锁"></a>9.1 读写锁</h5><ul><li>一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程</li><li>java中的读写锁通过ReentrantReadWriteLock实现</li></ul><h5 id="9-2-分段锁"><a href="#9-2-分段锁" class="headerlink" title="9.2 分段锁"></a>9.2 分段锁</h5><ul><li>ConcurrentHashMap采用了分段锁</li></ul><h5 id="9-3-互斥锁"><a href="#9-3-互斥锁" class="headerlink" title="9.3 互斥锁"></a>9.3 互斥锁</h5><ul><li>一次最多只能有一个线程持有的锁</li><li>jdk的synchronized</li><li>juc的Lock</li></ul><h5 id="9-4-闭锁"><a href="#9-4-闭锁" class="headerlink" title="9.4 闭锁"></a>9.4 闭锁</h5><ul><li>是一种同步工具类，可以延迟线程的进度直到到达终止条件</li><li>在闭锁到达结束条件之前，这扇门是一直关的，当到达结束条件之后，门打开允许所有线程通过，当闭锁达到结束状态之后，将不会再改变状态，门一直打开，确保其他活动的完成</li><li>CountDownLatch就是一种灵活的闭锁实现</li></ul><h5 id="9-5-死锁"><a href="#9-5-死锁" class="headerlink" title="9.5 死锁"></a>9.5 死锁</h5><ul><li><p>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去</p></li><li><p>死锁的四个条件：</p><ul><li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li><li><strong>请求与保持条件</strong>：一个进程因请求资源而被阻塞时，对已获得资源保持不放。</li><li><strong>不剥夺条件</strong>：进程已获得资源，在未使用完之前，不能强行剥夺。</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul></li><li><p>避免死锁的方法</p><ul><li>阻止循环等待条件，将系统中的所有资源设置标志位，排序，规定所有的进程申请资源必须以一定的顺序做操作来避免死锁</li></ul></li></ul><h5 id="9-6-活锁"><a href="#9-6-活锁" class="headerlink" title="9.6 活锁"></a>9.6 活锁</h5><ul><li>该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败</li><li>如果不能成功的处理某个消息，那么消息处理机制将会回滚整个事务，并将它重新放到队列的开头，因此处理器将会反复调用，并返回相同的结果。</li></ul><h3 id="10-其它概念"><a href="#10-其它概念" class="headerlink" title="10. 其它概念"></a>10. 其它概念</h3><h5 id="10-1-锁消除"><a href="#10-1-锁消除" class="headerlink" title="10.1 锁消除"></a>10.1 锁消除</h5><ul><li>锁消除的判断依据是源于逃逸分析的数据支持，如果在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那么就可以把他们当做栈上的数据对待，认为他们是线程私有的，同步加锁自然无需进行</li><li>比如StringBuffer的append（）方法连续多个出现在一个方法内</li></ul><h5 id="10-2-锁粗化"><a href="#10-2-锁粗化" class="headerlink" title="10.2 锁粗化"></a>10.2 锁粗化</h5><ul><li>如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中，那么即使没有线程竞争，频繁的进行互斥同步操作也导致不必要的性能损耗，所以可以将锁的同步范围扩展到整个操作序列的外部，这种行为称为锁粗化</li></ul><p><strong>锁的状态只能升级，不能降级：无锁 – 偏向锁 – 轻量级锁 – 重量级锁</strong></p><p><strong>偏向锁tongue对比Mark Word 解决加锁问题，避免CAS操作，而轻量级锁是通过CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能，重量级锁是将除了拥有锁的线程之外的线程都阻塞。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：深入解析CAS</title>
      <link href="/2019/06/16/java-bing-fa-shen-ru-jie-xi-cas/"/>
      <url>/2019/06/16/java-bing-fa-shen-ru-jie-xi-cas/</url>
      
        <content type="html"><![CDATA[<h3 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1. 悲观锁和乐观锁"></a>1. 悲观锁和乐观锁</h3><h4 id="1-1-悲观锁"><a href="#1-1-悲观锁" class="headerlink" title="1.1 悲观锁"></a>1.1 悲观锁</h4><p>​        悲观锁较常见于传统的关系型数据库的锁机制，比如行锁，表锁，读锁，写锁等，都会在操作之前上锁，保证同时只有一个线程进行修改。悲观锁总是假设最坏的情况，即每次拿数据时，都会认为别人会进行数据的修改，因为每次操作必须进行上锁。<strong>java中的synchronized关键字的实现就是悲观锁</strong>。</p><p>​    <em>悲观锁的缺陷：</em></p><ul><li>多线程竞争下，加锁，释放锁会导致较多的上下文切换和调度延时，引起性能问题。</li><li>一个线程持有锁会导致其他所有需要此锁的线程挂起。</li><li>优先级高的线程等待优先级低的线程释放锁，会导致优先级倒置，引起性能风险。</li></ul><h4 id="1-2-乐观锁"><a href="#1-2-乐观锁" class="headerlink" title="1.2 乐观锁"></a>1.2 乐观锁</h4><p>​        乐观锁，在每次拿数据时，都认为别人不会进行数据的修改，因为不会上锁，但需要在更新的时候判断一下此期间是否有人去更新这个数据。<strong>java 中的java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</strong>适用于多读的应用类型。</p><p>​        乐观锁如果在正式对数据是否产生并发冲突进行检测，发现了冲突存在，则会返回用户错误信息，并且不会被挂起。乐观锁的主要步骤就是：<strong>冲突</strong>与<strong>检测和数据更新</strong>。</p><h3 id="2-CAS-Compare-and-Swap"><a href="#2-CAS-Compare-and-Swap" class="headerlink" title="2. CAS(Compare and Swap)"></a>2. CAS(Compare and Swap)</h3><h4 id="2-1-概念解析"><a href="#2-1-概念解析" class="headerlink" title="2.1 概念解析"></a>2.1 概念解析</h4><p>​        CAS是乐观锁技术，乐观锁是一个思想概念，CAS是乐观锁的一种实现。</p><p>​        <em>CAS的操作包含三个操作数：</em></p><ul><li><p>需要读写的内存位置（V）</p></li><li><p>进行比较的预期原值（A）</p></li><li><p>拟写入的新值（B）    </p><p>​    如果内存位置V的值和预期原值A相匹配，即相同，没有发生改变，则处理器将会自动把该位置的值更新为新值B,否则不做任何操作。并且在CAS指令之前都会返回该位置的值。即V处应该是A，结果是A，那就替换成B，否则不做改动，将V处的值告诉我。</p></li></ul><h4 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h4><p>​        以下是 java.util.concurrent.atomic包下的AtomicInteger的部分源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6214790243416807050L<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//在没有锁的机制下，字段value要使用volatile，来保证数据在线程间是可见的。</span>     <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//prev拿到原始值，next拿到新值，采用compareAndSet方法进行CAS操作，其返回的是boolean值，即在自旋过程中，如果修改失败，则继续自旋重试，直到数据修改成功。</span>      <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">updateAndGet</span><span class="token punctuation">(</span>IntUnaryOperator updateFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            next <span class="token operator">=</span> updateFunction<span class="token punctuation">.</span><span class="token function">applyAsInt</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//利用JNI（Java Native Interface）来完成CPU指令的操作</span>     <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-3-CAS的缺点："><a href="#2-3-CAS的缺点：" class="headerlink" title="2.3 CAS的缺点："></a>2.3 CAS的缺点：</h4><ul><li><p>ABA问题</p><p>​    如果内存地址V初次读取的值是A，期间被改成B，之后又被改回A，那么CAS操作就会认为它从来没有变过，这个漏洞称为CAS的“ABA”问题。java的atomic包提供了AtomicStampedReference类来解决ABA问题，其作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p>循环时间长，开销大</p><p>​    自旋CAS如果长时间不成功，会给CPU带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作</p><p>​    可以采用CAS来保证单个共享变量的原子操作，但当有多个共享变量操作时，CAS无法保证操作的原子性，可以采用锁机制，或者将多个原子变量合成一个来进行操作。<strong>Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></p></li></ul><h4 id="2-4-拓展"><a href="#2-4-拓展" class="headerlink" title="2.4 拓展"></a>2.4 拓展</h4><h5 id="2-4-1-CAS与Synchronized"><a href="#2-4-1-CAS与Synchronized" class="headerlink" title="2.4.1 CAS与Synchronized"></a>2.4.1 CAS与Synchronized</h5><ul><li><p>对于竞争资源较少的情况，使用synchronized同步锁进行线程阻塞和唤醒切换用户内核的切换操作会浪费额外的cpu资源；而CAS基于硬件实现，不需进入内核，不需切换线程，自旋几率较少，因此可以获得更高的性能。</p></li><li><p>对于竞争资源较多的情况：CAS自旋的概率会比较大，从而浪费更多的cpu资源，效率较低</p></li><li><p>synchronized在1.6之后进行了优化，底层主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了吞吐量。冲突较低时，和CAS性能基本类似，冲突较高时，性能远胜CAS。</p></li><li><p>concurrent包基本上有一个通用的实现模式</p><ul><li>首先声明共享变量为volatile</li><li>使用CAS的原子条件更新来实现线程之间的同步</li><li>配合voliate的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ul></li></ul><p><img src="/2019/06/16/java-bing-fa-shen-ru-jie-xi-cas/1047941-20170319190237932-274252686%5B1%5D.png" alt=""></p><ul><li><p>JVM中的CAS(堆中对象的分配)</p><p>在new object（）时，JVM会为对象在堆上划分存储空间</p><p>单线程情况下，有两种分配策略：</p><ul><li>指针碰撞：适用于内存绝对规整，分配空间只需要将指针向空闲内存进行移动。</li><li>空闲列表：适用于内存非规整的情况，JVM会维护一个内存列表，用于记录内存的使用情况，分配对象的内存时，只需查询分配即可。</li></ul><p>但JVM的运行一般都是非单线程，所以多线程分配对象时，采用空闲列表，即查询空闲列表，分配内存，修改空闲列表等等，这些都是不安全的，有两种策略可以解决：</p><ul><li>CAS:虚拟机采用CAS配合上失败重试的方式保证更新操作的原子性。</li><li>TLAB: 每个线程在java堆中会预先分配一小块内存，即本地线程分配缓冲区（TLAB），线程内部需要分配内存时，直接在TLAB上分配就行，避免了线程冲突。只有当缓冲区的内存用光需要重新分配内存的时候才会进行CAS操作分配更大的内存空间。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发：流式数据处理</title>
      <link href="/2019/06/08/java-bing-fa-liu-shi-shu-ju-chu-li/"/>
      <url>/2019/06/08/java-bing-fa-liu-shi-shu-ju-chu-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​            采用JSONWriter + 多线程 + 安全队列 + CountDownLatch实现 Http请求下，请求边处理边以流的形式将结果进行返回。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>JSONWriter jsonWriter<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> ipList<span class="token punctuation">,</span> <span class="token keyword">int</span> threadNum<span class="token punctuation">,</span> String threadName<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//采用线程安全的队列存放处理信息</span>    Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>String ip <span class="token operator">:</span> ipList<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//增加一个元素，如果已满则抛出异常</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    jsonWriter<span class="token punctuation">.</span><span class="token function">startObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jsonWriter<span class="token punctuation">.</span><span class="token function">writeKey</span><span class="token punctuation">(</span><span class="token string">"xxxxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jsonWriter<span class="token punctuation">.</span><span class="token function">startArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用于保证threadNum个任务完成后，主线程才继续执行。防止子线程在执行时，主线程结束。</span>    CountDownlatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownlatch</span><span class="token punctuation">(</span>threadNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IPPingRunner</span><span class="token punctuation">(</span>latch<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> jsonWriter<span class="token punctuation">)</span><span class="token punctuation">,</span> threadName <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//主线程等待，直到threadNum个线程全部执行完毕，即计数器置0</span>    latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jsonWriter<span class="token punctuation">.</span><span class="token function">endArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jsonWriter<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jsonWriter<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">IPPingRunner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> CountDownLatch latch<span class="token punctuation">;</span>    <span class="token keyword">private</span> Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token keyword">private</span> JSONWriter jsonWriter<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">IPPingRunner</span><span class="token punctuation">(</span>CountDownLatch latch<span class="token punctuation">,</span> Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue<span class="token punctuation">,</span> JSONWriter jsonWriter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> latch<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>jsonWriter <span class="token operator">=</span> jsonWriter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//获取元素，没有则返回null</span>                String ip <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>ip <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    breadk<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                采用latch作为锁                <span class="token keyword">synchronized</span><span class="token punctuation">(</span>latch<span class="token punctuation">)</span><span class="token punctuation">{</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">startObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">writeKey</span><span class="token punctuation">(</span><span class="token string">"ip"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">writeValue</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">writeKey</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">writeKey</span><span class="token punctuation">(</span><span class="token string">"xx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//出现异常时，则自动释放</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 数据流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程：ThreadLocal</title>
      <link href="/2019/06/02/java-bing-fa-threadlocal/"/>
      <url>/2019/06/02/java-bing-fa-threadlocal/</url>
      
        <content type="html"><![CDATA[<h4 id="1-ThreadLocal-简介"><a href="#1-ThreadLocal-简介" class="headerlink" title="1. ThreadLocal 简介"></a>1. ThreadLocal 简介</h4><p>​            在多线程环境下，一个类的方法被调用，并且该类的方法涉及类自身某个属性的值的变更。那么为保证该属性值在多线程环境下的安全性，有两种选择：1.给方法加锁并且保证属性值的可见性。保证同时只有一个线程可以进入该方法去改变属性值，但会阻塞其他线程，属于<strong>时间换空间</strong>。2.采用ThreadLocal，为每一个线程创建独立的属性值的副本，保证线程修改的是属于当前线程的属性值副本，属于<strong>空间换时间</strong>。</p><p>​            ThreadLocal为每个使用该变量的线程分配一个独立的变量副本。所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。</p><p>​            <strong>示例：private static ThreadLocal<integer> threadLocal = new ThreadLocal();</integer></strong></p><h4 id="2-方法源码介绍"><a href="#2-方法源码介绍" class="headerlink" title="2. 方法源码介绍"></a>2. 方法源码介绍</h4><ul><li><p><strong>中间方法</strong></p><ul><li><p><strong>getMap</strong></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//获取当前线程的ThreadLocalMap</span>    ThreadLocalMap <span class="token function">getMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p><strong>createMap</strong></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//创建ThreadLocalMap</span>    <span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> T firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p><strong>setInitialValue</strong></p><pre class=" language-java"><code class="language-java">     <span class="token keyword">private</span> T <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//通过initialValue拿到初始值</span>        T value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//自动将初始值放到Map中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul></li></ul><ul><li><p><strong>核心方法</strong></p><ul><li><p><strong>set</strong></p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//获取当前线程</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过当前线程拿到ThreadLocalMap</span>        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p><strong>get</strong></p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//获取当前线程</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//拿到当前线程的ThreadLocalMap</span>        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//ThreadLocalMap如果是null，则获取初始值</span>        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p><strong>initialValue</strong></p><pre class=" language-java"><code class="language-java">      <span class="token comment" spellcheck="true">//初始化的值默认为null</span>      <span class="token keyword">protected</span> T <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p><strong>remove</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//拿到当前线程的Map，移除掉Map中的内容</span>         ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>             m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre></li></ul></li></ul><h4 id="3-逻辑图"><a href="#3-逻辑图" class="headerlink" title="3.逻辑图"></a>3.逻辑图</h4><p><img src="/2019/06/02/java-bing-fa-threadlocal/1570785755103.png" alt="1570785755103"></p><p>​        <strong>本质是线程通过ThreadLocal 这个属性，将线程变量存储到线程的ThreadLocalMap中。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：字符串类型</title>
      <link href="/2019/04/12/redis-zi-fu-chuan-lei-xing/"/>
      <url>/2019/04/12/redis-zi-fu-chuan-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><p><img src="/2019/04/12/redis-zi-fu-chuan-lei-xing/1572256192770.png" alt="1572256192770"></p><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><ul><li><p>设置值</p><pre class=" language-shell"><code class="language-shell">set key value </code></pre><ul><li><p>用于新加(键必须不存在)</p><pre class=" language-shell"><code class="language-shell">setnx key value</code></pre></li></ul></li><li><p>获取值</p><pre class=" language-shell"><code class="language-shell">get key</code></pre></li><li><p>批量设置值</p><pre class=" language-shell"><code class="language-shell">mset key value [key value ...]</code></pre></li><li><p>批量获取值</p><pre class=" language-shell"><code class="language-shell">mget key [key ...]</code></pre></li><li><p>计数</p><pre class=" language-shell"><code class="language-shell">incr key</code></pre></li></ul><h3 id="1-3-内部编码"><a href="#1-3-内部编码" class="headerlink" title="1.3 内部编码"></a>1.3 内部编码</h3><p>​    内部有三种编码：</p><ul><li>int：8个子节的长整型</li><li>embstr：小于等于39个子节的字符串</li><li>raw：大于39个子节的字符串</li></ul><p><strong>redis会根据当前值的类型和长度决定使用哪种内部编码实现</strong></p><h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h3><ul><li><p><strong>缓存功能</strong></p><p>​    redis作为用户和mysql存储层之间的缓冲，绝大多数的请求从redis中进行获取，能起到加速读写和降低后端压力的作用。</p></li></ul><p><img src="/2019/04/12/redis-zi-fu-chuan-lei-xing/1572255687909.png" alt="1572255687909"></p><ul><li><p><strong>计数</strong></p><p>​    redis可以快速实现计数，查询缓存的功能，同时数据可以异步落地到其他数据源。</p></li><li><p><strong>共享session</strong></p><p>​    分布式环境下，可将session信息存储在redis中，保证session的集中管理，用户每次登陆可以从session中进行获取。</p></li><li><p><strong>限速</strong></p><p>​    许多应用为防止机器人破坏，会进行验证时间的限速，比如手机短信的发送时间间隔等。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：有序集合类型</title>
      <link href="/2019/04/06/redis-you-xu-ji-he-lei-xing/"/>
      <url>/2019/04/06/redis-you-xu-ji-he-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>​        具有成员不可重复的特性，元素可以排序，但遵循元素的分数进行排序，并且其分数允许重复<img src="/2019/04/06/redis-you-xu-ji-he-lei-xing/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.PNG" alt=""></p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><ul><li><p>集合内</p><ul><li><p>添加成员</p><pre class=" language-shell"><code class="language-shell">zadd key score member [score member ...]</code></pre></li><li><p>计算成员个数</p><pre class=" language-shell"><code class="language-shell">zcard key</code></pre></li><li><p>计算某个成员的分数</p><pre class=" language-shell"><code class="language-shell">zscore key member</code></pre></li><li><p>计算成员的排名</p><pre class=" language-shell"><code class="language-shell">zrank key memberzrevrank key member</code></pre></li><li><p>删除成员</p><pre class=" language-shell"><code class="language-shell">zrem key member [member ...]</code></pre></li><li><p>增加成员的分数</p><pre class=" language-shell"><code class="language-shell">zincrby key increment member</code></pre></li><li><p>返回指定排名范围的成员</p><pre class=" language-shell"><code class="language-shell">zrange key start end [withscores]zrevrange key start end [withscores]</code></pre></li><li><p>返回指定分数范围的成员</p><pre class=" language-shell"><code class="language-shell">zrangebyscore key min max [withscores] [limit offset count]zrevrangebyscore key min max [withscores] [limit offset count]</code></pre></li><li><p>返回分数范围成员个数</p><pre class=" language-shell"><code class="language-shell">zcount key min max</code></pre></li><li><p>删除指定排名内的升序元素</p><pre class=" language-shell"><code class="language-shell">zremrangebyrank key start end</code></pre></li><li><p>删除指定分数范围的成员</p><pre class=" language-shell"><code class="language-shell">zremrangebyscore key min max</code></pre></li></ul></li><li><p>集合间的操作</p><ul><li><p>交集</p><pre class=" language-shell"><code class="language-shell">zinterstore destination numkeys key [key ...] [weights weight [weight ..]] [aggregate sum|min|max]</code></pre><ul><li>destination 计算的交集保存到这个键</li><li>numkeys 需要做交集计算键的个数</li><li>key[key …] 需要做交集计算的键</li><li>weights 权重</li><li>aggregate 计算交集后，分值做汇总，默认值是sum</li></ul></li><li><p>并集</p><pre class=" language-shell"><code class="language-shell">zunionstore destination numkeys key[key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></pre></li></ul></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3. 内部编码"></a>3. 内部编码</h3><p>​        内部编码有两种：</p><ul><li><p>ziplist：当有序集合的元素个数小于zset-max-ziplistentries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配 置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist 可以有效减少内存的使用。</p></li><li><p>skiplist：当ziplist条件不满足时，使用skiplist。</p></li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4.使用场景"></a>4.使用场景</h3><ul><li><p>添加用户赞数</p><p>使用分数作为投票数，使用zadd和zincrby</p></li><li><p>取消用户赞数</p><p>使用zrem</p></li><li><p>通过获赞数排名截取前几位</p><p>使用zrevrangebyrank </p></li><li><p>展示用户信息以及用户分数</p><p>zscore和zrank</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：列表类型</title>
      <link href="/2019/03/31/redis-lie-biao-lei-xing/"/>
      <url>/2019/03/31/redis-lie-biao-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>​        列表是用来存储多个有序的字符串，最多存储2的32次方减1个元素。</p><ul><li><p>支持两端插入(push)和弹出(pop)</p></li><li><p>获取指定范围的元素列表</p></li><li><p>获取指定索引下标的元素</p></li><li><p>可充当栈和队列的角色</p></li><li><p>列表的特点：</p><ul><li><p>元素是有序的</p></li><li><p>元素是允许重复的</p><p><img src="/2019/03/31/redis-lie-biao-lei-xing/1572258937(1).jpg" alt=""></p></li></ul></li></ul><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p>添加操作</p><ul><li><p>从右边插入</p><pre class=" language-shell"><code class="language-shell">  rpush key value[value ...]</code></pre></li><li><p>从左边插入</p><pre class=" language-shell"><code class="language-shell">lpush key value[value ...]</code></pre></li><li><p>向某个元素前或后插入元素</p><pre class=" language-shell"><code class="language-shell">linsert key before|after pivot value</code></pre></li></ul></li><li><p>查找</p><ul><li><p>获取指定范围的元素列表</p><pre class=" language-shell"><code class="language-shell">lrange key start end</code></pre></li><li><p>获取指定索引下标的元素</p><pre class=" language-shell"><code class="language-shell">lindex key index</code></pre></li><li><p>获取列表长度</p><pre class=" language-shell"><code class="language-shell">llen key</code></pre></li></ul></li><li><p>删除</p><ul><li><p>从列表左侧弹出元素</p><pre class=" language-shell"><code class="language-shell">lpop key</code></pre></li><li><p>右侧弹出元素</p><pre class=" language-shell"><code class="language-shell">rpop key</code></pre></li><li><p>删除指定元素(count &gt;0 ,从左到右，count&lt;0 从右到左，count = 0, 删除所有)</p><pre class=" language-shell"><code class="language-shell">lrem key count value</code></pre></li><li><p>按照索引范围修剪列表</p><pre class=" language-shell"><code class="language-shell">ltrim key start end</code></pre></li></ul></li><li><p>修改</p><pre class=" language-shell"><code class="language-shell">lset key index newValue</code></pre></li><li><p>阻塞操作(列表为空时，timeout=3，3秒后返回，timeout=0，客户端一直阻塞，直到新数据插入，列表不为空时，立即返回，多个客户端执行，遵循先到先得原则)</p><pre class=" language-shell"><code class="language-shell">blpop key [key ...] timeoutbrpop key [key ...] timeout</code></pre></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3. 内部编码"></a>3. 内部编码</h3><p>，        列表的内部编码有两种：</p><ul><li>ziplist(压缩列表)：当列表的元素个数小于list-max-ziplist-entries配置 （默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时 （默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使<br>用。</li><li>linkedlist(链表)：当ziplist无法满足时，采用linkedlist。</li><li>quicklist：以一个ziplist为节点的linkedlist，结合了两者的优势。</li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul><li><p>消息队列</p><p>​    lpush + brpop 可以实现阻塞队列组合</p></li><li><p>文章列表</p><p>​    列表不但有序，还支持索引范围获取元素</p></li><li><p>其他组合</p><p>​    lpush + lpop = Stack</p><p>​    lpish + rpop = Queue</p><p>​    lpsh + ltrim = Capped Collection(有限集合)</p><p>​    lpush + brpop = Message Queue(消息队列)</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：内存</title>
      <link href="/2019/03/27/redis-nei-cun/"/>
      <url>/2019/03/27/redis-nei-cun/</url>
      
        <content type="html"><![CDATA[<h3 id="1-内存消耗"><a href="#1-内存消耗" class="headerlink" title="1. 内存消耗"></a>1. 内存消耗</h3><p>​            内存消耗可以分为<strong>自身消耗</strong>和<strong>子进程消耗</strong>。</p><p>​            <img src="/2019/03/27/redis-nei-cun/1572428138468.png" alt="1572428138468"></p><ul><li><p><strong>对象内存</strong></p><p>​        内存占用最大的一块，存储用户所有数据，对象内存消耗可以理解为sizeof(keys)+sizeof(values)，键是字符串会消耗一定的内存，值为五种基本数据类型，或者由五种基本数据类型衍生的类型。</p></li><li><p><strong>缓冲内存</strong></p><p>​        缓冲内存包括<strong>客户端缓冲</strong>，<strong>复制积压缓冲</strong>，<strong>AOF缓冲区</strong>。</p><ul><li><em>普通客户端</em>：Redis并没有对普通客户端的输出缓冲区做限制，当有大量慢连接时，内存消耗不能忽略，使用大量数据输出的命令且数据无法及时推送给客户端时，会造成Redis服务器内存飙升。</li><li><em>从客户端</em>：主节点为从节点独建连接用于命令复制，当挂载过多节点或网络延迟高会造成内存消耗占用很大。</li><li><em>订阅客户端</em>：使用发布订阅会使用单独的输出缓冲区，当生产速度大于消费速度，会造成缓冲区空间溢出。</li><li><em>复制积压缓冲区</em>：可重用的固定大小的缓冲区用于实现复制功能，主节点只有一个，从节点共享此缓冲区。</li><li><em>AOF缓冲区</em>：用于在Redis重写期间保存最近的写入命令。</li></ul></li><li><p><strong>内存碎片</strong></p><ul><li>频繁更新操作</li><li>大量过期键删除</li><li>解决方法<ul><li>数据对齐，即数据尽可能采用数字类型或固定长度字符串</li><li>安全重启，重启可以做到内存碎片的整理</li></ul></li></ul></li><li><p><strong>子进程消耗</strong></p><p>​        <strong>子进程内存消耗主要指执行AOF/RDB重写时Redis创建的子进程内存消耗。</strong></p><ul><li>Redis子进程消耗并非父进程内存的1倍，根据期间写入命令量决定。</li><li>需要设置，允许内核可以分配所有的物理内存，防止fork时因内存不足而失败。</li><li>排查系统是否支持并开启THP，建议关闭。</li></ul></li></ul><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h3><p>​            <strong>Redis主要通过控制内存上限和回收策略实现内存管理。</strong></p><h5 id="2-1-设置内存上限"><a href="#2-1-设置内存上限" class="headerlink" title="2.1 设置内存上限"></a>2.1 设置内存上限</h5><ul><li>目的：<ul><li>用于缓存场景，超出内存上限时使用LRU等删除策略释放空间。</li><li>防止内存超过服务器物理内存</li></ul></li></ul><h5 id="2-2-动态调整内存上限"><a href="#2-2-动态调整内存上限" class="headerlink" title="2.2 动态调整内存上限"></a>2.2 动态调整内存上限</h5><p>​            Redis可以通过config set maxmemory 进行内存的动态修改，达到当前服务器下动态伸缩Redis内存的目的。</p><h5 id="2-3-内存回收策略"><a href="#2-3-内存回收策略" class="headerlink" title="2.3 内存回收策略"></a>2.3 内存回收策略</h5><ul><li><p>删除过期键对象</p><ul><li>惰性删除，客户读取超时属性的键，超过键的超时时间，会自动删除，但过期键一直没有访问，导致内存不能及时释放，可能造成内存泄漏问题。</li><li>定时任务删除，内部维护定时任务，一秒10次，采用自适应算法，根据键的过期比例、使用快慢两种速率模式回收键。</li></ul></li><li><p>内存溢出控制策略（6种策略）</p><table><thead><tr><th>策略名称</th><th>介绍</th></tr></thead><tbody><tr><td>noeviction</td><td>默认策略，拒绝所有写操作，不删除任何数据，返回OOM信息，只响应读操作</td></tr><tr><td>volatile-lru</td><td>根据lru算法删除过期键，直到空间足够，没有删除的键，回退默认策略</td></tr><tr><td>allkeys-lru</td><td>不管数据是否设置超时属性，直到腾出足够空间为止</td></tr><tr><td>allkeys-random</td><td>随机删除所有键，直到腾出足够空间</td></tr><tr><td>volatile-random</td><td>随机删除所有过期键，直到腾出足够空间为止</td></tr><tr><td>volatile-ttl</td><td>根据键值对象的ttl，删除最近要过期的数据，如果没有就回退默认策略</td></tr></tbody></table></li></ul><h3 id="3-内存优化"><a href="#3-内存优化" class="headerlink" title="3. 内存优化"></a>3. 内存优化</h3><ul><li><p><strong>redisObject对象</strong></p><p>​    redis存储的数据都使用redisObject来封装。</p><ul><li><em>type字段</em>：表示数据类型（string、hash、list、set、zset）</li><li><em>encoding：</em>内部编码类型</li><li><em>lru：</em>最后一次被访问的时间</li></ul></li><li><p>缩减键值对象</p><ul><li>key长度，越简短越好</li><li>value长度，将业务对象进行序列化成二进制数据放入redis中，常见的格式如json和xml，同样可以进行压缩存储。</li></ul></li><li><p>共享线程池</p><p>​        Redis内部维护【0-9999】的整数对象池，除了整数值对象之外，list、hash、set、zset内部元素也可以使用整数对象池。</p><p>​        注意事项：</p><ul><li>共享对象池和maxmemory+LRU策略冲突，因为LRU策略需要获取对象的最后访问时间，但共享对象意味着共享一个redisObject，lru字段也会共享。</li><li>对于ziplist编码的值对象，即使内部数据为整数也无法使用共享对象池，因为ziplist使用压缩且内存连续的结构，对象共享判断成本过高。</li></ul></li><li><p>字符串优化</p><ul><li><p>字符串结构</p><p><img src="/2019/03/27/redis-nei-cun/1572489998076.png" alt="1572489998076"></p><p>特点</p><ul><li>O(1)的时间复杂度，字符串长度，已用长度、未用长度</li><li>可用于保存字节数组，支持安全的二进制数据存储</li><li>内部实现空间预分配机制，降低再分配次数</li><li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留</li></ul></li><li><p>预分配机制</p><ul><li>尽量减少字符串的频繁修改操作如append、setrange等，直接使用set修改字符串，降低分配带来的内存浪费和内存碎片化。</li></ul></li><li><p>字符串重构</p><ul><li>不一定没份数据都按字符串进行存储，json可以使用hash结构进行存储，方便单个字段的修改。</li></ul></li></ul></li><li><p>编码优化</p><ul><li>编码类型转换在Redis写入数据时自动完成，过程不可逆，转换规则只能从小内存编码到大内存编码转换。</li><li>可以使用config set命令设置编码相关参数来满足使用压缩编码的条件。</li><li>已采用非压缩编码类型的数据，设置参数后，即使满足压缩编码条件也要重启redis重新加载数据才会生效。</li></ul></li><li><p>控制键数量</p><ul><li>通过在客户端预估键规模，把大量键分组映射到多个hash结构中降低键的数量。</li><li>hash的field记录键的字符串，value记录键的值</li><li>同样的数据使用ziplist编码的hash类型比string类型节约内存</li><li>节省内存随着value空间的减少越来越明显。</li><li>hash-ziplist类型比string类型写入耗时，但随着value空间的减少，耗时逐渐降低。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：集合类型</title>
      <link href="/2019/03/24/redis-ji-he-lei-xing/"/>
      <url>/2019/03/24/redis-ji-he-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>​        集合Set也用来保存多个字符串元素，但不允许有重复元素，并且时无序的，也无法通过下标进行元素获取，最多存储2的32次方减1个元素。</p><p><img src="/2019/03/24/redis-ji-he-lei-xing/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.PNG" alt=""></p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p>集合内操作</p><ul><li><p>添加元素</p><pre class=" language-shell"><code class="language-shell">sadd key element [element ...]</code></pre></li><li><p>删除元素</p><pre class=" language-shell"><code class="language-shell">srem key element [element ...]</code></pre></li><li><p>计算元素个数</p><pre class=" language-shell"><code class="language-shell">scard key</code></pre></li><li><p>判断元素是否存在</p><pre class=" language-shell"><code class="language-shell">sismember key element</code></pre></li><li><p>随机返回指定个数元素(count 默认为 1)</p><pre class=" language-shell"><code class="language-shell">srandmember key [count]</code></pre></li><li><p>随机弹出元素</p><pre class=" language-shell"><code class="language-shell">spop key</code></pre></li><li><p>获取所有元素</p><pre class=" language-shell"><code class="language-shell">smembers key</code></pre></li></ul></li><li><p>集合间操作</p><ul><li><p>交集</p><pre class=" language-shell"><code class="language-shell">sinter key [key ...]</code></pre></li><li><p>并集</p><pre class=" language-shell"><code class="language-shell">suinon key [key ...]</code></pre></li><li><p>差集</p><pre class=" language-shell"><code class="language-shell">sdiff key [key ...]</code></pre></li><li><p>保存上述结果</p><pre class=" language-shell"><code class="language-shell">sinterstore destination key [key ...]suionstore destination key [key ...]sdiffstore destination key [key ...]</code></pre></li></ul></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3. 内部编码"></a>3. 内部编码</h3><p>​        集合类型编码有两种：</p><ul><li><p>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实<br>现，从而减少内存的使用。</p></li><li><p>hashtable（哈希表）：intset无法满足时，采用hashtable。</p></li></ul><h3 id="4-场景"><a href="#4-场景" class="headerlink" title="4.场景"></a>4.场景</h3><ul><li>给用户添加标签<ul><li>给用户添加标签</li><li>给标签添加用户</li><li>删除用户下的标签</li><li>删除标签下的用户</li></ul></li><li>组合<ul><li>sadd=Tagging(标签)</li><li>spop/srandmember = Random item(生成随机数，比如抽奖)</li><li>sadd+sinter = Social Graph(社交需求)</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：持久化</title>
      <link href="/2019/03/18/redis-chi-jiu-hua/"/>
      <url>/2019/03/18/redis-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>​        Redis的持久化支持<strong>RDB</strong>和<strong>AOF</strong>两种持久化机制，持久化能有效避免进程的退出造成数据的丢失问题，保证重启时，利用持久化文件进行数据的恢复。</p><h3 id="2-RDB"><a href="#2-RDB" class="headerlink" title="2. RDB"></a>2. RDB</h3><h5 id="2-1-持久化触发"><a href="#2-1-持久化触发" class="headerlink" title="2.1 持久化触发"></a>2.1 持久化触发</h5><p>​        <strong>RDB</strong>的持久化分为<strong>手动触发</strong>和<strong>自动触发</strong>，是把当前进程数据生成快照保存到硬盘的过程。</p><ul><li><p>手动触发分别对应<strong>save</strong>和<strong>bgsave</strong></p><ul><li><strong>save：</strong> 阻塞当前服务器，知道RDB完成</li><li><strong>bgsave：</strong> Redis进程执行fork操作创建子进程，子进程负责持久化，阻塞发生在fork阶段。</li></ul></li><li><p>自动触发</p><ul><li>使用save相关配置 触发bgsave。</li><li>从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件发送给从节点。</li><li>执行debug reload 重新加载Redis。</li><li>默认情况执行shutdown，没有开启AOF持久化功能。</li></ul></li></ul><h5 id="2-2-bgsave命令运作流程"><a href="#2-2-bgsave命令运作流程" class="headerlink" title="2.2 bgsave命令运作流程"></a>2.2 bgsave命令运作流程</h5><p><img src="/2019/03/18/redis-chi-jiu-hua/1572338742164.png" alt="1572338742164"></p><ol><li>执行bgsave，父进程判断是否有子进程存在，若有直接返回。</li><li>父进程阻塞，fork创建子进程。</li><li>父进程fork完成之后，不再进行阻塞。</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成对原有文件进行原子替换。</li><li>进程发送信号给父进程表示完成。</li></ol><h5 id="2-3-RDB的优缺点"><a href="#2-3-RDB的优缺点" class="headerlink" title="2.3 RDB的优缺点"></a>2.3 RDB的优缺点</h5><ul><li><p><strong>优点</strong></p><ul><li>紧凑压缩的二进制文件，适于备份，全量复制等场景。</li><li>恢复数据速度远远快于AOF的方式</li></ul></li><li><p><strong>缺点</strong></p><ul><li>无法做到实时持久化和秒级持久化，需要创建子进程，成本高。</li><li>使用 二进制格式保存，老版可能无法兼容新版RDB格式</li></ul></li></ul><h3 id="3-AOF"><a href="#3-AOF" class="headerlink" title="3. AOF"></a>3. AOF</h3><p>​        以独立日志的方式记录每次写命令，重启执行AOF进行数据恢复。解决了持久化的实时性。</p><p>​        默认不开启，开启需要配置 <strong>appendonly yes</strong>,文件名默认为：<strong>appendonly.aof</strong></p><h5 id="3-1-工作流"><a href="#3-1-工作流" class="headerlink" title="3.1 工作流"></a>3.1 工作流</h5><p><img src="/2019/03/18/redis-chi-jiu-hua/1572340821778.png" alt="1572340821778"></p><ol><li><p>命令写入</p><ul><li>所有写入命令会追加到缓冲区</li><li>写入的内容是文本协议格式（很好的兼容性，直接追加，避免二次处理，具有可读性，方便修改处理）</li><li>如果写入硬盘则性能受限，写入缓存redis提供多种同步硬盘策略</li></ul></li><li><p>文件同步</p><ul><li>缓冲区根据对应策略向硬盘同步</li><li>redis提供多种缓冲区同步文件策略</li></ul></li><li><p>文件重写</p><ul><li><p>AOF文件越来越大，需要定期重写，压缩</p></li><li><p>将redis进程内的数据转为写命令同步到新AOF文件</p></li><li><p>降低了文件占用空间，更小的更快进行加载。</p></li><li><p>可以手动触发和自动触发</p><p><img src="/2019/03/18/redis-chi-jiu-hua/1572341878158.png" alt="1572341878158"></p><ol><li><p>执行AOF请求</p></li><li><p>父进程fork创建子进程</p></li><li><p>3.1 主进程fork完响应其他命令，修改内容写入缓冲区，并根据同步策略同步到硬盘</p><p>3.2 fork采用写时复制技术，子进程只能共享fork操作的内存数据，缓冲区保存新数据</p></li><li><p>子进程根据内存快照，写入新AOF文件中。默认32M。</p></li><li><p>5.1 子进程发送信号给父进程，父进程更新统计信息</p><p>5.2  父进程将缓冲区数据写入新AOF文件</p><p>5.3 使用新AOF文件替换旧文件，完成重写。</p></li></ol></li></ul></li><li><p>重启加载</p><ul><li>加载AOF文件进行数据恢复</li></ul></li></ol><p><img src="/2019/03/18/redis-chi-jiu-hua/1572342471292.png" alt="1572342471292"></p><ul><li>AOF持久化开启，并且存在AOF文件，优先加载AOF文件</li><li>上面不成立，则加载RDB文件</li><li>加载完毕后，成功启动</li><li>否则 启动失败，打印错误信息</li></ul><h3 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h3><h5 id="4-1-fork操作的优化"><a href="#4-1-fork操作的优化" class="headerlink" title="4.1 fork操作的优化"></a>4.1 fork操作的优化</h5><ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例最大可用内存，fork耗时和内存成正比</li><li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败</li><li>降低fork操作频率，放宽AOF自动触发时机，避免全量复制</li></ul><h5 id="4-2-子进程优化"><a href="#4-2-子进程优化" class="headerlink" title="4.2 子进程优化"></a>4.2 子进程优化</h5><ul><li><strong>CPU</strong><ul><li>Redis是CPU密集型服务，不要做绑定单核CPU操作。</li><li>避免和CPU密集服务部署，造成CPU过度竞争。</li><li>多个实例下，尽可能保证同时只有一个子进程执行重写工作。</li></ul></li><li>内存<ul><li>多个实例下，尽可能保证同时只有一个子进程执行重写工作。</li><li>避免大量写入时，进行子进程重写操作，导致父进程维护大量页副本。</li></ul></li><li>硬盘<ul><li>不要和其他高硬盘负载服务部署在一起，如消息队列，存储服务</li><li>AOF重写消耗大量硬盘IO,设置在AOF重写期间不做fsync操作</li><li>高流量写入场景，瓶颈在AOF同步硬盘上</li><li>单机配置多实例，可配置不同实例分盘存储AOF文件，平摊写入压力。</li></ul></li></ul><h3 id="5-多实例部署（监控轮询）"><a href="#5-多实例部署（监控轮询）" class="headerlink" title="5.多实例部署（监控轮询）"></a>5.多实例部署（监控轮询）</h3><p>​        Redis属于单线程架构，所以单台机器会部署多个实例，但同时开启AOF重写后，彼此会产生CPU和IO的竞争。</p><p>​        可以通过外部程序轮询控制AOF重写操作的执行</p><ul><li>外部程序定时轮询监控所有实例</li><li>对开启AOF的实例，确定其增长率</li><li>增长率超过一定值，手动触发当前实例重写</li><li>运行期间循环检查，直到AOF重写结束</li><li>确认实例AOF重写完成后，再检查其他实例并重复2~4.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：哈希类型</title>
      <link href="/2019/03/16/redis-ha-xi-lei-xing/"/>
      <url>/2019/03/16/redis-ha-xi-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p><img src="/2019/03/16/redis-ha-xi-lei-xing/1572256259607.png" alt="1572256259607"></p><p>​        哈希类型的值可以是字符串，数字，哈希，但键只能是字符串</p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p>设置值(可以给一个键设置多次，即设置多个值)</p><pre class=" language-shell"><code class="language-shell">hest key field value</code></pre></li><li><p>获取值</p><pre class=" language-shell"><code class="language-shell">hget key field</code></pre></li><li><p>删除值</p><pre class=" language-shell"><code class="language-shell">hdel key field[field ...]</code></pre></li><li><p>计算field个数</p><pre class=" language-shell"><code class="language-shell">hlen key </code></pre></li><li><p>批量设置或获取filed-value</p><pre class=" language-shell"><code class="language-shell">hmget key fieldhmset key field value [field value ...]</code></pre></li><li><p>判断是否存在</p><pre class=" language-shell"><code class="language-shell">hexists key field</code></pre></li><li><p>获取所有field</p><pre class=" language-shell"><code class="language-shell">hkeys key</code></pre></li><li><p>获取所有value</p><pre class=" language-shell"><code class="language-shell">hvals key</code></pre></li><li><p>获取所有的field-value（元素太多可能造成阻塞，建议使用hscan渐进式遍历）</p><pre class=" language-shell"><code class="language-shell">hgetall key</code></pre></li><li><p>计数</p><pre class=" language-shell"><code class="language-shell">hincrby key fieldhincrbyfloat key field</code></pre></li><li><p>计算value的字符串长度</p><pre class=" language-shell"><code class="language-shell">hstrlen key field</code></pre></li></ul><h3 id="3-内部编码"><a href="#3-内部编码" class="headerlink" title="3.内部编码"></a>3.内部编码</h3><p>​        哈希类型的内部编码有两种：</p><ul><li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries 配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64子节）是采用。比hashtable更加节省内存。</li><li>hashtable（哈希表）：当ziplist无法满足时，采用hashtable，时间复杂度为O(1)。</li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul><li><p>相对于字符串序列化缓存用户信息，哈希类型更加直观</p></li><li><p>哈希类型与关系型数据库的不同：</p><ul><li>哈希的类型是稀疏的，键可以有多个值</li><li>不能做关联模拟查询，成本高</li></ul></li><li><p>三种缓存方式比较：</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>原生字符串，每个属性一个键</td><td>简单直观，每个属性支持独立更新</td><td>占用过多键，占用内存大</td></tr><tr><td>序列化，一键保存</td><td>显著提高内存效率</td><td>序列化和反序列化需要一定开销，修改开销大</td></tr><tr><td>哈希类型</td><td>有效提高内存效率</td><td>要控制ziplist和hashtable的转换。后者消耗更多内存</td></tr></tbody></table></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：基础介绍</title>
      <link href="/2019/03/16/redis-ji-chu-jie-shao/"/>
      <url>/2019/03/16/redis-ji-chu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-全局命令"><a href="#1-全局命令" class="headerlink" title="1. 全局命令"></a>1. 全局命令</h3><ul><li><p>查看所有键</p><pre class=" language-shell"><code class="language-shell">keys *    </code></pre></li><li><p>键总数</p><pre class=" language-shell"><code class="language-shell">dbsize</code></pre></li><li><p>检查键是否存在</p><pre class=" language-shell"><code class="language-shell">exists key </code></pre></li><li><p>删除键(支持删除多个)</p><pre class=" language-shell"><code class="language-shell">del key</code></pre></li><li><p>键过期</p><pre class=" language-shell"><code class="language-shell">expire key seconds</code></pre></li><li><p>键过期剩余时间(-1 : 没有过期时间， -2 ： 键不存在)</p><pre class=" language-shell"><code class="language-shell">ttl key</code></pre></li><li><p>键的数据结构类型(不存在返回none)</p><pre class=" language-shell"><code class="language-shell">type key</code></pre></li><li><p>查看内部编码</p><pre class=" language-shell"><code class="language-shell">objecy encoding key </code></pre></li></ul><h3 id="2-数据结构和内部编码"><a href="#2-数据结构和内部编码" class="headerlink" title="2. 数据结构和内部编码"></a>2. 数据结构和内部编码</h3><h5 id="2-1-五种数据结构"><a href="#2-1-五种数据结构" class="headerlink" title="2.1 五种数据结构"></a>2.1 五种数据结构</h5><p><img src="/2019/03/16/redis-ji-chu-jie-shao/1571973182171.png" alt="1571973182171"></p><h5 id="2-2-数据结构和内部编码"><a href="#2-2-数据结构和内部编码" class="headerlink" title="2.2 数据结构和内部编码"></a>2.2 数据结构和内部编码</h5><p><img src="/2019/03/16/redis-ji-chu-jie-shao/1571973218076.png" alt="1571973218076"></p><h3 id="3-单线程架构"><a href="#3-单线程架构" class="headerlink" title="3. 单线程架构"></a>3. 单线程架构</h3><p>​        Redis使用了<strong>单线程架构</strong>和<strong>I/O多路复用模型</strong>来实现高性能的内存数据服务。</p><p>​        单线程快的原因：</p><ul><li>纯内存访问</li><li>非阻塞I/O</li><li>避免线程切换和竞态产生的消耗    </li></ul><p><img src="/2019/03/16/redis-ji-chu-jie-shao/1572254956036.png" alt="1572254956036"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：基础命令</title>
      <link href="/2019/03/10/redis-ji-chu-ming-ling/"/>
      <url>/2019/03/10/redis-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        <strong>Redis</strong>是一个使用<a href="https://zh.wikipedia.org/wiki/ANSI_C" target="_blank" rel="noopener">ANSI C</a>编写的<a href="https://zh.wikipedia.org/wiki/开源" target="_blank" rel="noopener">开源</a>、支持<a href="https://zh.wikipedia.org/wiki/电脑网络" target="_blank" rel="noopener">网络</a>、基于<a href="https://zh.wikipedia.org/wiki/内存" target="_blank" rel="noopener">内存</a>、可选<a href="https://zh.wikipedia.org/w/index.php?title=持久性_(数据库)&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">持久性</a>的<a href="https://zh.wikipedia.org/wiki/键值-值数据库" target="_blank" rel="noopener">键值对存储数据库</a>，其特点如下：</p><ul><li>速度快</li><li>基于键值对的数据结构服务器</li><li>丰富的功能<ul><li>键过期</li><li>发布订阅</li><li>支持Lua</li><li>提供简单事务</li><li>提供流水线功能</li></ul></li><li>简单稳定</li><li>客户端语言多</li><li>持久化（AOF RDB）</li><li>主从复制</li><li>高可用和分布式</li></ul><p><strong>可以做什么</strong></p><ul><li>缓存</li><li>排行榜系统</li><li>计数器应用</li><li>社交网络</li><li>消息队列系统</li></ul><h3 id="1-Redis的安装"><a href="#1-Redis的安装" class="headerlink" title="1. Redis的安装"></a>1. Redis的安装</h3><h3 id="2-Redis的启动"><a href="#2-Redis的启动" class="headerlink" title="2. Redis的启动"></a>2. Redis的启动</h3><p>​        redis的启动有三种方式：</p><ul><li><p>默认启动</p><pre class=" language-shell"><code class="language-shell">redis-server</code></pre></li><li><p>运行启动(redis-server –configKey1 configValue1 –configKey2 configValue2)</p><pre class=" language-shell"><code class="language-shell">redis-server --port 6380 </code></pre></li><li><p>配置文件启动</p><pre class=" language-shell"><code class="language-shell">redis-server /opt/redis/redis.conf</code></pre></li></ul><h3 id="3-Redis命令客户端"><a href="#3-Redis命令客户端" class="headerlink" title="3. Redis命令客户端"></a>3. Redis命令客户端</h3><ul><li><p>交互式，一经连接，之后只输入命令返回结果</p><pre class=" language-shell"><code class="language-shell">redis-cli -h 127.0.0.1 -p 6379</code></pre></li><li><p>命令式</p><pre class=" language-shell"><code class="language-shell">redis-cli -h 127.0.0.1 -p 6379 get hello</code></pre></li></ul><h3 id="4-停止服务"><a href="#4-停止服务" class="headerlink" title="4. 停止服务"></a>4. 停止服务</h3><ul><li><p>停止服务(断开客户端的连接，生成持久化文件)</p><pre class=" language-shell"><code class="language-shell">redis-cli shutdown</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis：安装</title>
      <link href="/2019/03/03/redis-an-zhuang/"/>
      <url>/2019/03/03/redis-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  在官网进行redis的下载:<a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis官网</a></p><h1 id="1-安装Redis"><a href="#1-安装Redis" class="headerlink" title="1.安装Redis"></a>1.安装Redis</h1><ul><li>解压安装包</li></ul><pre class=" language-shell"><code class="language-shell">tar -zxvf  redis-5.0.4.tar.gz</code></pre><ul><li>进入解压后的安装包进行编译(时间较长)</li></ul><pre class=" language-shell"><code class="language-shell">make</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567668459576.png" alt="1567668459576"></p><p>出现以上结果，表明编译成功。</p><ul><li>运行make test 进行测试(貌似这一步可以跳过)</li></ul><pre class=" language-shell"><code class="language-shell">make test</code></pre><p>我这边报错，提示需要tcl 8.5 才能进行make test。</p><p><img src="/2019/03/03/redis-an-zhuang/1567668669399.png" alt="1567668669399"></p><p>去官网下载了tcl8.6.9.tar.gz，在解压安装之后，但在进行tcl编译的过程中会报错，最后采用yum命令进行了tcl的安装。</p><pre class=" language-shell"><code class="language-shell">yum install tcl</code></pre><p>再进行 make test </p><ul><li>进入src下进行安装</li></ul><pre class=" language-shell"><code class="language-shell">make install</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567671273931.png" alt="1567671273931"></p><ul><li>查看安装版本</li></ul><pre class=" language-shell"><code class="language-shell">redis-cli -v</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567671322453.png" alt="1567671322453"></p><ul><li>启动redis(默认启动方式)</li></ul><pre class=" language-shell"><code class="language-shell">redis-server</code></pre><p><img src="/2019/03/03/redis-an-zhuang/1567671488856.png" alt="1567671488856"></p><p>​            OK,安装成功！</p><p>``</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat：Linux多安装配置</title>
      <link href="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/"/>
      <url>/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h1><p>  关于jdk环境的安装详见</p><h1 id="2-tomcat安装配置"><a href="#2-tomcat安装配置" class="headerlink" title="2. tomcat安装配置"></a>2. tomcat安装配置</h1><ul><li>解压压缩包<pre class=" language-shell"><code class="language-shell">tar -zxvf apache-tomcat-8.5.45.tar.gz</code></pre></li><li>将解压后的tomcat文件夹重命名</li></ul><pre class=" language-shell"><code class="language-shell">mv apache-tomcat-8.5.45 tomcat8080</code></pre><ul><li>再次解压，重命名</li></ul><pre class=" language-shell"><code class="language-shell">tar -zxvf apache-tomcat-8.5.45.tar.gzmv apache-tomcat-8.5.45 tomcat8090</code></pre><ul><li>这时文件下面有两个tomcat 即 tomcat8080和tomcat8090</li></ul><p><img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567647778105.png" alt="1567647778105"></p><ul><li><p>配置环境变量（重点）</p><ul><li><p>编辑 /etc/profile文件 增加如下内容（注意采用自己的路径）：</p><pre class=" language-shell"><code class="language-shell">##########tomcat8080###########export CATALINA_HOME=/usr/lixs/tomcat/tomcat8080export CATALINA_BASE=/usr/lixs/tomcat/tomcat8080export TOMCAT_HOME=/usr/lixs/tomcat/tomcat8080###########tomcat8090############export CATALINA_2_HOME=/usr/lixs/tomcat/tomcat8090export CATALINA_2_BASE=/usr/lixs/tomcat/tomcat8090export TOMCAT_2_HOME=/usr/lixs/tomcat/tomcat8090</code></pre><p>改完/etc/profile 之后执行命令 使其生效：</p><pre class=" language-shell"><code class="language-shell">source /etc/profile</code></pre></li></ul></li><li><p>编辑tomcat8090的bin下的catalina.sh,增加以下语句（重点）：</p><pre class=" language-shell"><code class="language-shell">  # OS specific support.  $var _must_ be set to either true or false.  export CATALINA_BASE=$CATALINA_2_BASE  export CATALINA_HOME=$CATALINA_2_HOME</code></pre></li><li><p>编辑tomca8090的conf下的server.xml</p><pre class=" language-shell"><code class="language-shell"><Server port="8006" shutdown="SHUTDOWN">  #8005 ---》8006   <Connector port="8090" protocol="HTTP/1.1"    #8080---》8090                 connectionTimeout="20000"                 redirectPort="8443" /></code></pre></li></ul><pre><code>&lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8443" /&gt;   #8009 ---》8010```</code></pre><ul><li><p>修改tomcat各自的首页,以tomcat8080为例</p><pre class=" language-shell"><code class="language-shell">   vim /usr/lixs/tomcat/tomcat8080/webapps/ROOT/index.jsp  </code></pre><p>  修改如下：</p><p>  <img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567650064119.png" alt="1567650064119"></p></li><li><p>去tomcat8080的bin和tomcat8090的bin下面分别启动tomcat</p><pre class=" language-shell"><code class="language-shell">  ./startup.sh</code></pre></li><li><p>浏览器调用不同端口，结果显示如下：</p><p>  8080端口的tomcat</p></li></ul><p><img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567650140081.png" alt="1567650140081"></p><p>​    8090端口的tomcat</p><p><img src="/2019/02/24/tomcat-linux-duo-an-zhuang-pei-zhi/1567650181367.png" alt="1567650181367"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx：原理规则解析</title>
      <link href="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/"/>
      <url>/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Nginx是一款免费开源的高性能HTTP代理服务器及反向代理服务器（Reverse Proxy）产品,同时提供IMAP/POP3邮件代理等功能。最频繁使用的是Nginx的<strong>负载均衡</strong>和<strong>反向代理</strong>两个功能，但其功能还不至这些。</p><p>​        Nginx 特点：</p><ul><li>更快</li><li>高扩展性</li><li>高可靠性</li><li>低内存消耗</li><li>单机支持10w+的并发连接</li><li>热部署</li></ul><p>​        Nginx是由内核和一系列模块组成，内核提供web服务的基本功能，如启用网络协议，创建运行环境，接受和分配客户端请求，处理模块之间的交互。Nginx的各种功能和操作都是由模块来实现。Nginx的模块从结构上分为核心模块、基础模块和第三方模块。</p><ul><li>核心模块：HTTP模块、EVENT模块和MAIL模块</li><li>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块</li><li>第三方模块：HTTP Upsream Request Hash模块、Notice模块和HTTP Access Key模块等。</li></ul><h1 id="1-常用功能"><a href="#1-常用功能" class="headerlink" title="1. 常用功能"></a>1. 常用功能</h1><h3 id="1-1-反向代理"><a href="#1-1-反向代理" class="headerlink" title="1.1 反向代理"></a>1.1 反向代理</h3><p>  常见的<strong>正向代理</strong>模式，如VPN的使用，我们挂载VPN访问墙外网站时，自身的IP是不能访问的，我们首先通过VPN进入公网的IP，再经由公网的IP去获取墙外资源，这里正向代理是VPN，由<strong>VPN代理客户端获取资源</strong>。<br>  <strong>反向代理</strong>模式，恰恰相反，客户端的请求会首先经过Nginx服务器，Nginx将服务请求分发到相应的WEB服务器，这里的Nginx就是反向代理，代理的是资源服务器，<strong>我们只需将请求发送到反向代理服务器，不在乎，请求被Nginx传递给谁，正如VPN案例中，资源服务器将资源返回给VPN，不在乎VPN将会把资源传递给谁一样</strong>。</p><ul><li><strong>正向代理—-VPN代理我们去和服务器交涉</strong>。</li><li><strong>反向代理—-Nginx代理服务器和我们交涉</strong>。<br>  Nginx在提供代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置灵活，转发过程中不关心网络环境如何，可指定任意的IP地址和端口号，或其他类型的连接、请求等。</li></ul><p><strong>示例：</strong><br>  以本服务器上安装的tomcat作为示例,配置nginx对tomcat 的访问进行代理。</p><p>​        本机tomcat访问路径为：106.12.128.114:8080/</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567599370340.png" alt="1567599370340"></p><ul><li><p>编辑nginx的配置文件nginx.conf<br><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567598657319.png" alt="1567598657319"></p></li><li><p>找到这段代码，注释掉 root html 这一行。</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567598746032.png" alt="1567598746032"></p></li><li><p>添加 proxy_pass <a href="http://106.12.128.114:8080" target="_blank" rel="noopener">http://106.12.128.114:8080</a>; 即tomcat的访问路径</p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567599565318.png" alt="1567599565318"></li><li><p>在nginx 的sbin 目录下 调用命令 ./nginx -s reload  重启nginx，并使新配置文件生效</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567598999790.png" alt="1567598999790"></p></li><li><p>这时候访问 <a href="http://106.12.128.114" target="_blank" rel="noopener">http://106.12.128.114</a> 会直接跳到tomcat的显示页面，因为nginx已经进行了代理。</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1567599344314.png" alt="1567599344314"></p></li></ul><h3 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h3><p>  负载均衡可以分为两种，即将单一的重负载分担到多个网络节点上做并行处理，每个节点处理完成之后将结果汇总返回给用户，大幅提高网络系统的处理能力。另外就是，将大量的前端并发请求或数据流量分担到多个后端网络节点上分别处理，有效降低前端用户等待相应的时间。而Nginx负载均衡属于后一方面，保证用户访问效率，减少后端服务器处理压力。</p><p>  负载均衡的算法主要分为两大类：</p><ul><li><p><strong>静态负载均衡算法</strong>：主要包括<strong>轮询算法</strong>、<strong>基于比率的加权轮询算法</strong>或者<strong>基于优先级的加权轮询算法</strong>。</p></li><li><p><strong>动态负载均衡算法</strong>：主要包括<strong>基于任务量的最少连接优化算法</strong>、<strong>基于性能的最快响应优先算法</strong>、<strong>预测算法</strong>和<strong>动态性能分配算法</strong>等。</p><p>静态负载均衡在一般的网络环境下也能表现的比较好，动态负载均衡算法更适用于复杂的网络环境。</p><h5 id="1-2-1-普通轮询算法"><a href="#1-2-1-普通轮询算法" class="headerlink" title="1.2.1 普通轮询算法"></a>1.2.1 普通轮询算法</h5><p>  普通轮询算法是指，当任务传递过来时，会按照一个固定的顺序，将任务分配下去。缺陷是，由于客观原因，我们不能保证每个节点的处理速度和能力是相同的，即A处理100个同时，B只能处理50个，因为这样一视同仁的算法存在一定问题。<br>  下面以tomcat作为示例，<strong>服务器安装配置多个tomcat</strong>详见博文XXXXX。</p></li></ul><p>  nginx.conf配置代码如下：</p><pre class=" language-shell"><code class="language-shell"> upstream OrdinaryPolling {      server 106.12.128.114:8080;      server 106.12.128.114:8090;      }      server {          listen       80;          server_name  localhost;          location / {             proxy_pass http://OrdinaryPolling;             index  index.html index.htm index.jsp;         }     }</code></pre><h5 id="1-2-2-基于比例加权轮询"><a href="#1-2-2-基于比例加权轮询" class="headerlink" title="1.2.2 基于比例加权轮询"></a>1.2.2 基于比例加权轮询</h5><p>  nginx.conf配置代码如下：</p><pre class=" language-shell"><code class="language-shell"> upstream OrdinaryPolling {      server 106.12.128.114:8080 weight=5;      server 106.12.128.114:8090 weight=2;      }      server {          listen       80;          server_name  localhost;          location / {             proxy_pass http://OrdinaryPolling;             index  index.html index.htm index.jsp;         }     }</code></pre><p>加权轮询的区别在于加上了weight，普通轮询实质上也是基于比例的加权轮询算法，只不过weight都是1.</p><h5 id="1-2-3-基于IP路由负载"><a href="#1-2-3-基于IP路由负载" class="headerlink" title="1.2.3 基于IP路由负载"></a>1.2.3 基于IP路由负载</h5><p>  在请求经由服务器处理时，服务器会保存相关的会话信息，比如session，但如果是轮询模式下，session在不同服务器之间是不能共享的，可能导致用户每次发起请求都需要进行登录验证。<br>  解决上述问题有两种思路：</p><ul><li>采用中间件，将登录信息保存在中间件上，比如redis,这样第一次登录时，保存会话信息到redis中，当轮询跳转时，先去redis上查询登录信息，如果有就直接操作，没有就保存到redis上。</li><li>根据客户端的IP地址划分，即将一个IP的请求全部发送到同一个服务器上，就不存在session共享的问题，nginx的基于IP路由负载，就是该形式，详细实例代码如下：</li></ul><pre class=" language-shell"><code class="language-shell">     upstream OrdinaryPolling {       ip_hash      server 106.12.128.114:8080 weight=5;      server 106.12.128.114:8090 weight=2;      }      server {          listen       80;          server_name  localhost;          location / {             proxy_pass http://OrdinaryPolling;             index  index.html index.htm index.jsp;         }     }</code></pre><p>  区别在于加上了 <strong>ip_hash</strong>.</p><h5 id="1-2-4-基于服务器响应时间负载分配"><a href="#1-2-4-基于服务器响应时间负载分配" class="headerlink" title="1.2.4 基于服务器响应时间负载分配"></a>1.2.4 基于服务器响应时间负载分配</h5><p>  根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配。<br>代码同上 只是将 <strong>ip_hash</strong> 替换为<strong>fair</strong>。</p><h5 id="1-2-5-对不同域名实现负载均衡"><a href="#1-2-5-对不同域名实现负载均衡" class="headerlink" title="1.2.5 对不同域名实现负载均衡"></a>1.2.5 对不同域名实现负载均衡</h5><p>  配合location指令块实现对不同域名实现负载均衡。</p><pre class=" language-shell"><code class="language-shell">upstream wordbackend {    server 127.0.0.1:8080;    server 127.0.0.1:8081;    }    upstream pptbackend {    server 127.0.0.1:8082;    server 127.0.0.1:8083;    }    server {        listen       80;        server_name  localhost;        location /word/ {            proxy_pass http://wordbackend;            index  index.html index.htm index.jsp;        }    location /ppt/ {            proxy_pass http://pptbackend;            index  index.html index.htm index.jsp;        }    }</code></pre><h5 id="1-2-6-upstream参数补充"><a href="#1-2-6-upstream参数补充" class="headerlink" title="1.2.6 upstream参数补充"></a>1.2.6 upstream参数补充</h5><pre class=" language-shell"><code class="language-shell">service #权重字段weight# nginx对服务进行心跳检测，达到一定程度后，认为挂了，就剔除掉。max_fails#恢复检测时长，剔除后或宕机后 隔一定的时间检测服务是否可以继续用，然后进行下线或者上线操作#（所有服务宕掉后，隔一定的时间拉起备份服务，服务正常后，隔一定时间下线备份服务）fail_timeout# 标记备份服务，当所有服务宕掉后，该服务会顶上，其他服务恢复后，该服务退下backup# 项目服务允许的最大连接数max_conns</code></pre><h3 id="1-3-Web缓存"><a href="#1-3-Web缓存" class="headerlink" title="1.3 Web缓存"></a>1.3 Web缓存</h3><p>  Nginx会对用户已经访问过的内容在服务器本地建立副本，这段时间内再次访问是，不需要Nginx再向服务器后端发送请求，缓存前端请求，提高Web服务器的性能。</p><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><h5 id="1-4-1-Master-Worker模式"><a href="#1-4-1-Master-Worker模式" class="headerlink" title="1.4.1 Master-Worker模式"></a>1.4.1 Master-Worker模式</h5><ul><li><strong>Master</strong>：负责读取验证配置文件nginx.conf,管理worker进程。</li><li><strong>Worker</strong>：每一个Worker进程维护一个线程（避免线程切换），处理连接和请求。其个数由配置文件决定，和CPU个有关，配置几个就有几个work进程。</li></ul><p>​        </p><p>​            配置文件中设定的worker数量：</p><p>1573199360734</p><p>​            查看进程：</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1573199430465.png" alt="1573199430465"></p><p>​            工作模型：</p><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/153561774023221fec6df27%5B1%5D.jpg" alt=""></p><h5 id="1-4-2-用途"><a href="#1-4-2-用途" class="headerlink" title="1.4.2 用途"></a>1.4.2 用途</h5><ul><li>Nginx 可以作为web server处理静态资源，这也是nginx能提高速度的一个主要原因，静态资源nginx处理，动态请求转发给后端</li><li>可以在Nginx下把静态资源、日志文件归属到不同的域名之下，方便维护管理。</li><li>Nginx可以进行IP访问控制，黑名单可以在Nginx中进行拦截，不必交给后端进行处理。</li><li>对于Tomcat而言，请求的IP是Nginx的地址，并非真实的request地址，Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER.</li></ul><h5 id="1-4-3-思考"><a href="#1-4-3-思考" class="headerlink" title="1.4.3 思考"></a>1.4.3 思考</h5><ul><li><p><strong>Nginx如何做到热部署？</strong></p><p>​    修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求都必须交给新的worker进程，旧的进程在处理完请求之后，全部kill掉即可。</p></li><li><p><strong>Nginx如何做到高并发下的高效处理？</strong></p><p>​    Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程为异步，worker只需从队列中循环处理即可。</p></li><li><p><strong>Nginx挂了如何处理？</strong></p><ul><li><p>keepalived + Nginx实现高可用。</p></li><li><p>请求不直接打到Nginx上，应该先通过Keepalived。</p></li><li><p>Keepalived应该能监控Nginx的生命状态。</p></li></ul><p><img src="/2019/02/16/nginx-yuan-li-gui-ze-jie-xi/1535617740483760159cc3a%5B1%5D.jpg" alt=""></p></li></ul><p>  参考博客：<a href="https://www.cnblogs.com/ysocean/p/9392908.html" target="_blank" rel="noopener">Nginx反向代理</a></p><p>​                          <a href="https://blog.csdn.net/yinwenjie/article/details/46620711" target="_blank" rel="noopener">架构设计：负载均衡方案</a>            </p><p>​                          <a href="https://segmentfault.com/a/1190000007803704" target="_blank" rel="noopener">Nginx+Tomcat整合体验</a></p><p>​                        <a href="https://www.jianshu.com/p/7d3360bb1250" target="_blank" rel="noopener">https://www.jianshu.com/p/7d3360bb1250</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx：安装与配置文件详解</title>
      <link href="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/"/>
      <url>/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Nginx–Liunx安装"><a href="#1-Nginx–Liunx安装" class="headerlink" title="1.Nginx–Liunx安装"></a>1.Nginx–Liunx安装</h1><h3 id="1-安装nginx环境"><a href="#1-安装nginx环境" class="headerlink" title="1. 安装nginx环境"></a>1. 安装nginx环境</h3><pre class=" language-shell"><code class="language-shell">1 yum install gcc-c++2 yum install -y pcre pcre-devel3 yum install -y zlib zlib-devel4 yum install -y openssl openssl-devel</code></pre><ul><li>gcc，因为安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境的话，需要安装gcc。</li><li>pcre，prce(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</li><li>zlib，zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</li><li>openssl，OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</li></ul><h3 id="2-正式安装"><a href="#2-正式安装" class="headerlink" title="2. 正式安装"></a>2. 正式安装</h3><ul><li>下载nginx1.8.0版本</li></ul><pre class=" language-shell"><code class="language-shell">wget http://nginx.org/download/nginx-1.8.0.tar.gz</code></pre><ul><li>解压文件</li></ul><pre class=" language-shell"><code class="language-shell">tar -zxvf nginx-1.8.0.tar.gz</code></pre><ul><li>进入解压目录进行编译（nginx的全路径）</li></ul><pre class=" language-shell"><code class="language-shell">./configure --prefix=/usr/lixs/nginx/nginx-1.8.0</code></pre><pre class=" language-shell"><code class="language-shell">make</code></pre><pre class=" language-shell"><code class="language-shell">make install</code></pre><ul><li>上述操作完毕之后，会在nginx-1.8.0的目录下出现<strong>sbin</strong>和<strong>logs</strong>文件夹（如果没有logs文件夹，则需要手动创建，并创建<strong>error.log</strong>和<strong>access.log</strong>文件）。</li></ul><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570387898.png" alt="1567570387898"></p><ul><li>启动nginx，进入sbin目录，内部有一个<strong>nginx</strong>文件，执行命令<pre class=" language-shell"><code class="language-shell">./nginx</code></pre></li></ul><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570525335.png" alt="1567570525335"></p><ul><li>查看nginx进程，是否已经成功启动</li></ul><pre class=" language-shell"><code class="language-shell">ps aux|grep nginx</code></pre><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570599157.png" alt="1567570599157"></p><h3 id="2-1-查看结果"><a href="#2-1-查看结果" class="headerlink" title="2.1 查看结果"></a>2.1 查看结果</h3><ul><li>浏览器输入ip地址便可以直接访问nginx页面。<br><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567570840754.png" alt="1567570840754"><h3 id="2-2-安装验证"><a href="#2-2-安装验证" class="headerlink" title="2.2 安装验证"></a>2.2 安装验证</h3></li><li>验证配置文件，可以检查nginx.conf配置文件其格式、语法是否正确，如果存在配置文件错误，则会出现相应提示，成功也会提示</li></ul><pre class=" language-shell"><code class="language-shell">./nginx -t</code></pre><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/1567578852819.png" alt="1567578852819"></p><ul><li>重加载/重启nginx，以新的nginx.conf配置文件启动</li></ul><pre class=" language-shell"><code class="language-shell">./nginx -s reload</code></pre><ul><li>停止nginx</li></ul><pre class=" language-shell"><code class="language-shell">./nginx -s stop</code></pre><ul><li><p>补充几种命令</p><pre class=" language-shell"><code class="language-shell"># 默认启动方式./sbin/nginx#指定配置文件启动./sbin/nginx -c /tmp/nginx.conf#指定nginx程序目录启动./sbin/nginx -p /usr/local/nginx/#快速停止./sbin/nginx -s stop#优雅停止./sbin/nginx -s quit#热装载配置文件，不用停止可以刷新配置./sbin/nginx -s reload#重新打开日志文件./sbin/nginx -s reopen#检测当前使用的是哪个配置文件，配置是否正确./sbin/nginx -t</code></pre></li><li><p>Nginx 默认使用的是80端口</p></li></ul><h3 id="2-3-重要配置项"><a href="#2-3-重要配置项" class="headerlink" title="2.3 重要配置项"></a>2.3 重要配置项</h3><p>  以下是针对于Nginx安装目录下的conf文件夹下的<strong>nginx.conf</strong>配置文件的解析。</p><pre class=" language-shell"><code class="language-shell">#================================以下是全局配置项#指定运行nginx的用户和用户组，默认情况下该选项关闭（关闭的情况就是nobody）#user  nobody nobody;     #运行nginx的进程数量，最优值取决于多种因素，CPU核数，硬盘驱动，一般设置为CPU的核数worker_processes  1;      #nginx运行错误的日志存放位置。第二个参数决定了日记的级别，可选的值有 debug, info, notice, warn, error, crit, alert 或者 emerg#error_log  logs/error.log;    #error_log  logs/error.log  notice;#error_log  logs/error.log  info;#指定主进程id文件的存放位置，虽然worker_processes != 1的情况下，会有很多进程，管理进程只有一个#pid        logs/nginx.pid;    #这是工作者进程的最大文件打开数目worker_rlimit_nofile 1024;events {    #设置每个工作进程能够同时打开的最大连接数。需要注意的是：这个连接数是指所有的连接数（包括与代理服务器的连接数，还有其它的连接数），还有一点就是，最大连接数（worker_connections）的值不能超过当前工作者进程能够打开的最大文件数目（worker_rlimit_nofile）的限制    worker_connections  1024;       #连接规则，指定工作者进程的方法，一般不需要设置，nginx会选取最高效的方法，可以采用[kqueue rtsig epoll select poll eventport ]，    use   epoll;    }#================================以上是全局配置项http {    #=================================================以下是 http 协议主配置    #安装nginx后，在conf目录下除了nginx.conf主配置文件以外，有很多模板配置文件，这里就是将其它的文件包含到配置文件中    include       mime.types;    #HTTP核心模块指令，这里设定默认类型为二进制流，也就是当文件类型未定义时使用这种方式    default_type  application/octet-stream;         #日志格式    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                         '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    #日志文件存放的位置    #access_log  logs/access.log  main;             #启用或者禁用 sendfile()    sendfile        on;    #当sendfile启用时，该指令才会生效。它的作用是启用或者关闭在 freeDSB 中使用 TCP_NOPUSH socket 选项，或者在 linux 中使用 TCP_CORK socket 选项    tcp_nopush      on;    #启用或者禁用 TCP_NODELAY 选项，只有当一个连接是 keep-alive 状态时，该指令才会生效    tcp_nodelay     on;    #指定一个连接的等待时间（单位秒），如果超过等待时间，连接就会断掉。注意一定要设置，否则高并发情况下会产生性能问题。    keepalive_timeout  65;                          #开启数据压缩，后文详细介绍    gzip  on;                                       #=================================================以上是 http 协议主配置     #================================以下是Nginx后端服务配置项，upstream用来定义一组服务，里面的服务可以监听不同的端口。另外，服务也可以将 TCP 和 UNIX-domain sockets 进行混合使用。    upstream backendserver1 {        #nginx向后端服务器分配请求任务的方式，默认为轮询；如果指定了ip_hash，就是hash算法（上文介绍的算法内容）        #ip_hash            #后端服务器 ip:port ，如果有多个服务节点，这里就配置多个        server 192.168.220.131:8080;         server 192.168.220.132:8080;            #backup表示，这个是一个备份节点，只有当所有节点失效后，nginx才会往这个节点分配请求任务        #server 192.168.220.133:8080 backup;                #weight，固定权重，还记得我们上文提到的加权轮询方式吧。        #server 192.168.220.134:8080 weight=100;        }    #================================以上是Nginx后端服务配置项    #=================================================以下是一个服务实例的配置    server {        #用来设置虚拟主机要监听的端口        listen       80;        #设置虚拟主机的域名，多个域名使用空格隔开        #server_name         server_name  localhost;         # 指定特定的字符集到响应头部的 “Content-Type” 首部        charset utf-8;          #access_log 设置访问日记的路径及格式。        #access_log  logs/host.access.log  main;            #location将按照规则分流满足条件的URL。"location /"您可以理解为“默认分流位置”。        location / {            #root目录，这个html表示nginx主安装目录下的“html”目录。            root   html;               #目录中的默认展示页面            index  index.html index.htm;                }        #location支持正则表达式，“~” 表示匹配正则表达式。        location ~ ^/business/ {               #方向代理。后文详细讲解。            proxy_pass http://backendserver1;           }        #redirect server error pages to the static page /50x.html        #error_page  404              /404.html;        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }    #=================================================以上是一个服务实例的配置}从整体结构来看配置文件结构时这样子的，总共包括七大块。# main 1.全局配置    ...# 2.可以配置nginx的工作模式、工作者进程数    events {    ...}# 3.http的相关配置http {    ...    # 4.负载均衡配置块     upstream myproject{        ...    }    # 5.虚拟主机配置块    server {        ...        # 6.RUI 匹配块        location / {            ...            # 7.条件判断块            if(test_condition){                ...            }        }    }    server {        ...        location / {            ...            if(test_condition){                ...            }        }    }}</code></pre><p><strong>扩展信息：</strong></p><ul><li><p><strong>upstream块</strong></p><p>​    在Http Upstream模块中，可以设置后端服务器的socket信息，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用状态如下：</p><ul><li>down 表示当前server暂不参与负载均衡</li><li>backup 预留的备份机器</li><li>max_fails 允许请求失败的次数，默认为1，当超过最大次数时，返回proxy_next_stream模块定义的错误</li><li>fail_timeout 在经历max_fails次失败后，暂停服务的时间，可以和max_fails 一起使用。</li></ul><p>​     <strong>Nginx支持四种负载均衡的方法</strong>：</p><ul><li><p>Round-robin 根据权重的轮询方式，默认使用该方法</p><pre class=" language-shell"><code class="language-shell">upstream backend{    server backend1.example.com weight=3;    server backend2.example.com;}</code></pre></li><li><p>least_conn 具有最少活跃连接数的服务器将会被发送请求</p><pre class=" language-shell"><code class="language-shell">upsream backend{    least_conn;    server backend1.example.com;    server backend2.example.com;}</code></pre></li><li><p>ip_hash 根据客户端的ip地址来决定请求发送给哪个服务器（hash算法）</p><pre class=" language-shell"><code class="language-shell">upstream backend{    ip_hash;    server backend1.example,com;    server backend2.example.com;}</code></pre></li><li><p>hash 根据用户自定义的hash值来决定请求发送到哪个服务器</p><pre class=" language-shell"><code class="language-shell">upstream backend{    hash $request_uri consistent    server backend1.example.com;    server backend2.example.com;}</code></pre></li></ul></li><li><p><strong>location块</strong> </p><ul><li><p>一个location可以匹配字符串前缀，也可以匹配正则表达式。</p></li><li><p>正则表达式会以“<del>*”（大小写不敏感）开始，或以“</del>”（大小写敏感）开始。</p></li><li><p>解析url之后，会按照配置文件的顺序依次查找适配，一旦查到立马使用相关配置，并停止查找。</p></li><li><p>如果没有找到与之对应的正则表达式，那么之前匹配的前缀字符串location里面的配置将会被采用。</p></li><li><p>使用“=”可以进行精确匹配。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>把 URI 作为字符串，以便于参数中 uri 做完全匹配</td></tr><tr><td>~</td><td>匹配URL时大小写敏感</td></tr><tr><td>~*</td><td>匹配URL时忽略字母大小写</td></tr><tr><td>^~</td><td>匹配URI时只需要前半部分与URI参数匹配</td></tr><tr><td>@</td><td>仅用于Nginx服务内部请求之间的重定向</td></tr></tbody></table><pre><code>location ~*\.(gif|jpg|jpeg)${    # 匹配以.gif .jpg .jpeg结尾的请求}</code></pre><p>如果请求可以匹配多个location，只会被第一个location处理。</p></li><li><p><strong>文件路径</strong></p><ul><li><p>root 表示页面所载目录</p><pre class=" language-shell"><code class="language-shell">server{    listen 80;    server_name localhost    location / {        root html        index index.html index.htm;    }}# 访问localhost:80 端口  会跳转到html目录下的index.html页面改造如下</code></pre></li></ul><p>server{</p><pre><code>  listen 8080;server_name www.test.com;  location / {      root html/www/test      index test.html  }</code></pre><p>  }</p></li></ul></li></ul><pre><code>  # 因为添加了域名，所以需要给本机添加一个host，将www.test.com进行映射  # 访问 www.test.com:8080,将会返回html/www/test/test.html页面  #如果不想访问带端口，可将端口设为默认的nginx 80端口server{      listen 8080;    server_name www.test.com;      # root 放在外部时，其他的location都将会继承这个root      root html/www/test      location / {          index test.html      }  }```- 以root 设置资源路径 root path  ```shell  # 如果请求是 /abc/index/test.html 则web服务器将会返回 /data/html/abc/index/test.html  location /abc {      root /data/html  }  # 请求 .js文件都会返回 /data/js 下的文件  location \/js$ {      root /data/js  }```- 以 alias 设置资源路径：alias path  ```shell  # 访问 /abc 会映射到 /data/abc 文件夹  location /abc {      alias /data/abc  }  # 等同于  location /abc {      root /data  }  ```- 首页 index file  ```shell  # 收到请求后，先尝试访问path/index.html 文件，如果可以访问，直接返回文件内容结束请求，否则，再尝试返回 path/index.php  location / {      root path;      index /index.html /index.php  }  ```- 根据HTTP返回码重定向  ```shell  error_page 404 /404.html  error_page 502 503 504 /50x.html  error_page 403 http://example.com/forbidden.html  ```  通过 = 更改返回的错误码：  ```shell  error_page 404=200 /empty.gif  ```</code></pre><ul><li><p><strong>反向代理服务器</strong></p><ul><li><p><strong>proxy_pass</strong></p><p>该配置将当前请求反向代理到URL参数指定的服务器上，URL可以是主机名或IP地址。</p><pre class=" language-shell"><code class="language-shell"># 访问 /abc 会转发到 http://127.0.0.1:8080/index.htmllocation /abc {    proxy_pass http://127.0.0.1:8080/index.html}</code></pre></li></ul></li><li><p>动静分离（资源服务器）</p><ol><li><p>nginx目录下创建static文件夹，并上传图片test.jpg进去</p><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/image-20210317164524267.png" alt="image-20210317164524267"></p></li><li><p>在 修改nginx默认页面，/nginx/html/index.html , 引用该图片</p><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/image-20210317164731492.png" alt="image-20210317164731492"></p><p>备注： 图片的路径为 /nginx/static/test.jpg,   html的路径为 /nginx/html/index.html ， 这里使用 <img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/test.jpg">的原因是，nginx 读取的默认是 root根目录，所以读取图片时也是从nginx的根目录角度去读取的。</p></li></ol></li></ul><pre><code>   如果图片的路径是/nginx/static/aa/bb/cc/test.jpg, 则需要在nginx.conf 中配置如下：   ```shell   location /static {           alias static/aa/bb/cc   }   # nginx 会自动将static 替换为static/aa/bb/cc 读取 static/aa/bb/cc/test.jpg   ```   如果图片路径为/nginx/static/aa/bb/cc/image/test.jpg|png|gif, 则直接可以通过网址：81.68.118.170（服务器域名或IP）：80(监听端口)/image/test.jpg|png|gif拿到对应的图片（网页中可以设为&lt;img src="image/test.jpg"&gt;），但前提是设置正则表达式如下   ```shell   location ~*\.(jpg|png|gif|css|js)$ {           root static/aa/bb/cc   }   ```</code></pre><ul><li><p>防盗链</p><ul><li>nginx模块ngx_http_referer_module通常用于阻挡来源非法的域名请求</li></ul><pre class=" language-sh"><code class="language-sh">location ~*\.(jpg|png|gif|css|js)$ {        root static/aa/bb/cc        # valid_referes 是指白名单        # none 表示不存在的Referer头（表示空的，也就是直接访问，在浏览器中打开一个图片）        # blocked 意为根据防火墙伪装Referer头        # 81.68.118.170 表示只有该来源才能访问当前站点的图片，如果不是，if判断为false,将会返回404 或者跳转页面或图片等。        #多个白名单用,隔开，0.5.33以后可以在名称中使用*通配符        valid_referes none blocked 81.68.118.170        if($invalid_referer){                #rewrite ^/ http://www.baidu.com                return 404        }}</code></pre></li><li><p>黑白名单配置</p><ul><li><p>黑名单</p><ol><li>在安装目录的配置文件目录下新建黑名单black.ip，内容为下：</li></ol><pre><code>deny 10.88.80.190</code></pre><ol start="2"><li>修改nginx配置文件</li></ol><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/image-20210318143651366.png" alt="image-20210318143651366"></p><p>​        放到http里作为总的黑名单，放在server中为单独的server黑名单</p></li><li><p>白名单</p><ol><li><p>注释掉配置文件的黑名单配置</p></li><li><p>建立文件white.ip,配置一个IP 数量设置为 1 </p><pre class=" language-shell"><code class="language-shell">10.88.80.190 1;</code></pre></li><li><p>修改nginx.conf 文件</p></li><li><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/webp" alt="img"></p><p>geo 为引入白名单，设置白名单之外的默认值都是0</p><p>location做了判断，只要是0的就不在白名单之列，一律返回403.</p></li></ol></li></ul></li><li><p>网络限速</p><p>​        <img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/image-20210318145402715.png" alt="image-20210318145402715"></p><p>limit_rate_after 表示小于2k的部分不限速，大于的部分进行限速</p><p>limit_rate 表示如果限速，限速的速度为1k</p></li><li><p>日志配置</p><p>​    日志配置的两个属性：</p><ul><li><p>log_format  设置日志格式</p></li><li><p>access_log 定义日志级别和位置</p><p>默认配置如下：</p><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/image-20210318150759953.png" alt="image-20210318150759953"></p></li><li><p>日志常用变量解释</p><pre class=" language-shell"><code class="language-shell">$remote_addr,$http_x_forwarded_for #记录客户端IP地址$remote_user #记录客户端名称$request #记录请求的URL和HTTP协议(GET,POST,DEL,等)$status #记录请求状态$body_bytes_sent #发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。$bytes_sent #发送给客户端的总字节数。$connection #连接的序列号。$connection_requests #当前通过一个连接获得的请求数量。$msec #日志写入时间。单位为秒，精度是毫秒。$pipe #如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。$http_referer #记录从哪个页面链接访问过来的$http_user_agent #记录客户端浏览器相关信息$request_length #请求的长度（包括请求行，请求头和请求正文）。$request_time #请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。$time_iso8601 #ISO8601标准格式下的本地时间。$time_local #通用日志格式下的本地时间。</code></pre><p>打印日志记录IP地址、远程用户、时间和访问地址</p><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/image-20210318152540787.png" alt="image-20210318152540787"></p><p>日志结果：</p><p><img src="/2019/02/08/nginx-an-zhuang-yu-pei-zhi-wen-jian-xiang-jie/image-20210318152505894.png" alt="image-20210318152505894"></p></li><li><p>配置文件可根据网址命名，但要给nginx.conf配置 user root;</p><pre><code>access_log logs/$host.access.log main;</code></pre></li><li><p>要查看nginx错误，需要设置error日志，并设置为debug日志：</p><pre><code>error_log logs/error.log debug</code></pre></li><li><p>平时error日志量大，可针对指定客户端进行debug日志输出</p><pre><code>events{    debug_connection 192.168.0.1;    debug_connection 192.168.0.2;}</code></pre></li></ul></li></ul><h3 id="2-4-常用命令"><a href="#2-4-常用命令" class="headerlink" title="2.4 常用命令"></a>2.4 常用命令</h3><pre class=" language-shell"><code class="language-shell">nginx -s reload #使运行中的Nginx重加载配置并生效nginx -s stop #停止服务nginx -s quit #处理完当前所有请求再停止服务nginx -t # 检查配置信息是否有错误nginx -c new_nginx.conf #使用自定义配置文件</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://blog.csdn.net/qq_39591494/article/details/78857677" target="_blank" rel="noopener">https://blog.csdn.net/qq_39591494/article/details/78857677</a></li><li><a href="https://www.cnblogs.com/jiangxiaobo/p/10266308.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangxiaobo/p/10266308.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/56587724" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56587724</a></li><li><a href="https://blog.51cto.com/2475296/2313297" target="_blank" rel="noopener">https://blog.51cto.com/2475296/2313297</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka：深入原理</title>
      <link href="/2019/02/08/kafka-shen-ru-yuan-li/"/>
      <url>/2019/02/08/kafka-shen-ru-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​            Kafka的应用场景一般是<strong>大数据领域的实时计算、日志采集等</strong>，是业内标准。其设计的首要目标是解决网站中海量用户的操作行为记录、页面浏览记录，后被捐献给apche。以“满足搞数据吞吐量”为首要目标，因而在其他方面做出了一定的牺牲，比如：消息的事务性。</p><p>​        常用于收集操作日志，对于消息的可靠性没有太多要求。</p><h3 id="2-原理结构"><a href="#2-原理结构" class="headerlink" title="2.原理结构"></a>2.原理结构</h3><p>​        完整的Kafka解决方案包括四个要素：</p><ul><li><p>Producer（消息生产者）</p></li><li><p>Server Broker（服务代理器）</p></li><li><p>Zookeeper（协调者）</p></li><li><p>Consumer（消息消费者）</p><p><strong>Kafka在设计之初就被认为是集群化工作的</strong></p></li></ul><h4 id="2-1-Kafka-Broker-工作结构"><a href="#2-1-Kafka-Broker-工作结构" class="headerlink" title="2.1 Kafka Broker 工作结构"></a>2.1 Kafka Broker 工作结构</h4><p>​        <img src="/2019/02/08/kafka-shen-ru-yuan-li/1573789480(1).jpg" alt=""></p><ul><li>一个独立进行消息获取，消息记录和消息分送操作的队列称为topic，和ActiveMQ中的queue和topic属于同一概念</li><li>将Topic拆分分区，这些分区可能在同一个Broker上也可能在多个Broker上。</li><li>producer的消息会被分到各分区存储，一条消息只会被分到一个分区进行存储，并且这些消息以分区为单位，保持顺序排列。   这样的好处在于，消息派送到多个broker的多个分区上，充分调动计算资源</li><li>每一个分区还会有一个段结构或多个段结构<ul><li>.index后缀的索引文件：记录消息在整个topic中的序号以及在log中的偏移单位</li><li>.log后缀的数据文件：这条消息的真实内容</li></ul></li><li>对索引文件始终保证顺序读取</li><li>kafka对Linux操作系统下Page Cache技术的应用，才是其高性能的最大保证</li></ul><h4 id="2-2-Kafka-Cluster结构"><a href="#2-2-Kafka-Cluster结构" class="headerlink" title="2.2 Kafka Cluster结构"></a>2.2 Kafka Cluster结构</h4><p><strong>消息在kafka集群中的流动：</strong></p><p> <img src="/2019/02/08/kafka-shen-ru-yuan-li/cluster.jpg" alt=""></p><ul><li>消息生产者会决定发送的消息将会送入Topic的哪一个分区</li><li>在同一个Topic下，kafka会为不同的消费者组创建独立的index索引定位，生产者发送有个消息，topic下不同组的消费者都会收到消息。</li><li>同一个组下的消费者可以消费一个或多个分区中的消息，但是一个分区的消息只能被同一组下的某一个消费者所消费。</li><li>消费者会通过zookeeper协调集群获取当前消费组中其他消费者的连接状态，并得到当前topic下可用于消费的分区和该消费组中其他消费者的对应关系，若发现分区都已一一对应，则将自己挂起，以便接替后面的失效者</li><li>消费者发现存在一个消费者关联多个分区，并且处于繁忙不能全部处理时，会接替它处理一个或多个分区的消息，并且一直和这个分区保持关联</li><li>kafka集群只保证同一个分区下消息队列中的消息顺序</li><li>topic下分区的消息不是broker进行推送的，而是消费者主动拉取的。</li></ul><h4 id="2-3-复制功能"><a href="#2-3-复制功能" class="headerlink" title="2.3 复制功能"></a>2.3 复制功能</h4><ul><li>kafka让topic下的每一个分区复制到多个broker服务节点上，由zookeeper进行管理，目的是当leader挂掉之后，follower会成为leader。</li><li>两个概念区分：<ul><li>分区：若干消息按照一定的规则分别存放在不同的区域，一条消息只存入一个区域（<strong>且Topic下的多个分区可以存在同一个Broker上</strong>）</li><li>复制：为保证消息在被消费之前不丢失，需要将某一个区域中的消息集合复制出多个副本（<strong>同一个分区的多个副本不能存放在同一个Broker上</strong>）</li></ul></li><li><strong>只有当ISR中所有分区副本全部完成了某一条消息的同步过程，这条消息才算完成了真正的“记录”操作</strong>。</li></ul><h4 id="2-4-生产者"><a href="#2-4-生产者" class="headerlink" title="2.4 生产者"></a>2.4 生产者</h4><ul><li>生产者直接和Broker进行连接，并没有连接zookeeper进行协调，生产者唯一知道的就是Topic有多少个分区，以及每个分区存在于哪些Broker上，都是直接对一个Broker的轮询</li><li>生产者可以决定指向Topic的哪一个分区发送消息，而不是由Broker来决定</li><li>生产者可以决定对消息的一致性的关注的级别，或者又可以完全不关心</li><li>可以决定是异步，还是同步发送消息，如果是异步，还可以决定发送的周期</li><li>随机选取节点，读取当前Topic的分区和复制表信息，并保存到本地的Pool中</li><li>没有像ActiveMQ中那样的事务机制</li><li><strong>生产者指定分区</strong><ul><li>第一种，在创建消息对象KeyedMessage时，指定方法中partkey/key的值。</li><li>第二种：重新实现kafka.producer.Patitioner接口</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMQP：协议学习</title>
      <link href="/2019/02/06/amqp-xie-yi-xue-xi/"/>
      <url>/2019/02/06/amqp-xie-yi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  AMQP协议的全称是：Advanced Message Queuing Protocol（高级消息队列协议）。目前AMQP协议的版本为 Version 1.0，是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><h1 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2. 协议结构"></a>2. 协议结构</h1><p>  AMQP协议结构如下：</p><p><img src="/2019/02/06/amqp-xie-yi-xue-xi/AMQP1.PNG" alt=""></p><ul><li>由上图可以看出，AMQP结构的构成分为六块<ul><li><strong>Message</strong>：消息体</li><li><strong>Producer</strong>：生产者</li><li><strong>Consumer</strong>：消费者</li><li><strong>Virtual Host</strong>：虚拟节点</li><li><strong>Exchange</strong>：交换机</li><li><strong>Queue</strong>：队列<ul><li>AMQP的客户端由<strong>Producer</strong>和<strong>Consumer</strong>组成，服务端Broker则是由Virtual Host，Exchange和Queue组成。</li></ul></li></ul></li><li><strong>Message</strong>的传递需要客户端（Producer和Consumer）创建连接到Broker的连接Connection，之后由客户端在Connection之上建立channel通道连接到Virtual host或者Queue上。Connection支持多个Channel的建立，消息的发送与接受只有在channel上才能进行。</li><li><strong>Exchange</strong>作为协议中的交换机，可以和多个Queue以及Exchange进行绑定，消息会根据Exchange上的路由规则进行发送传播。Exchange要至少和一个Queue或者Exchange绑定关系，并且设置好Queue和Exchange的Routing（路由规则），Exchange根据路由规则发送消息到符合路由规则的Queue或Exchange中，路由规则可以和Message中的Routing key属性配合使用。Exchange的路由规则包含三种：<strong>Direct、Fanout、Topic</strong></li><li><strong>Queue</strong>对于消息的处理，没有channel连接到Queue时，消息将会被存储，知道channel被创建，如果channel已经创建，消息按顺序发送给channel</li><li><strong>Consumer</strong>在收到消息后，需要手动（可以设置自动发送和无需发送）发送一条ACK回应消息给对应的Queue，Queue接收到后，会将该消息移除掉，在channel断开之前Queue若未能收到消息，则该消息会被发送给其他的channel。发送NACK，消息会发送给其他channel，不论当前channel是否已经断开。<h1 id="3-消息格式"><a href="#3-消息格式" class="headerlink" title="3.消息格式"></a>3.消息格式</h1>  作为一种网络通讯协议，AMQP工作在七层/五层网路模型的应用层。其消息真正的内容主要在PAYLOAD区域，即交付区，非PAYLOAD区，在网络协议的应用层说明Channel的工作状态。<br>PAULOAD区域共七个数据区域：<table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>header</td><td>记录AMQP消息在“支持AMQP的中间件”中的交互状态，如消息在节点间被交互的总次数，优先级，TTL值等信息</td></tr><tr><td>delivery-annotations</td><td>在header部分只能传递规范的、标准的、经过ISO/IEC组织定义过的属性。所以对应这里用来记录“非标”的header信息</td></tr><tr><td>message-annotations</td><td>用于存储一些自定义的辅助属性，主要用于消息的转换</td></tr><tr><td>properties</td><td>AMQP消息的正文内容是从properties到application-data部分，properties记录了消息正文中标准的，规范的属性，例如消息ID，分组ID,发送者ID等</td></tr><tr><td>application-properties</td><td>主要记录和应用有关的数据，该协议的实现产品需要用这部分数据决定其处理逻辑，例如消息的Routing是什么，是否进行持久化等</td></tr><tr><td>application-data</td><td>使用二进制格式描述的AMQP消息的用户部分内容，即发送的真实内容</td></tr><tr><td>footer</td><td>一般用来存储辅助内容，如消息的哈希值，HMAC，签名或加密细节</td></tr></tbody></table></li></ul><h1 id="3-Exchange路由规则"><a href="#3-Exchange路由规则" class="headerlink" title="3. Exchange路由规则"></a>3. Exchange路由规则</h1><table><thead><tr><th>规则命称</th><th>区别</th></tr></thead><tbody><tr><td>Direct路由</td><td>该模式下Exchange将使用消息中所携带的Routing key 和Queue中的Routing key进行比较，如果匹配，该消息进入该队列</td></tr><tr><td>Fanout</td><td>Exchange接受消息后，会将消息赋值多份，发送到自己绑定的Exchange和Queue中，不需要Routing key</td></tr><tr><td>Topic路由</td><td>Exchange将支持‘#’和’*‘通配符进行Routing key的匹配查找</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> AMQP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stomp：协议学习</title>
      <link href="/2019/02/03/stomp-xie-yi-xue-xi/"/>
      <url>/2019/02/03/stomp-xie-yi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  消息从发送到接受的方式有两种：一种称为<strong>即时消息通讯</strong>，即一端发送之后，另一端能够立即接受 ，具体实现就是RPC。另一种称为<strong>延迟消息通讯</strong>，即消息发出后，进入中间容器进行存储，到达一定条件之后，再发送给接受者，中间的容器称为<strong>消息队列</strong>。<br>  <strong>Stomp协议</strong>，英文全名<strong><em>Streaming Text Orientated Message Protocol</em></strong>，中文名称为 ‘流文本定向消息协议’。是一种以纯文本为载体的协议，前身是TTMP协议，专为消息中间件设计。<br>  <strong>Stomp协议属于延迟消息通讯</strong><br>  目前的版本为V1.1和V1.2</p><h3 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2.协议结构"></a>2.协议结构</h3><p>  标准的协议包括：<strong>命令/关键信息，头信息，文本内容</strong></p><pre><code>CONNECT    //命令accept-version:1.2  //版本号（头信息）param1:value1param2:value2this is stomp    //文本内容</code></pre><p>  Stomp协议由两个角色组成：<strong>客户端(Client)</strong>和<strong>消息代理(Broker)</strong></p><p><img src="/2019/02/03/stomp-xie-yi-xue-xi/1566985233886.png" alt="1566985233886"></p><p>  <strong>消息代理（Broker）</strong>只负责接受和存储客户端发送的消息，依据客户端要求的路径进行转发，对消息内容不做任何处理，只负责客户端连接和订阅</p><h3 id="3-交互流程及命令"><a href="#3-交互流程及命令" class="headerlink" title="3. 交互流程及命令"></a>3. 交互流程及命令</h3><p>   交互流程大致如下图：<br><img src="/2019/02/03/stomp-xie-yi-xue-xi/1566986429790.png" alt="1566986429790"></p><ul><li><strong>CONNECT/STOMP</strong>：客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</li><li><strong>CONNECTED</strong>：代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</li><li><strong>SEND</strong>：客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</li><li><strong>BEGIN</strong>：Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</li><li><strong>COMMIT</strong>：提交事务。使得事务中的一条或多条消息进入Stomp代理队列</li><li><strong>ABORT</strong>：取消/终止当前还未COMMIT的事务。</li><li><strong>SUBSCRIBE</strong>：订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</li><li><strong>UNSUBSCRIBE</strong>：取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</li><li><strong>ACK</strong>：若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</li><li><strong>NACK</strong>：若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</li><li><strong>DISCONNECT</strong>：断开客户端和消息代理之间的连接</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong>CONNECT/STOMP</strong></td><td>客户端通过CONNECT命令连接到代理端，使用STOMP，必须版本是1.2</td></tr><tr><td><strong>CONNECTED</strong></td><td>代理接受客户端连接请求并成功处理，返回CONNECTED状态信息，失败返回ERROR信息</td></tr><tr><td><strong>SEND</strong></td><td>客户端向代理端的一个虚拟路径发送内容，其他订阅该虚拟路径的额客户端将受到该信息。</td></tr><tr><td><strong>BEGIN</strong></td><td>Stomp支持事务模式，开启事务模式后，send内容将不会发送给代理，直到执行COMMIT命令。</td></tr><tr><td><strong>COMMIT</strong></td><td>提交事务。使得事务中的一条或多条消息进入Stomp代理队列</td></tr><tr><td><strong>ABORT</strong></td><td>取消/终止当前还未COMMIT的事务</td></tr><tr><td><strong>SUBSCRIBE</strong></td><td>订阅命令，向消息代理订阅某一指定虚拟路径的监听，ACK 属性表明客户端接受到消息后，是否需要进行回应。ACK的值只有三种：auto（默认）、client和client-individual</td></tr><tr><td><strong>UNSUBSCRIBE</strong></td><td>取消订阅，即取消对某个虚拟路径的监听，若本身未订阅，此命令无效</td></tr><tr><td><strong>ACK</strong></td><td>若SUBSCRIBE时，ACK选择client，则客户端接受消息后要进行回应，若断开连接前未回应，代理会将消息发送给其他客户端</td></tr><tr><td><strong>NACK</strong></td><td>若SUBSCRIBE时，ACK选择client，客户端回应NACK，表明消息处理失败，代理不管该客户端是否断开连接，都会将消息发送给其他客户端</td></tr><tr><td><strong>DISCONNECT</strong></td><td>断开客户端和消息代理之间的连接</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> Stomp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ：安装</title>
      <link href="/2019/01/27/activemq-an-zhuang/"/>
      <url>/2019/01/27/activemq-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   ActiveMQ安装较为简单, 下载的官网：<a href="https://activemq.apache.org/download-archives.html" target="_blank" rel="noopener">ActiveMQ</a></p><h1 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h1><ul><li>解压包</li></ul><pre class=" language-shell"><code class="language-shell">tar -zxvf apache-activemq-5.13.2-bin.tar.gz  </code></pre><ul><li>配置环境变量</li></ul><pre class=" language-shell"><code class="language-shell">vim /etc/profile</code></pre><p>添加内容如下：</p><pre class=" language-shell"><code class="language-shell">############activemq############export PATH=/usr/lixs/activemq/apache-activemq-5.13.2/bin/linux-x86-64:$PATH</code></pre><ul><li>启动程序</li></ul><pre class=" language-shell"><code class="language-shell">activemq start</code></pre><ul><li>访问页面 ip + 8161</li></ul><p><img src="/2019/01/27/activemq-an-zhuang/1567665904552.png" alt="1567665904552"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 消息中间件 </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ：存储方案</title>
      <link href="/2019/01/20/activemq-cun-chu-fang-an/"/>
      <url>/2019/01/20/activemq-cun-chu-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  上文已经学习了ActiveMQ的存储分为两种：持久化和非持久化，其中持久化的介质可以是<strong>磁盘文件系统</strong>，也可以是其<strong>内置数据库</strong>，或者外部的<strong>关系型数据库</strong>。</p><h1 id="2-持久化存储"><a href="#2-持久化存储" class="headerlink" title="2.持久化存储"></a>2.持久化存储</h1><ul><li>发布订阅模式下，没有订阅者时，消息也要进行先存储再标记，但不一定进入物理磁盘。</li><li>事务没有提交的情况下，消息依旧会被服务端持久化，但没有进入到具体的队列之中。</li><li>服务端持久化消息的行为，可以设置为异步，持久化完成会告知服务端。</li><li>持久化数据的删除，只有在消息被通知已经被消费时，才会被移除。<h2 id="2-1-配置介绍"><a href="#2-1-配置介绍" class="headerlink" title="2.1 配置介绍"></a>2.1 配置介绍</h2>  ActiveMQ每一个服务节点都是一个独立的进程。</li></ul><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td>systemUsage</td><td>表示进程级别的容量设置</td></tr><tr><td>memoryUsage</td><td>子标记设置节点的“可用内存限制”，内存容量供所有队列使用</td></tr><tr><td>storeUsage</td><td>标记节点的用于存储“持久化消息”的“可用磁盘空间”，采用数据库存储方案，该参数无作用</td></tr><tr><td>tempUsage</td><td>设置“temp store”的可用磁盘空间限制</td></tr></tbody></table><h1 id="3-存储方案"><a href="#3-存储方案" class="headerlink" title="3.存储方案"></a>3.存储方案</h1><h2 id="3-1-KahaDB"><a href="#3-1-KahaDB" class="headerlink" title="3.1 KahaDB"></a>3.1 KahaDB</h2><h3 id="3-1-1-基本结构"><a href="#3-1-1-基本结构" class="headerlink" title="3.1.1 基本结构"></a>3.1.1 基本结构</h3><p>emsp;emsp;KahaDB基于文件系统，支持事务，是目前ActiveMQ默认的持久化存储方案。<br>基本元素：</p><ul><li><p>Metadata Cache：用于在内存中检索消息的存储位置</p></li><li><p>Data log：记录消息内容，默认大小为32M，当其内部所有消息被成功消费后，该文件会在Metadata Cache中被标记为删除，在下一个checkpoint周期进行删除操作。Data log文件采用顺序写的方式操作，为保证物理上的连接，文件需要进行区域预占。</p></li><li><p>Metadata Store：在磁盘上检索消息存储位置。内存中没有被处理的消息索引会以一定周期，同步到Metadata Store中。</p></li><li><p>redo文件：用于系统异常关闭后恢复Btree结构</p><h3 id="3-1-2-配置KahaDB"><a href="#3-1-2-配置KahaDB" class="headerlink" title="3.1.2 配置KahaDB"></a>3.1.2 配置KahaDB</h3><p>  ActiveMQ会默认启动KahaDB。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>broker</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://activemq.apache.org/schema/core<span class="token punctuation">"</span></span>  <span class="token attr-name">brokerName</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span> <span class="token attr-name">dataDirectory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${activemq.data}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  ......  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>persistenceAdapter</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>kahaDB</span> <span class="token attr-name">directory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${activemq.data}/kahadb<span class="token punctuation">"</span></span> <span class="token attr-name">journalMaxFileLength</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>64mb<span class="token punctuation">"</span></span> <span class="token attr-name">indexWriteBatchSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>persistenceAdapter</span><span class="token punctuation">></span></span>  ......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>broker</span><span class="token punctuation">></span></span></code></pre></li><li><p>journalMaxFileLength：表示设置后的信息文件大小</p></li><li><p>indexWriteBatchSize：表示Metadata Cache 和 Metadata Store进行checkpoint同步的上限</p></li></ul><h2 id="3-2-LevelDB"><a href="#3-2-LevelDB" class="headerlink" title="3.2 LevelDB"></a>3.2 LevelDB</h2><h3 id="3-2-1-基本结构"><a href="#3-2-1-基本结构" class="headerlink" title="3.2.1 基本结构"></a>3.2.1 基本结构</h3><p>  核心的设计算法是<strong>跳跃表</strong>，核心操作策略是对磁盘上的数据日志结构进行归并（LSM）。</p><p>  结构元素如下：</p><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td>Log 文件</td><td>新的消息进入时，直接写log文件目的是系统异常时能够进行数据的恢复，采用预占磁盘空间的形式顺序写入，可设置为异步，有丢失数据风险</td></tr><tr><td>MemTable//Immutable</td><td>新的消息进入时，会写入MemTable，内部数据组织结构就是跳跃表。当内部数据大于一定参数值时，会被标记为Immutable，开启一个新的MemTable,Imuutable的“删除”数据会被剔除，其余可能压缩写入到.sst文件中</td></tr><tr><td>SStable</td><td>位于硬盘，后缀为.sst，默认大小为2M,因其按照数据的key排序随机写，固无需预占磁盘空间<br>SSTable文件也分层次，每层为上层的十倍，某曾达到最大值时，选取一个文件做Compact操作<br>读写SSTable的最小单元是Block，大小为4KB，最后的Index Block指明每SSTable一个Data Block的起始位置<br>LevelDB的内存区域，存在Block Cache区域，存储众多的Index Block</td></tr><tr><td>Manifest</td><td>该文件记录sst文件的关键信息，包括：某个.sst文件属于哪一个Level，最小key值是多少，最大key值是多少等</td></tr></tbody></table><h3 id="3-2-2-配置LevelDB"><a href="#3-2-2-配置LevelDB" class="headerlink" title="3.2.2 配置LevelDB"></a>3.2.2 配置LevelDB</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>persistenceAdapter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>levelDB</span> <span class="token attr-name">directory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${activemq.data}/levelDB<span class="token punctuation">"</span></span> <span class="token attr-name">logSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>52428800<span class="token punctuation">"</span></span> <span class="token attr-name">sync</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>persistenceAdapter</span><span class="token punctuation">></span></span></code></pre><ul><li>directory：LevelDB的结构文件所放置的目录位置</li><li>logSize：默认大小为100M，采用预占用磁盘，即一旦消息进入，就会有100MB被预先占用。</li><li>sync：异步写log，异步在内存区域向Memtable写入位置索引。<h2 id="3-3-关系型数据库"><a href="#3-3-关系型数据库" class="headerlink" title="3.3 关系型数据库"></a>3.3 关系型数据库</h2>  ActiveMQ支持使用关系型数据库进行持久化存储–通过JDBC实现数据库的连接。<br>mysql数据库配置如下：</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>broker</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>persistenceAdapter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbcPersistenceAdapter</span> <span class="token attr-name">dataSource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#mysql_datasource<span class="token punctuation">"</span></span> <span class="token attr-name">createTablesOnStartup</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>persistenceAdapter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>broker</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql_datasource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mchange.v2.c3p0.ComboPooledDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/activemqdb?relaxAutoCommit<span class="token punctuation">=</span>true&amp;amp;useUnicode<span class="token punctuation">=</span>true&amp;amp;characterEncoding<span class="token punctuation">=</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>123456<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>minPoolSize<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxPoolSize<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initialPoolSize<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p><strong>备注：</strong>使用关系型数据库，需要将相关jar包放置到安装路径下的./lib目录下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ：基本原理</title>
      <link href="/2019/01/13/activemq-ji-ben-yuan-li/"/>
      <url>/2019/01/13/activemq-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  ActiveMQ是Apache软件基金会的开源产品，支持AMQP协议、MQTT协议、Openwire协议和Stomp协议等多种消息协议,并且支持JMS API接口规范。</p><h1 id="2-基本参数"><a href="#2-基本参数" class="headerlink" title="2. 基本参数"></a>2. 基本参数</h1><table><thead><tr><th>参数名称</th><th>参数介绍</th></tr></thead><tbody><tr><td>stop</td><td>停止当前ActiveMQ节点的运行</td></tr><tr><td>restart</td><td>重启当前的ActiveMQ节点</td></tr><tr><td>status</td><td>仅展示当前节点是处于运行还是停止</td></tr><tr><td>console</td><td>使用控制台启动ActiveMQ节点</td></tr><tr><td>dump</td><td>采用console启动ActiveMQ,使用dump参数，可获取当前线程的快照</td></tr></tbody></table><h1 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3.工作机制"></a>3.工作机制</h1><p>  ActiveMQ有两种不同的模式队列：<strong>Topic订阅-发布模式，Queue负载均衡模式。</strong></p><table><thead><tr><th>比较内容</th><th>Topic</th><th>Queue</th></tr></thead><tbody><tr><td>工作模式</td><td>“订阅-发布”模式，如果有多个订阅者，消息会被复制多份进行发送，若没有订阅者，消息将会被丢弃</td><td>“负载均衡”模式，如果有多个消费者，消息只会发送给其中的一个，并且要求ack进行消息的确认，如果没有消费者，消息将会被保存，直到有消费者连接订阅</td></tr><tr><td>持久化</td><td>不会</td><td>数据默认在MQ服务器上以文件形式进行保存，可以配置为DB存储</td></tr><tr><td>传递完整性</td><td>没有订阅者，消息将被丢弃</td><td>没有订阅者，消息被存储</td></tr><tr><td>效率</td><td>处理性能会伴随订阅者数量的增加而降低，并且也要考虑使用的协议性能差异</td><td>仅有一个消费者进行信息的接受，性能不随消费者数量的变化而影响，但也受协议影响</td></tr><tr><td># 4. 优化</td><td></td><td></td></tr><tr><td>  ActiveMQ的优化可以考虑从多个次层入手，如<strong>代码级性能、规则性能、网络性能和集群方案</strong>。</td><td></td><td></td></tr></tbody></table><h2 id="4-1-网络性能优化"><a href="#4-1-网络性能优化" class="headerlink" title="4.1 网络性能优化"></a>4.1 网络性能优化</h2><p>  ActiveMQ的网络信息传递方式默认是基于网络模型的BIO方式，为提高单点性能，可以为单个节点配置更高效的网络IO模型。<br>  ActiveMQ支持的协议如下：</p><ul><li><strong>AMQP</strong></li><li><strong>MQTT</strong></li><li><strong>OpenWire</strong></li><li><strong>REST</strong></li><li><strong>Stomp</strong></li><li><strong>XMPP</strong></li></ul><p><strong>不同的协议需要设置不同的网络监听端口</strong>，详见./conf/conf/activemq.xml文件。<br><strong>ActiveMQ中默认的消息协议是openwire</strong><br>在5.13.0+版本后，OpenWire，Stomp，AMQP，MQTT四种协议的端口监听进行了合并，使用auto关键字进行表示。ActiveMQ将会监听这一个端口的消息状态，匹配合适的协议格式,优化使得连接管理变的简洁，但没有提升单节点的处理性能。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transportConnectors</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transportConnector</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto<span class="token punctuation">"</span></span> <span class="token attr-name">uri</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto://0.0.0.0:61617?maximumConnections<span class="token punctuation">=</span>1000<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transportConnectors</span><span class="token punctuation">></span></span></code></pre><p>端口默认使用BIO网络IO模型，为提高单节点吞吐量，可以指定网络模型为nio：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transportConnectors</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transportConnector</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nio<span class="token punctuation">"</span></span> <span class="token attr-name">uri</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nio://0.0.0.0:61618?maximumConnections<span class="token punctuation">=</span>1000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transportConnectors</span><span class="token punctuation">></span></span></code></pre><p>让某一端口支持NIO和协议：</p><pre><code>&lt;transportConnector name="stomp+nio" uri="stomp+nio://0.0.0.0:61613?transport.transformer=jms"/&gt;// 表示这个端口使用NIO模型支持Stomp协议</code></pre><p>让某一端口支持NIO网络和多协议：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transportConnector</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto+nio<span class="token punctuation">"</span></span> <span class="token attr-name">uri</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto+nio://0.0.0.0:61608?maximumConnections<span class="token punctuation">=</span>1000<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>每一种协议都有一些特定的参数，各协议也包含共用的参数，具体详见官方文档<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ官网</a></p><h2 id="4-2-处理规则和优化"><a href="#4-2-处理规则和优化" class="headerlink" title="4.2 处理规则和优化"></a>4.2 处理规则和优化</h2><h3 id="4-2-1-JMS规范概念"><a href="#4-2-1-JMS规范概念" class="headerlink" title="4.2.1 JMS规范概念"></a>4.2.1 JMS规范概念</h3><p>   ActiveMQ是JMS规范的完整实现，故其调度与存储等原理与JMS中的概念原理相关。JMS的相关概念如下表：</p><ul><li><p>订阅发布与负载均衡模式<br>详见ActiveMQ的工作机制。</p></li><li><p>持久化消息和非持久化</p><table><thead><tr><th>差异</th><th>持久化（PERSISTENT）</th><th>非持久化（NON_PERSISTENT）</th></tr></thead><tbody><tr><td>存储位置</td><td>不受JMS服务端异常状态的影响，服务端会持久化保存消息，直到被处理</td><td>只存储在JMS服务节点的内存区域</td></tr><tr><td>持久化方案</td><td>KahaDB、AMQ和关系型数据库</td><td>无</td></tr><tr><td>宕机</td><td>数据保存</td><td>数据丢失</td></tr><tr><td>策略</td><td>无</td><td>内存区域不足时，采用辅助方案进行转存（ActiveMQ使用临时存储区域）</td></tr></tbody></table></li><li><p>持续订阅和非持续订阅<br>是针对<strong>“订阅-发布”</strong>模式的细分处理策略</p><ul><li>持续订阅（Durable-subscribers）被标记的用户获取某条消息和它曾经下线没有任何关系，Topic会保存该消息，直到订阅者上线，该消息被正确处理为止。</li><li>非持久化订阅（Non-Durable-subscribers）Topic不再为下线的订阅者保留消息，发送给在线的消费者之后就可以标记为“处理完成”。<h3 id="4-2-2-生产者与消费者优化"><a href="#4-2-2-生产者与消费者优化" class="headerlink" title="4.2.2 生产者与消费者优化"></a>4.2.2 生产者与消费者优化</h3><h4 id="4-2-2-1-生产者（producer）"><a href="#4-2-2-1-生产者（producer）" class="headerlink" title="4.2.2.1 生产者（producer）"></a>4.2.2.1 生产者（producer）</h4>  生产者发送消息支持<strong>同步发送</strong>和<strong>异步发送</strong>。在消息产生堆积的情况下，补不能一味只追求发送效率。<br>  处理消息堆积的基本原则是：</li></ul></li><li><p><strong>持久化状态</strong>：无论如何消息总会被持久化存储，再视情况进行发送。完成消息的存储后，服务节点<strong>会</strong>向生产者发送回执确认消息。</p></li><li><p><strong>非持久化状态</strong>：在内存中产生消息堆积后，会进行消息的转储到Temp store区域。完成消息的存储后，服务节点<strong>不会</strong>向生产者发送回执确认消息。<br>以上两种，如果区域也产生堆积，则会通知生产者开启Slow Producer机制。</p><h5 id="4-2-2-1-1-生产者消息发送"><a href="#4-2-2-1-1-生产者消息发送" class="headerlink" title="4.2.2.1.1 生产者消息发送"></a>4.2.2.1.1 生产者消息发送</h5><p>   生产者默认发送的消息是<strong>持久化类型</strong>，非持久化消息需要明确指明，并且非持久的消息发送默认方式为<strong>异步方式</strong>，即消息存储之后默认不会发送回执消息给生产者。</p></li></ul><p><strong>注意</strong>：异步模式下，在生产者发送一定量的消息后，也需要等待服务端的消息回执,否则会导致消息堆积，需要进行相关配置，仅限异步模式下，是必须配置的。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//以下语句设置消息发送者在累计发送102400byte大小的消息后（可能是一条消息也可能是多条消息</span>    connectionFactory<span class="token punctuation">.</span><span class="token function">setProducerWindowSize</span><span class="token punctuation">(</span><span class="token number">102400</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用以下配置可以异步条件下每次消息的存储都返回回执信息：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//会降低消息发送的效率</span>    connectionFactory<span class="token punctuation">.</span><span class="token function">setAlwaysSyncSend</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在发送持久化消息时，也可以设置为异步方式。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//发送持久化消息时设置的异步</span>    connectionFactory<span class="token punctuation">.</span><span class="token function">setUseAsyncSend</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//因此异步模式下也要设置回执窗口</span>    connectionFactory<span class="token punctuation">.</span><span class="token function">setProducerWindowSize</span><span class="token punctuation">(</span><span class="token number">102400</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><em>小结：</em></p><table><thead><tr><th></th><th>持久化（系统默认）</th><th>非持久化</th></tr></thead><tbody><tr><td>默认方式</td><td>同步发送</td><td>异步发送</td></tr><tr><td>改为同步</td><td></td><td>每次进行消息回执<br>connectionFactory.setAlwaysSyncSend(true);</td></tr><tr><td>改为异步</td><td>connectionFactory.setUseAsyncSend(true);<br>设置回执窗口<br>connectionFactory.setProducerWindowSize(102400);</td><td>并非改为同步<br>异步模式下需要设置回执connectionFactory.setProducerWindowSize(102400);</td></tr><tr><td>##### 4.2.1.1.2 生产者事务</td><td></td><td></td></tr><tr><td>  事务由消息发送者发起，会在连接会话中设置一个Transaction ID,之后可以在事务中发送多条消息。事务未提交之前，消息已经被服务端所接受，但不会进入队列（发现有Transaction ID），消息会被先放置在“transaction store”中，该区域存在“redo”日志，用于事务的回滚。事务在被提交之后，服务端根据自身的规则（持久化还是非持久化）进行消息的入队操作（无论订阅-发布模式还是负载均衡模式）。</td><td></td><td></td></tr><tr><td>##### 4.2.1.1.3 生产者策略</td><td></td><td></td></tr><tr><td>  ProducerFlowControl 生产控制流，当发生消息堆积时，生产者收到服务端的回执消息，服务端会让生成者进入<strong>等待状态</strong>或者直接<strong>抛出JMSException</strong>异常。</td><td></td><td></td></tr><tr><td>  关闭订阅-发布的生产控制流</td><td></td><td></td></tr></tbody></table><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>policyEntry</span> <span class="token attr-name">topic</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">></span><span class="token punctuation">"</span></span> <span class="token attr-name">producerFlowControl</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>  启用负载均衡的生产控制流</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>policyEntry</span> <span class="token attr-name">queue</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">></span><span class="token punctuation">"</span></span> <span class="token attr-name">producerFlowControl</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">memoryLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>200mb<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><p>memoryLimit 表示每个Queue信息的最大内存存储限制，指最多使用200MB的内存区域，非消息总和。</p><h4 id="4-2-2-2-消费者"><a href="#4-2-2-2-消费者" class="headerlink" title="4.2.2.2 消费者"></a>4.2.2.2 消费者</h4><p>  相比较于生产者，消费者的性能会更加影响ActiveMQ系统的整体性能。</p><h5 id="4-2-2-2-1-消费者消息接收"><a href="#4-2-2-2-1-消费者消息接收" class="headerlink" title="4.2.2.2.1 消费者消息接收"></a>4.2.2.2.1 消费者消息接收</h5><p>  默认情况下，ActiveMQ服务端采用异步的方式向消费者推送消息，即服务端不会一直等待消费者响应，消费者完成消息处理之后，主动发送状态到服务端。<br>  将推送设置为同步：</p><pre class=" language-java"><code class="language-java">connectionFactory<span class="token punctuation">.</span><span class="token function">setDispatchAsync</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>  服务端推送消息给消费者，存在推送数量限制，即“预期数量”PrefetchSize。ActiveMQ的默认策略是一旦有新的消息，就主动按照设置的规则推送给当前活动的消费者。<br>   针对不同的工作机制，不同的存储方案，服务端有不同的预期数量设置：</p><table><thead><tr><th></th><th>Queue</th><th>Topic</th></tr></thead><tbody><tr><td>持久化</td><td>1000</td><td>100</td></tr><tr><td>非持久化</td><td>1000</td><td>32766</td></tr><tr><td>- 通过ActiveMQPrefetchPolicy变更预取数量</td><td></td><td></td></tr><tr><td>```java</td><td></td><td></td></tr><tr><td>// 预取策略对象</td><td></td><td></td></tr><tr><td>ActiveMQPrefetchPolicy prefetchPolicy = connectionFactory.getPrefetchPolicy();</td><td></td><td></td></tr><tr><td>// 设置Queue的预取数量为50</td><td></td><td></td></tr><tr><td>prefetchPolicy.setQueuePrefetch(50);</td><td></td><td></td></tr><tr><td>connectionFactory.setPrefetchPolicy(prefetchPolicy);</td><td></td><td></td></tr><tr><td>```</td><td></td><td></td></tr><tr><td>- 更改Properties属性变更预取数量</td><td></td><td></td></tr><tr><td>```java</td><td></td><td></td></tr><tr><td>Properties props = new Properties();</td><td></td><td></td></tr><tr><td>props.setProperty(“prefetchPolicy.queuePrefetch”, “1000”);</td><td></td><td></td></tr><tr><td>props.setProperty(“prefetchPolicy.topicPrefetch”, “1000”);</td><td></td><td></td></tr><tr><td>//设置属性</td><td></td><td></td></tr><tr><td>connectionFactory.setProperties(props);</td><td></td><td></td></tr><tr><td>```</td><td></td><td></td></tr><tr><td>##### 4.2.2.2.2 消费者事务</td><td></td><td></td></tr><tr><td>  消费者采用事务告知服务器一组消息是否处理成功，要么全部处理成功，要么失败全部进行回滚。</td><td></td><td></td></tr><tr><td>  调用回滚时，回滚之前的数据将会被重新进行发送，并且在同一个会话之中。消息的重发计数器（redeliveryCounter）属性将会加1.</td><td></td><td></td></tr><tr><td>##### 4.2.2.2.3 死信队列</td><td></td><td></td></tr><tr><td>  一条消息失败，会进行回滚重发，一旦重发次数达到一定的策略值（默认为6次），该消息将会被加入到死信队列。</td><td></td><td></td></tr><tr><td>- 非持久化策略下，消息超过重发上限，将会被删除</td><td></td><td></td></tr><tr><td>- 默认情况下持久化策略下，消息会加入到死信队列</td><td></td><td></td></tr><tr><td>  设置非持久化也加入到死信队列：</td><td></td><td></td></tr><tr><td>```xml</td><td></td><td></td></tr><tr><td><policyentry queue=">"></policyentry></td><td></td><td></td></tr><tr><td><deadletterstrategy></deadletterstrategy></td><td></td><td></td></tr><tr><td><shareddeadletterstrategy processnonpersistent="true"></shareddeadletterstrategy></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>```</td><td></td><td></td></tr><tr><td>  修改默认的重发次数：</td><td></td><td></td></tr><tr><td>```java</td><td></td><td></td></tr><tr><td>RedeliveryPolicy redeliveryPolicy = connectionFactory.getRedeliveryPolicy();</td><td></td><td></td></tr><tr><td>// 设置最大重发次数</td><td></td><td></td></tr><tr><td>redeliveryPolicy.setMaximumRedeliveries(3);</td><td></td><td></td></tr><tr><td>```</td><td></td><td></td></tr><tr><td>  触发重发的三种机制：</td><td></td><td></td></tr><tr><td>描述</td><td>重发计数器的作用域</td><td></td></tr><tr><td>–</td><td>–</td><td></td></tr><tr><td>在消费者连接会话中调用回滚</td><td>本次连接会话</td><td></td></tr><tr><td>在消费者连接会话中，commit之前，连接终止</td><td>整个ActiveMQ系统范围</td><td></td></tr><tr><td>在发送ACK告知服务器之前，连接终止</td><td>整个ActiveMQ系统范围</td><td></td></tr><tr><td>##### 4.2.2.2.4 消费者acknowledge策略</td><td></td><td></td></tr><tr><td>  消费者端通知服务器的两种方式：<strong>事务</strong>和<strong>acknowledge</strong></td><td></td><td></td></tr></tbody></table><p>  acknowledge模式的四种方式：<br>|参数|简介|<br>|–|–|<br>|AUTO_ACKNOWLEDGE|连接会话会自动认为消费者端对消息的处理时成功的，无论是服务端主动推送还是消费者端主动拉取，但消费端不一定是逐条进行ACK|<br>|CLIENT_ACKNOWLEDGE|同上场景，但必须要进行ACK确认，否则认为消息没有处理成功|<br>|DUPS_OK_ACKNOWLEDGE|批量确认方式，消费端依据策略间隔发送ack，表示一批消息处理完成|<br>|INDIVIDUAL_ACKNOWLEDGE|单独确认方式，消费者端逐条发送ack确认消息，性能较差|</p><p><strong>备注</strong>：</p><ul><li>推荐使用AUTO_ACKNOWLEDGE + optimizeACK，该优化选项只有在AUTO_ACKNOWLEDGE的模式下生效，目的在于“延迟确认”，当消息的数量达到策略值，通过ack告知服务端，这批消息处理完成。<strong>数量阈值为：prefetch*0.65, 时间阈值为：&gt; optimizeAcknowledgeTimeOut</strong></li><li>DUPS_OK_ACKNOWLEDGE 在<strong>负载均衡模式</strong>下和AUTO_ACKNOWLEDGE是一致的。</li><li>AUTO_ACKNOWLEDGE 下 如果prefetchSize = 1,也会进行逐条确认</li><li>如果是<strong>发布-订阅模式</strong>，阈值&gt;= prefetch*0.5时，都会进行批量确认。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：类加载机制</title>
      <link href="/2019/01/05/java-xu-ni-ji-lei-jia-zai-ji-zhi/"/>
      <url>/2019/01/05/java-xu-ni-ji-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是类加载机制？"><a href="#1-什么是类加载机制？" class="headerlink" title="1.什么是类加载机制？"></a>1.什么是类加载机制？</h3><ul><li>虚拟机把描述类的数据从Class文件加载到内存中，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</li><li><strong>类型的加载，连接和初始化都是在程序运行期间完成的</strong>，增加了性能开销，但是提高了代码灵活性</li><li>用户可以通过java预定义的和自定义类加载器，让本地的应用程序可以在运行时，从网络或者其他地方加载一个二进制流作为程序代码的一部分</li></ul><h3 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2.类加载的时机"></a>2.类加载的时机</h3><h5 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h5><ul><li>要完成的事情<ul><li>通过类的全限定名获取此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java。lang。Class对象，作为方法区的这个类的各种数据访问入口。Hotspot会将其放到方法区中</li></ul></li><li>数组类本身不通过类加载器创建，由java虚拟机直接创建，但数组类的元素类型，最终要靠类加载器进行创建<ul><li>如果数组的组件类型是引用类型，就采用上述加载过程进行加载</li><li>如果是非引用类型，虚拟机将会把数组C标记为与引导类加载器相关联</li></ul></li></ul><h5 id="2-2-连接"><a href="#2-2-连接" class="headerlink" title="2.2 连接"></a>2.2 连接</h5><ul><li>验证<ul><li>目的是确保Class文件的字节流包含的信息符合当前虚拟机的要求，不会危害虚拟机。</li></ul></li><li>准备</li><li>解析</li></ul><p>​        <strong>备注：加载和连接阶段的部分内容是交叉进行的</strong></p><h5 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h5><ul><li>遇到new等字节码指令时，如果类没有初始化，则需要先触发初始化，触发点为<ul><li>new关键字实例化对象</li><li>读取或设置一个类的非常量静态字段</li><li>调用一个类的静态方法</li></ul></li><li>对类进行反射调用，类没有初始化，则需要先初始化。</li><li>初始化一个类，父类若没有初始化，先初始化父类</li><li>虚拟机启动，用户指定一个要执行的主类，即包含main方法，先初始化主类</li><li>方法句柄所对应的类没有进行初始化，则需要触发初始化。</li><li>被动引用不会触发初始化<ul><li>通过其子类来引用父类中定义的静态字段，只会触发父类的初始化，而不会触发子类的初始化</li><li>通过数组来定义引用类，不会触发此类的初始化</li><li>final  常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，不会触发定义常量类的初始化</li></ul></li><li>一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用到父接口的时候，才会初始化。</li></ul><h5 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h5><h5 id="2-5-卸载"><a href="#2-5-卸载" class="headerlink" title="2.5 卸载"></a>2.5 卸载</h5><p>​                </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：垃圾收集器与内存分配策略</title>
      <link href="/2019/01/03/java-xu-ni-ji-la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
      <url>/2019/01/03/java-xu-ni-ji-la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/</url>
      
        <content type="html"><![CDATA[<h3 id="1-回收依据"><a href="#1-回收依据" class="headerlink" title="1. 回收依据"></a>1. 回收依据</h3><h5 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h5><ul><li>给对象添加一个引用计数器，每当有一个地方引用它，计数器值加1，引用失效，计数器减1，任何时刻计数器为0，表示该对象不再使用</li><li>实现简单，判定效率高</li><li>主流虚拟机未采用其进行内存管理，因为难以解决对象之间相互循环引用的问题</li></ul><h5 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h5><ul><li>以一系列GC roots的对象作为起始点，从这些节点向下搜索，走过的路径称为引用链，当一个对象到GC root没有任何引用链，则认为该对象不可达，不可用。</li><li><em>GC root</em><ul><li>虚拟机栈中引用的对象</li><li>方法区中静态类引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li></ul><h3 id="2-对象引用"><a href="#2-对象引用" class="headerlink" title="2.对象引用"></a>2.对象引用</h3><h5 id="2-1-强引用"><a href="#2-1-强引用" class="headerlink" title="2.1 强引用"></a>2.1 强引用</h5><ul><li>只要强引用在，垃圾收集器就永远不会回收掉被引用的对象</li></ul><h5 id="2-2-软引用"><a href="#2-2-软引用" class="headerlink" title="2.2 软引用"></a>2.2 软引用</h5><ul><li>还有用，但非必须的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收</li></ul><h5 id="2-3-弱引用"><a href="#2-3-弱引用" class="headerlink" title="2.3 弱引用"></a>2.3 弱引用</h5><ul><li>被弱引用关联的对象只能生存到下一次垃圾收集发生之前，无论内存是否足够，都会被回收</li></ul><h5 id="2-4-虚引用"><a href="#2-4-虚引用" class="headerlink" title="2.4 虚引用"></a>2.4 虚引用</h5><ul><li>幽灵引用或幻影引用，存在的唯一目的是该对象被回收时，收到一个通知。</li></ul><h3 id="3-对象的回收"><a href="#3-对象的回收" class="headerlink" title="3. 对象的回收"></a>3. 对象的回收</h3><ul><li>即使在可达性算法中不可达的对象，也并非非死不可，一个对象的死亡需要经历两次标记过程。</li><li>认为对象不可达之后，将会进行第一次标记筛选，条件是，该对象是否又必要执行finalize（）方法，对象如果没有覆盖finalize方法，或者已经执行过该方法，则虚拟机认为该对象没有必要执行。</li><li>如果该对象被判定为有必要执行将被放到F-Queue的队列之中，并由一个虚拟机建立的低优先级的Finalize线程去执行它。</li><li>虚拟机对F-Queue进行第二次小规模标记，对象要在finalize（）中拯救自己，只要和引用链的任何一个对象建立关联即可。这样在第二次标记时，它将被移出“即将回收”的集合，否将就将要被回收</li></ul><h3 id="4-回收方法区"><a href="#4-回收方法区" class="headerlink" title="4.  回收方法区"></a>4.  回收方法区</h3><ul><li><p>在方法区会回收效率比较低</p></li><li><p><em>垃圾回收包含两部分</em></p><ul><li><p><em>废弃的常量</em></p><ul><li>常量池中没有任何对象赋予该常量，或者也没有其他地方引用这个字面量，常量池中的其他类，方法，字段的符号引用也与此类似</li></ul></li><li><p><em>无用的类</em>（判断条件）</p><ul><li><p>该类的所有实例都已经被回收，java堆中不存在该类的任何实例</p></li><li><p>加载该类的ClassLoader已经被回收</p></li><li><p>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p><strong>满足这三个条件，表明该类可以被回收，不是必然会被回收</strong></p></li></ul></li></ul></li></ul><h3 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5. 垃圾收集算法"></a>5. 垃圾收集算法</h3><ul><li><p>标记-清除法</p><ul><li>标记出所有的需要回收的对象，在标记完成之后，再进行同一回收</li><li><em>缺点</em><ul><li>效率不高</li><li>会产生大量的不连续的内存碎片，程序运行中需要大内存进行分配时，如果找不到合适大小的内存，将会触发二次回收。</li></ul></li></ul></li><li><p>复制算法</p><ul><li><p>将n内存容量划分大小相等的两块，每次只使用一块，当另一块用完时，将存活对象放到另一块，将该块进行全部清理掉。</p></li><li><p>实现简单，效率高，不考虑内存碎片问题</p></li><li><p>缺点是内存变为原来一半，代价过高</p></li><li><p><em>演变</em></p><ul><li><p>现在的商业型虚拟机进行新生代对象回收时，分配比例一般为8：1</p><ul><li><p>占据8的Eden</p></li><li><p>占据1的Survivor</p></li><li><p>占据1的Survivor</p><p><strong>拿到该两处的存活对象，放入Survivor中，然后进行擦除，如果Survivor放不下，需要依赖其他内存（老年代）进行分配担保，即Survivor如果放不下，会直接存入到老年代中。</strong></p></li></ul></li></ul></li><li><p>如果老年代存活率较高，不适合使用该算法</p></li></ul></li><li><p>标记整理法</p><ul><li>在标记清除的算法基础上，增加了整理工作</li><li>让所有存活的对象都向另一端移动，然后清除掉边界以外的内存</li></ul></li><li><p>分代收集算法</p><ul><li>根据老年代和新生代的特点，进行算法的选择</li><li>新生代，对象死亡率较高，采用复制算法比较合理</li><li>老年代，存活率高，没有额外空间为其担保，一般采用标记-清理或者标记-整理算法。</li></ul></li></ul><h3 id="6-HotSpot的算法实现"><a href="#6-HotSpot的算法实现" class="headerlink" title="6.HotSpot的算法实现"></a>6.HotSpot的算法实现</h3><ul><li>枚举根节点<ul><li>作为GC root的节点在全局性的引用与执行上下文中。</li><li>采用OopMap的数据结构来达成目的，在类加载完成的时候，HotSpot会把对象内什么偏移量上是什么类型的数据计算出来。在JIT编译时，也会在特定的位置记录下栈和寄存器中哪些位置时引用。这样GC扫描时，可以直接扫这些信息</li></ul></li><li>安全点<ul><li>程序执行时，并非在所有地方都能停顿下来开始GC,只有到达安全点，才能暂停</li><li>安全点的选定基本上是以程序‘’是否具有让程序长时间执行的特征“为标准进行选定的</li><li>GC发生时，让所有的线程都跑到安全点再停顿下来<ul><li><strong><em>抢先式中断</em></strong> ，不需要线程的执行代码主动配合，gc发生时，所有线程中断，发现其不在安全点，就恢复其线程，跑到安全点。现在几乎不怎么使用</li><li><strong><em>主动式中断</em></strong>，不对线程直接操作，设定一个标志位，各个线程执行时，主动去轮询这个标志，发现标志为真，就自己中断挂起，轮询标志的地方和安全点是重合的</li></ul></li></ul></li><li>安全区域<ul><li>线程可能处于sleep或者blocked状态，无法响应JVM的中断请求，这时就需要安全区域</li><li>安全区域指在一段代码片段中，引用关系不会发生变化，这个区域的任意地方开始GC都是安全的，可以将安全区域看成安全点的扩展</li><li>在线程要离开安全区域之前，检查系统是否已经完成根节点枚举，如果完成，那线程就继续执行，否则必须等到收到可以安全离开的Safe Region的信号为止</li></ul></li></ul><h3 id="7-垃圾收集器"><a href="#7-垃圾收集器" class="headerlink" title="7.垃圾收集器"></a>7.垃圾收集器</h3><ul><li>Serial收集器<ul><li>是一个单线程收集器，收集期间，必须暂停其他所有线程，直到收集结束</li><li>是虚拟机运行在client下的默认新生代收集器</li><li><em>优点</em><ul><li>简单高效</li><li>没有线程交互的开销</li></ul></li></ul></li><li>ParNew收集器<ul><li>是Serial的多线程版本，控制参数，收集算法，对象分配规则，回收策略和Serial收集器一样</li><li>运行在Server模式下的虚拟机中首选二点新生代收集器</li><li>除了Serial之外，只有该收集器可以和CMS配合使用</li><li>它的出现，使得垃圾收集线程可以和用户线程同时工作</li><li>默认开启的线程数与CPU数目相同</li><li>在单cpu情况下，不一定比Seria收集器好，因为存在线程交互的开销</li></ul></li><li>Parallel Scavenge<ul><li>新生代收集器，使用复制算法，支持并行多线程</li><li>其目标关注点是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU消耗总时间的比值。 = 运行用户代码时间/（运行用户代码时间+垃圾回收时间）</li><li>适合后台运算，被称为“吞吐量优先”收集器</li><li>支持虚拟机的自适应参数配置</li></ul></li><li>Serial Old 收集器<ul><li>是Serial的老年代版本</li><li>单线程收集器</li><li>使用“标记-整理”算法</li><li><em>适用范围</em><ul><li>server<ul><li>与1.5以及之前版本中与Parallel Scavenge 收集器搭配使用</li><li>作为CMS收集器的后备预案</li></ul></li><li>client</li></ul></li></ul></li><li>Parallel Old收集器<ul><li>Parallel Scavenge 收集器的老年代版本</li><li>多线程收集器</li><li>使用标记-整理算法</li><li>在注重吞吐量和CPU资源的场合，优先考虑Parallel scavenge 与 Parallel Old 收集器</li></ul></li><li>CMS收集器<ul><li>一种以获取最短回收停顿时间为目标的收集器</li><li>采用 标记-清楚</li><li><em>步骤</em><ul><li><strong>初始标记</strong>, 标记一下GC roots 能直接关联的对象</li><li><strong>并发标记</strong>,GC Roots进行Tracing的过程</li><li><strong>重新标记</strong>，修正并发标记期间因用户程序继续运转而导致标记变动的那一部分对象的标记记录</li><li><strong>并发清除</strong></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：对象和异常分析</title>
      <link href="/2018/12/30/java-xu-ni-ji-dui-xiang-he-yi-chang-fen-xi/"/>
      <url>/2018/12/30/java-xu-ni-ji-dui-xiang-he-yi-chang-fen-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-HotSpot虚拟机对象"><a href="#1-HotSpot虚拟机对象" class="headerlink" title="1. HotSpot虚拟机对象"></a>1. HotSpot虚拟机对象</h3><h5 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h5><ul><li><strong>遇到一条new指令，首先检查这个指令参数是否在常量池中定位到一个类的符号引用，检查符号代表的类是否被加载，解析和初始化过。如果没有先执行相应的类的加载过程</strong></li><li><strong>虚拟机为对象分配内存</strong><ul><li>内存大小在类加载完成后便可以确定，即是把一块确定大小的内存，从Java堆中划分出来<ul><li>如果java内存是绝对规整的，内存一边，空闲一边，中间是分界点的指示器，那内存分配只是将指针向空闲区挪动对象大小的范围，称为“指针碰撞”。</li><li>如果已使用内存与未使用内存相互交互，虚拟机维护一个列表，记录哪一块内存是可用的，从列表中寻找大小合适的空间划给对象，并更新列表。称为“空闲列表”</li><li>选择哪种方式由java堆是否规整决定，而java堆是否规整又由采用的垃圾回收器是否带有压缩整理而决定</li></ul></li><li>并发情况下不是线程安全的<ul><li>解决方案一：对分配内存空间的动作进行同步处理</li><li>解决方案二：把内存分配的动作按照线程划分在不同的空间进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲。</li></ul></li><li>内存分配完成过后，虚拟机将分配的内存初始化为零值</li><li>将类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，存放到对象的对象头之中。</li><li>对象创建完成之后，紧接着将会执行init方法进行初始化。</li></ul></li></ul><h5 id="1-2-对象的内存布局"><a href="#1-2-对象的内存布局" class="headerlink" title="1.2 对象的内存布局"></a>1.2 对象的内存布局</h5><ul><li><strong>在内存中的布局可分为三部分</strong><ul><li><em>对象头</em><ul><li>第一部分：存储对象自身的运行时数据，如哈希码，gc分代年龄，锁状态标志，线程持有的锁，偏向线程ID,偏向时间戳等，对象头信息是与对象自身定义的数据无关的额外存储成本</li><li>第二部分：类型指针，即对象指向它的类元数据的指针，通过该指针，确定对象是哪个类的实例。查找对象的元数据信息不一定要经过对象本身。如果是个java数组，对象头中还必须有一块用于记录数组长度的数据。</li></ul></li><li><em>示例数据</em><ul><li>是对象真正存储的有效信息，存储顺序会受到虚拟机分配策略参数和字段在java源码中定义的顺序的影响。</li><li>相同宽度的字段总是分配到一起，在该基础下，父类的变量出现在子类的变量之前。</li></ul></li><li><em>对齐填充</em><ul><li>并不是必然存在的</li><li>起占位符作用，对象的大小必须为8字节的整倍数，当对象实例数据没有补齐时，就需要对齐填充来补全</li></ul></li></ul></li></ul><h5 id="1-3-对象的访问定位"><a href="#1-3-对象的访问定位" class="headerlink" title="1.3 对象的访问定位"></a>1.3 对象的访问定位</h5><ul><li><strong>java通过操作栈上的reference数据，来操作堆上的具体对象</strong></li><li><strong>指向对象的引用，可以分为两种方式</strong><ul><li><em>使用句柄</em><ul><li>java堆会划分出一块内存，来作为句柄池，reference存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li><li>优势在于，对象移动时，只会改变句柄中的实例数据指针，而reference本身不需要修改。</li></ul></li><li><em>直接指针</em><ul><li>java堆对象布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的就是直接的对象地址</li><li>优势在于，速度更快，节省了一次指针定位的开销。</li></ul></li></ul></li></ul><h3 id="2-异常分析"><a href="#2-异常分析" class="headerlink" title="2. 异常分析"></a>2. 异常分析</h3><h5 id="2-1-Java堆异常"><a href="#2-1-Java堆异常" class="headerlink" title="2.1 Java堆异常"></a>2.1 Java堆异常</h5><p>​        区分是<strong>内存泄漏</strong>，还是<strong>内存溢出</strong></p><h5 id="2-2-虚拟机栈和本地方法栈溢出"><a href="#2-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.2 虚拟机栈和本地方法栈溢出"></a>2.2 虚拟机栈和本地方法栈溢出</h5><ul><li>线程请求的栈深度大于虚拟机所允许的最大深度，抛出stackOverFlow异常</li><li>虚拟机在扩展栈时，无法申请到足够的内存空间，导致OutOfMemory异常</li><li>在单线程下，无论时栈帧太大，还是虚拟机的容量太小，当内存无法分配时，虚拟机抛出的都是StackOverFlowError异常</li><li>为每个线程的栈分配的内存越大，反而容易产生内存溢出<ul><li>操作系统分配给进程的内存有限，减去方法去和java堆，再减去程序计数器，其余由虚拟机栈和本地方法栈瓜分，每个线程分配的栈容量越大，可建的线程数量会减小，再建时，会将剩下的内存耗尽。</li><li>如果建立太多线程导致内存溢出，可以考虑减少最大堆和减少栈容量来换取更多线程，即通过减少内存的手段来解决内存溢出的问题。</li></ul></li></ul><h5 id="2-3-方法区和运行时常量池溢出"><a href="#2-3-方法区和运行时常量池溢出" class="headerlink" title="2.3 方法区和运行时常量池溢出"></a>2.3 方法区和运行时常量池溢出</h5><ul><li>常见的内存溢出异常</li><li>动态期间生成大量Class的应用中，需要特别注意类的回收状况</li></ul><h5 id="2-4-本地直接内存溢出"><a href="#2-4-本地直接内存溢出" class="headerlink" title="2.4 本地直接内存溢出"></a>2.4 本地直接内存溢出</h5><ul><li>DirectMemory导致的内存溢出，一个明显的特征是Head Dump 文件不会看见明显的异常，如果发现OOM很小，代码中又用了NIO，可以考虑下这方面的原因。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机：内存区域</title>
      <link href="/2018/12/21/java-xu-ni-ji-nei-cun-qu-yu/"/>
      <url>/2018/12/21/java-xu-ni-ji-nei-cun-qu-yu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​            Java虚拟机在执行java程序时，会将所管理的内存划分为不同的数据区域，大致如下：</p><p>​        <img src="/2018/12/21/java-xu-ni-ji-nei-cun-qu-yu/1570861077915.png" alt="1570861077915"></p><p>​            其中<strong>方法区</strong>和<strong>堆</strong>属于线程共享，<strong>虚拟机栈、本地方法栈和程序计数器</strong>属于线程隔离。</p><h3 id="2-区域介绍"><a href="#2-区域介绍" class="headerlink" title="2. 区域介绍"></a>2. 区域介绍</h3><h5 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h5><ul><li><p>可以看作是当前线程所执行的字节码的行号指示器</p></li><li><p>java虚拟机的多线程，实质上是线程轮流切换并分配处理器的执行时间的方式来实现的。在任意时刻，只有一个线程在执行其中的指令。确保线程切换后工作的正常执行，每个线程拥有独立的程序计数器，属于线程私有。</p></li><li><p>若执行Java方法，记录字节码指令的地址，Native方法，计数器值为空。</p></li><li><p>唯一一个没有规定任何OutMemoryError情况的区域。</p></li></ul><h5 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h5><ul><li>属于线程私有，生命周期与线程相同</li><li>用于描述Java方法执行的内存模型</li><li>每个方法在执行时，会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息</li><li>一个方法的完成就是一个栈帧在虚拟机栈中的进栈出栈过程</li><li>局部变量表<ul><li>存放编译器可知的各种基本数据类型</li><li>对象引用类型</li><li>不是对象本身，可能是一个指向对象起始地址的引用指针，或者是指向一个代表对象的句柄，或者其他与此对象相关的位置</li><li>long和double会占用两个字节，其余的只占用一个</li><li>所需的内存空间在编译期间完成分配，进入一个方法时，帧中的大小已经固定，运行期间不会改变</li></ul></li><li>两种异常<ul><li>线程请求的栈的深度大于虚拟机所允许的深度，会抛出StackOverFlow异常</li><li>如果虚拟机栈可以扩展，但扩展时没有足够的内存，会抛出OutOfMemoryError</li></ul></li></ul><h5 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h5><ul><li>与虚拟机栈发挥的作用类似，但是虚拟机栈为java方法服务，本地方法栈为Native方法服务</li><li>虚拟机对于使用的语言，使用方式，和数据结构没有做强制规定，具体的虚拟机可以自由实现</li><li>会抛出两种异常<ul><li>StackOverFlowError异常</li><li>OutofMemoryError异常</li></ul></li></ul><h5 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h5><ul><li>Java虚拟机所管理的内存中最大的一块</li><li>是被所有线程共享的一块内存区域，在虚拟机启动时创建</li><li>内存的唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配内存，详细描述是，所有的对象实例以及数组都要在堆上分配实例</li><li>Java堆是 垃圾收集器的主要区域，即GC堆</li><li>结构<ul><li>新生代<ul><li>Eden</li><li>From survivor</li><li>To survivor</li></ul></li><li>老年代</li></ul></li><li>从内存角度来看，堆中可能划分出多个线程私有的分配缓冲区，划分的目的是更好的分配内存或者划分内存</li><li>java堆可以在物理上不连续的内存空间中，只要逻辑连续即可</li><li>通过-Xms  和-Xmx控制</li><li>堆中没有内存完成实例分配，并且无法扩展时，会抛出OutOfMemoryError异常</li></ul><h5 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h5><ul><li>和java堆一样，都是线程共享区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据</li><li>虚拟机规范，描述方法区为堆的一个逻辑部分，但自身又称为非堆，目的是和java堆区分开，或者被称为“永久代”。</li><li>不需要连续的内存，可以选择固定大小，并且可以扩展，还可以选择不实现垃圾回收。</li><li>这个区域的内存回收目标主要是针对常量池的回收和对类的卸载</li><li>当方法区无法满足内存分配需求时，将会抛出OutOfMemory异常</li></ul><h3 id="3-其他区域"><a href="#3-其他区域" class="headerlink" title="3. 其他区域"></a>3. 其他区域</h3><h5 id="3-1-运行时常量池"><a href="#3-1-运行时常量池" class="headerlink" title="3.1 运行时常量池"></a>3.1 运行时常量池</h5><ul><li>是方法区一部分，用于存放编译期间生成的各种字面量和符号的引用。这部分内容将会在类加载后进入方法区的运行时常量池中存放</li><li>虚拟机规范没有做细节的要求，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中</li><li>常量池具有动态性，并非一定产生于编译器，运行期间也可能将新的常量存放于池中。</li><li>当常量池无法再申请到内存时，会抛出OutOfMemoryError异常</li></ul><h5 id="3-2-直接内存"><a href="#3-2-直接内存" class="headerlink" title="3.2 直接内存"></a>3.2 直接内存</h5><ul><li>不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域</li><li>这部分内存被频繁使用，可能导致OutOfMemory的异常出现</li><li>不会受java堆的限制，但会受到本机内存的限制</li><li>设置时，忘了设置直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展出现OutOfMemoryError异常</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql：深入之分区</title>
      <link href="/2018/12/15/mysql-shen-ru-zhi-fen-qu/"/>
      <url>/2018/12/15/mysql-shen-ru-zhi-fen-qu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>  日常开发中经常会遇到数据库的一些大表，即单表数据存储可能是百万级甚至千万级并且字段非常多，由于表数据的庞大，会导致在数据检索和变更方面的效率很低，如果SQL复杂，级联表众多，其运行性能会变的非常糟糕。使得数据库在高并发情况下成为系统的性能瓶颈。一定程度的分区分表，甚至在分布式情况下的分库等，能有效提升数据库的效率，但凡事均有度，分区分表过多，会造成内存占用升高，以及主从之间数据的一致性问题等等，怎样分区分表，分多少合适，还是要基于现实的业务情况进行选择处理。</p><h3 id="2-分区"><a href="#2-分区" class="headerlink" title="2.分区"></a>2.分区</h3><p>  分区允许通过设置需要的规则在文件系统中分布存储单个表的各个部分。实际上就是表的不同部分作为单独的表存储在不同的位置，Mysql5.1引入的，是一种简单的<strong>水平拆分</strong>，在建表时加上分区参数，对应用是透明的，无需代码的修改。分区本质上是将数据底层的存储块变多，在数据库层面依旧是一张表。</p><p>  目前的mysql8.0中，唯一支持分区的存储引擎是InnoDB和NDB。分区不能与不支持分区的存储引擎一起使用，这些引擎包括MyISAM、MERGE、CSV和FEDERATED存储引擎。</p><p>  分区可以分为两种：<strong>水平分区</strong>和<strong>垂直分区</strong></p><ul><li>水平分区，通常是对表的行进行分区，将不同的行数据进行切割，但表中定义的列在每个数据集中都能找到，只是根据规则将不同的行数据存储在不同的存储块中。</li><li>垂直分区，通过对表的垂直划分来减少目标表的宽度，使得特定的列被划分到特定的分区，每个分区都包含了该列所对应的所有的行</li></ul><p><strong>分区的本质是单表数据在物理层存储的改变，目前mysql还不支持垂直分区，网上大多数将垂直分区和垂直分表混为一谈。</strong></p><p>  <strong>水平分区的四大类型</strong></p><ul><li>范围分区（Range）</li><li>列表分区（List）</li><li>哈希分区（Hash）</li><li>Key分区<h5 id="2-1-Range分区"><a href="#2-1-Range分区" class="headerlink" title="2.1 Range分区"></a>2.1 Range分区</h5>   把一个连续的区间进行划分，把多行分配给分区，常见的字段为自增的主键ID,或者是时间等，基于分区的列最好是整型。</li></ul><pre><code>CREATE TABLE `sql_range` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY RANGE (id)(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN (30),    PARTITION p4 VALUES LESS THAN (40),    PARTITION p5 VALUES LESS THAN (MAXVALUE))-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- range添加新分区alter table &lt;table&gt; add partition(partition p4 values less than MAXVALUE);-- range重新分区ALTER TABLE user REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES LESS THAN MAXVALUE);</code></pre><p><strong><em>注意</em></strong>：</p><ul><li>按照时间范围分区时，转换函数最好使用UNIX_TIMESTAMP 而不是TIMESTAMP</li><li>对于null值，Range分区会将其作为最小分区值存储<h5 id="2-2-List分区"><a href="#2-2-List分区" class="headerlink" title="2.2 List分区"></a>2.2 List分区</h5>  类似于Range分区，但区别在于List分区是一个枚举值列表的集合，而非区间，建议分区为非null列，否则插入null，而集合中不包含，则会报错。另外，List分区只支持整型。</li></ul><pre><code>CREATE TABLE `sql_list` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY LIST (id)(    PARTITION p1 VALUES IN (1,3,5),    PARTITION p2 VALUES IN  ('a','b'))会报错：VALUES value for partition 'p2' must have type INT-- 删除list或者range分区(同时删除分区对应的数据)alter table &lt;table&gt; drop partition &lt;分区名称&gt;;-- list添加新分区alter table &lt;table&gt; add partition(partition p4 values in (25,26,28));-- list重新分区ALTER TABLE &lt;table&gt; REORGANIZE PARTITION p0,p1,p2,p3,p4 INTO (PARTITION p0 VALUES in (1,2,3,4,5));</code></pre><h5 id="2-3-Hash分区"><a href="#2-3-Hash分区" class="headerlink" title="2.3 Hash分区"></a>2.3 Hash分区</h5><p>  对于一些表，是没有连续的字段或者集合性质的可以用来明显分区的特征字段，但表数据又非常庞大，为了将这些数据分散存储，mysql提供了hash分区，基于给定的分区个数，将数据分配到不同分区，但只针对于整数hash，非整数类型数据需要表达式转换，复杂表达式可能造成性能问题。</p><p>hash分区可以细分为：<strong><em>hash</em></strong>分区和<strong><em>线性hash</em></strong>分区，语法区别在于 partition by linear hash.</p><ul><li>Hash分区，是通过MOD函数取模的方式可以让数据非常平均的分布在每一分区，但由于分区在创建时已经固定，新增和收缩分区，数据的迁移比较大。</li><li>线性Hash分区，优点在于增加，删除，合并和拆分分区变的快捷，有利于处理大量的数据的表，缺点在于数据分布可能不太均匀。</li></ul><p>  hash分区示例代码如下：</p><pre><code>CREATE TABLE `sql_hash` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY HASH (id)PARTITIONS 4;//不指定PARTITIONS 4子句时，默认分区为1-- hash重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-4-Key分区"><a href="#2-4-Key分区" class="headerlink" title="2.4 Key分区"></a>2.4 Key分区</h5><p>  key分区类似于Hash分区，但区别在于以下四点：</p><ul><li><p>KEY分区允许多列，Hash只允许一列。</p></li><li><p>如果有主键或唯一键，key分区可不指定，默认是主键或唯一键。如果没有必须显示指定。</p></li><li><p>KEY分区必须基于列，而不是基于列的表达式</p></li><li><p>Hash的算法是MOD函数，而Key是MD5</p></li></ul><pre><code>CREATE TABLE `sql_key` (  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8PARTITION BY KEY (id)PARTITIONS 4;    -- key重新分区alter table &lt;table&gt; add partition partitions 4;</code></pre><h5 id="2-5-子分区"><a href="#2-5-子分区" class="headerlink" title="2.5 子分区"></a>2.5 子分区</h5><p>  子分区是对分区表中的每个分区再进行分割，又称复合分区，支持对range和list进行子分区，子分区可以采用hash分区或者key分区。复合分区用于保存大量的数据记录。<br>  示例代码如下：</p><pre><code>CREATE TABLE custom(    id INT,    NAME VARCHAR(20))PARTITION BY RANGE(id)SUBPARTITION BY HASH(id) SUBPARTITIONS 2(    PARTITION p1 VALUES LESS THAN (10),    PARTITION p2 VALUES LESS THAN (20),    PARTITION p3 VALUES LESS THAN MAXVALUE)# 指明了子分区名CREATE TABLE seller(    id INT,    NAME VARCHAR(50)) PARTITION BY RANGE(id)SUBPARTITION BY HASH(id)(    PARTITION p1 VALUES LESS THAN (10)(SUBPARTITION s1, SUBPARTITION s2, SUBPARTITION s3),    PARTITION p2 VALUES LESS THAN (20)(SUBPARTITION s4, SUBPARTITION s5, SUBPARTITION s6),    PARTITION p3 VALUES LESS THAN MAXVALUE(SUBPARTITION s7, SUBPARTITION s8, SUBPARTITION s9))--子分区添加新分区，系统自动为子分区命名alter table &lt;table&gt; add partition(partition p3 values less than MAXVALUE);</code></pre><h3 id="3-分区表"><a href="#3-分区表" class="headerlink" title="3.分区表"></a>3.分区表</h3><h5 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h5><p>  普通表进行分区之后就被称为分区表，分区表是由多个相关的底层表（存储块）来实现的，这些底层表也是由句柄对象表示，所以我们可以直接访问各个分区，管理分区的各个底层表和普通表对于存储引擎来说是一样的，分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储角度来看没有区别，存储引擎无需知道该表是普通表还是分区表。</p><p><img src="/2018/12/15/mysql-shen-ru-zhi-fen-qu/1566879182129.png" alt=""></p><h5 id="3-2-操作分析"><a href="#3-2-操作分析" class="headerlink" title="3.2 操作分析"></a>3.2 操作分析</h5><ul><li>select：查询分区表时，分区层先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</li><li>insert：写入分区表时，分区层先打开并锁住所有的底层表，确定哪个分区接受这条记录，再将记录写入对应的底层</li><li>delete: 删除数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，并进行记录删除</li><li>uodate: 更新数据时，分区层先打开并锁住所有的底层表，确定记录所在分区，取出更新，再确定数据该放到哪个分区，对底层表进行写操作，并删除原分区表的旧数据。</li></ul><p><strong>注意</strong>：如果存储引擎能够自己实现行级锁，如Innodb，则会在分区层释放对应的表锁，这个加锁和解锁的过程与普通Innodb上的查询类似。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><h5 id="4-1-分区的注意事项"><a href="#4-1-分区的注意事项" class="headerlink" title="4.1 分区的注意事项"></a>4.1 分区的注意事项</h5><ul><li><p>primary key  和unique key必须包含在分区key的一部分，否则在创建primary key 和unique index时会报错</p></li><li><p>范围分区添加分区只能在最大值后面追加分区</p></li><li><p>所有分区的engine必须一样</p></li><li><p>范围分区字段：integer，数值表达式，日期列，日期函数表达式（如year(), to_days(), to_seconds(), unix_timestamp()）</p></li><li><p>分区字段尽量避免null值，null值对于range分区，会放置到最左边的分区，对于list分区，必须在集合中加入null，对于key和hash分区，都会将null返回为0</p></li><li><p>一个表最多只能有1024个分区</p></li><li><p>分区表无法使用外键约束</p><h5 id="4-2-分区的优点"><a href="#4-2-分区的优点" class="headerlink" title="4.2 分区的优点"></a>4.2 分区的优点</h5></li><li><p>只获取表的热点数据，其他都是历史数据</p></li><li><p>分区表更容易进行维护，可以针对单个分区删除数据，也可以新增分区进行数据的插入，还可以对一个独立的分区进行优化、检查和修复等操作</p></li><li><p>部分查询能够从查询条件确定只落到少数分区上，速度比较快</p></li><li><p>分区表的数据可以分布到不同的物理设备上，从而高效利用多个硬件设备</p></li><li><p>可以使用分区表避免某些特殊瓶颈，如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</p></li><li><p>可以备份和恢复单个分区</p></li><li><p>优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时，涉及聚合函数是，可以在分区上进行处理，最终只需要汇总所有分区的得到的结果</p><h5 id="4-3-分区与分表的关系"><a href="#4-3-分区与分表的关系" class="headerlink" title="4.3 分区与分表的关系"></a>4.3 分区与分表的关系</h5></li><li><p>都能提高mysql的性能，在高并发状态下有一个良好的表现</p></li><li><p>分表和分区不矛盾，可以相互配合，对于需要大量访问，并且数据比较多的表，可以采用分区加分表的方式，访问量不大，但数据很多的表，可以仅采用分区的方式。</p></li><li><p>分表稍微复杂，需要手动创建子表，读写时需要计算子表名。</p></li><li><p>表分区相对于分表，操作方便，不需要创建子表</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql：深入之分表</title>
      <link href="/2018/12/08/mysql-shen-ru-zhi-fen-biao/"/>
      <url>/2018/12/08/mysql-shen-ru-zhi-fen-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  mysql中存在一种机制是表锁定（myisam存储引擎）和行锁定（innodb存储引擎），对于一行数据或一张表，同时只能有一条sql进行操作，其他针对该行或该表的执行sql需要进行排队，在高并发情况下，请求执行的sql如果出现骤增，整个系统的性能将会卡在sql的执行效率上。对一些数据庞大的表，可以采取分表策略，将执行的sql进行均匀分布，减少sql等候执行队列的长度，提高数据库的吞吐量。</p><h3 id="2-分表"><a href="#2-分表" class="headerlink" title="2.分表"></a>2.分表</h3><p> 分表依据不同的业务情况可以分为两种切分方式：<strong>垂直切分</strong>和<strong>水平切分</strong>。</p><h5 id="2-1-垂直切分"><a href="#2-1-垂直切分" class="headerlink" title="2.1 垂直切分"></a>2.1 垂直切分</h5><p> 垂直切分的场景是，表中属性很多，但是基本上是核心的几个属性的操作频率很高，其他的属性平时不怎么需要获取到。</p><ul><li>将长度较短，访问频率高的属性可以放到一个表中，暂且称为主表。</li><li>将长度较短，访问频率低的属性放到一个表中，暂且称为扩展表。</li><li>也可以将经常一起访问的属性，放置到同一表中，具体视业务而定。</li></ul><p> 数据库有自身的内存buffer，会将磁盘上的数据load到内存buffer中，其单位是以row为单位的，在内存有限的情况下，缓存越短的row，就能缓存更多的数据，提高缓存命中率，减少磁盘访问，有效提高操作效率。</p><p><strong>缺点：</strong></p><ul><li>会造成一定量的冗余列</li><li>查询所有数据需要进行join操作，如果进行了分库，表在不同库或服务器，将会增加访问数据库次数。<h5 id="2-2-水平切分"><a href="#2-2-水平切分" class="headerlink" title="2.2 水平切分"></a>2.2 水平切分</h5> 水平切分场景是，单表的数据量很大，执行多条sql会造成排队较长，整体的执行效率降低。这时需要将表中行数据按照一定的规则进行进行划分，创建多个子表，<strong>分表不同于分区，mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对应三个文件，.MYD数据文件，。MYI索引文件，。FRM表结构文件</strong>。这样就能保证sql的执行是在不同的表中，读取的时候从各自的表中进行读取，降低了单表的sql执行的排队长度。</li></ul><p><strong>缺点：</strong></p><ul><li>当分配规则确定后，打破这条规则很麻烦，可能会导致相同的数据，因为规则不同而出现在不同的表中。</li><li>同库不同表数据需要进行union操作</li><li>不同库不同表将会增加数据库访问次数</li></ul><p><strong>利用merge存储引擎分表</strong><br> 把已有的大数据量的表进行切分的确非常困难，可能涉及到要修改代码中大量的sql，利用merge存储引擎分表将会在数据库层面进行表的切分，而对外程序的中依旧是该主表，不需要代码中sql的修改，但仅限于MyISAM存储引擎，采用InnoDB引擎的表不适用。<br> 具体代码如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 分表1</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> user_1<span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MYISAM<span class="token comment" spellcheck="true">#分表2</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> user_2<span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MYISAM<span class="token comment" spellcheck="true"># merge表挂载分表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">USER</span><span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">MERGE</span> <span class="token keyword">UNION</span><span class="token operator">=</span><span class="token punctuation">(</span>user_1<span class="token punctuation">,</span>user_2<span class="token punctuation">)</span> INSERT_METHOD<span class="token operator">=</span><span class="token keyword">LAST</span><span class="token punctuation">;</span></code></pre><ul><li><strong>ENGINE=MERGE</strong> 指明merge表使用MERGE引擎</li><li><strong>UNION=(user_1,user_2)</strong> 指明merge表挂载了哪些表</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">#该sql用于移除user_2的挂载</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">USER</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">MERGE</span> <span class="token keyword">UNION</span><span class="token operator">=</span><span class="token punctuation">(</span>user_1<span class="token punctuation">)</span> INSERT_METHOD<span class="token operator">=</span><span class="token keyword">LAST</span> </code></pre><ul><li><strong>INSERT_METHOD=LAST</strong> 指明输入插入的方式，0表示不允许数据插入，<strong>FIRST</strong>将会插入UNION的第一个分表中，<strong>LAST</strong>将会插入UNION的最后一个分表中</li><li>如上sql所示，merger表和其他的分表结构必须保持一致，包括同样的索引。</li><li>一个merge表不能在整个表上维持unique约束，若merge存在重复主键，按主键查询，获取一条记录便会停止。后续重复主键的数据将无法插入，即只保证挂载之后主键的唯一性。</li><li>若分表存在自增主键，merge表新数据的插入自增将会从分表中最大的主键开始自增。即user_1最大自增主键为10，user_2为20，则merge表数据的主键将会从21开始。</li></ul><p><strong>推荐：利用merge存储引擎分表，可以先有一张merge表，且只挂载一个分表，当分表的数据到达一定的数量级之后，再建立新的分表进行挂载，数据将会插入到新分表中</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql：深入分库</title>
      <link href="/2018/12/02/mysql-shen-ru-zhi-fen-ku/"/>
      <url>/2018/12/02/mysql-shen-ru-zhi-fen-ku/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>  大多数的数据库设计往往是一台主库负责数据的写入，多台从库同步主库数据仅提供读数据，但随着业务的增长，主库的写压力会与日俱增，这时往往通过分库+分布式的架构来缓解来自业务数据增长带来的压力，但同时也会引发数据的一致性和事务等诸多问题。</p><h3 id="2-分库"><a href="#2-分库" class="headerlink" title="2.分库"></a>2.分库</h3><p>  数据库的拆分同样也可以分为两种<strong>垂直拆分</strong>和<strong>水平拆分</strong><br>  <strong>垂直拆分</strong>是分库的首选，其分库方式较为简单，因其的依据在于业务的整体架构，可以将独立不相关的业务模块的表迁移到不同的库中，要求数据的增长速度比较平稳。<br>  <strong>水平拆分</strong>复杂度较高，往往会涉及<strong>分表</strong>。<br>  拆分思路：</p><ul><li>按算法对应<br>  将数据的主键按照固定的算法进行分类，放置到不同的数据库中，实现较为方便，但扩展性较差，后续节点收缩或算法变动会造成很大的数据集迁移。</li><li>按索引映射表对应<br>  即建立数据主键与所在数据库的关系表，每次数据请求先去该表查取，再到具体的数据库获取数据，优势在于伸缩性，新的数据进来，只需要放入合适的库中，在关系表上添加对应的记录便可。缺点在于会增加数据库的访问次数。<h3 id="3-分库面临的问题"><a href="#3-分库面临的问题" class="headerlink" title="3.分库面临的问题"></a>3.分库面临的问题</h3></li><li>不能跨库关联查询<br>  当关联数据分布在不同的数据库中或者获取级联数据时不能进行join操作，解决思路要么数据两边均存储一份（全局表），采用空间换时间，要么只能代码层查询之后再进行聚合，牺牲部分性能</li><li>不能保证数据的一致性<br>  跨库的数据没有外键约束，也没有事务保证。</li><li>所有查询必须提供数据库线索<br>  分库之后的数据可能存在于不同库中，每次数据的操作都需要先定位库的位置。</li><li>自增ID<br>  有时跨库数据可能依赖于数据主键，采取自增主键可能导致不同库的数据录入时主键信息不一致，可以采取第三方表数据生成自增主键为标准，作为相关数据的主键，保证自增的一致性。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：泛型</title>
      <link href="/2018/11/24/java-fan-xing/"/>
      <url>/2018/11/24/java-fan-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>​        泛型的主要目的之一就是来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性，基本类型无法作为类型参数。</p><h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h3><h5 id="2-1-元组概念"><a href="#2-1-元组概念" class="headerlink" title="2.1 元组概念"></a>2.1 元组概念</h5><p>​        将一组对象打包直接存储在其中一个单一对象中。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//可被继承 进行扩展</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TwoTuple</span><span class="token operator">&lt;</span>A<span class="token punctuation">,</span> B<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> A first<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> B second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TwoTuple</span><span class="token punctuation">(</span>A a<span class="token punctuation">,</span> B b<span class="token punctuation">)</span><span class="token punctuation">{</span>       first <span class="token operator">=</span> a<span class="token punctuation">;</span>       second <span class="token operator">=</span> b<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreeTuple</span><span class="token operator">&lt;</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">TwoTuple</span><span class="token operator">&lt;</span>A<span class="token punctuation">,</span> B<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> C three<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreeTuple</span><span class="token punctuation">(</span>A a<span class="token punctuation">,</span> B b<span class="token punctuation">,</span> C c<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">super</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>       three <span class="token operator">=</span> c<span class="token punctuation">;</span>   <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元组测试  存放多个返回对象</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tupletest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> TwoTuple<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TwoTuple</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-2-泛型接口"><a href="#2-2-泛型接口" class="headerlink" title="2.2 泛型接口"></a>2.2 泛型接口</h5><pre class=" language-java"><code class="language-java">pulic <span class="token keyword">interface</span> <span class="token class-name">Gernerator</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>    T <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>参数化的接口确保next（）的返回值是参数的类型。</code></pre><h5 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h5><p>​        泛型方法使得方法独立于类而产生变化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GeneratorMethods</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token function">sout</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>​        使用泛型类时必须指明参数类型，而泛型方法不必指出， 编译器会进行类型参数推断。 类型参数判断若传入是基本类型，系统会自行进行打包处理。</p><p>​        类型判断只对赋值操作有效，若将泛型方法调用的结果作为参数进行传递，编译器不会类型推断。因为编译器认为：泛型方法调用后，其返回值被赋给了Object类型的变量。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>People<span class="token punctuation">,</span> List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Pet</span><span class="token operator">>></span> petPeople<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span>New<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​        显示进行说明 可以解决上述问题，即泛型显示说明</p><pre class=" language-java"><code class="language-java"><span class="token function">f</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>People<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Pet<span class="token operator">></span> petPeople<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span>New<span class="token punctuation">.</span>&lt;Person<span class="token punctuation">.</span>List<span class="token operator">&lt;</span>Pet<span class="token operator">>></span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​        静态方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">getSelf</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-4-泛型的限制"><a href="#2-4-泛型的限制" class="headerlink" title="2.4 泛型的限制"></a>2.4 泛型的限制</h5><ul><li>不能实例化类型变量</li></ul><pre class=" language-java"><code class="language-java">T objg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ERROR<span class="token comment" spellcheck="true">//可以利用反射进行</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenerateObj</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> T obj<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">GenerateObj</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">try</span><span class="token punctuation">{</span>       obj <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>           e<span class="token punctuation">.</span><span class="token function">printStackTrance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>test<span class="token operator">:</span>GenerateObj<span class="token operator">&lt;</span>String<span class="token operator">></span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenerateObj</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>不能实例化泛型数据</li></ul><pre class=" language-java"><code class="language-java">T<span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> ERROR<span class="token comment" spellcheck="true">//A.可以先创建Object类型的数组，然后获取时转换为T类型的数组。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenerateArray</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">GenerateArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">object</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> T o<span class="token punctuation">)</span><span class="token punctuation">{</span>       arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>   <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//B.利用反射机制</span><span class="token keyword">public</span> <span class="token function">generateArray</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    arr <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>不能在<strong>泛型类</strong>的静态上下文使用类型变量</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> T t<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//error</span>       <span class="token keyword">return</span> T<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>不能抛出或者捕获泛型类的实例</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Problem</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//error</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩展Throwable也是不合法的</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">try</span><span class="token punctuation">{</span>       <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//error</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//但在异常规范中使用泛型变量是允许的</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token keyword">throws</span> T<span class="token punctuation">{</span>       <span class="token keyword">try</span><span class="token punctuation">{</span>       <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Throwable realCause<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">throw</span> t<span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-5-类型变量的规定"><a href="#2-5-类型变量的规定" class="headerlink" title="2.5 类型变量的规定"></a>2.5 类型变量的规定</h5><p>​        <strong>java类库中，常用E表示集合的元素类型，K和V分别表示关键字和值的类型，T（U, S）表示任意类型。</strong></p><ul><li><p>被定义的泛型类作为接收方，也需要对传入的类型变量T的值做一定的限制和约束，如必须是某个超类的子类，或实现某个接口</p></li><li><p>对于实现接口，和继承某个父类。统一使用extends。</p></li><li><p>限定类型之间使用“&amp;”进行分割。</p></li><li><p>如果有类有接口，类名放于前，且至多有一个，接口不限</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span><span class="token operator">&amp;</span>Comparable<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li></ul><h5 id="2-6-泛型的继承关系"><a href="#2-6-泛型的继承关系" class="headerlink" title="2.6 泛型的继承关系"></a>2.6 泛型的继承关系</h5><ul><li>类名相同，但类型变量T不同的两个泛型类没有什么联系（即使Employee 是Manager的父类）。（ArrayList<manager> 和 ArrayList<employee>）</employee></manager></li><li>类型变量T相同，同是本来就是父子关系的两个类，作为泛型类依然保持继承关系。（ArrayList<employee> 和 List<employee>）</employee></employee></li><li>某个类的原始类型，和其对应的泛型类可以看做由“继承关系” (ArrayList 和ArrayList<employee>)</employee></li></ul><h5 id="2-7-统配符的使用"><a href="#2-7-统配符的使用" class="headerlink" title="2.7 统配符的使用"></a>2.7 统配符的使用</h5><ul><li><p>向上造型一个泛型对象的引用（上界通配符）</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Apple<span class="token operator">></span> apples <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Fruits</span><span class="token operator">></span> fruits <span class="token operator">=</span> apples<span class="token punctuation">;</span></code></pre><p>​        <strong>上界通配符，List&lt;? extends Fruits&gt; 是 List<fruits>和List<apple>的基类,一个能放水果以及一切都是水果派生类的盘子。</apple></fruits></strong></p></li><li><p><strong>下界通配符，Plate&lt;? super Fruit&gt; 是 Plate<fruit>的基类，但不是Plate<apple>的基类。一个能放水果以及一切是水果基类的盘子。Food 是 Fruits的基类。</apple></fruit></strong></p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Fruits<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>Fruit<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong><em>副作用：</em></strong></p><ul><li>上界不能存，只能外取。即&lt;? extends Fruits&gt; 会让set方法失效，但get方法还是有效的。</li><li>原因：编译器只知道容器内是Frutis或者它的子类，但不知道具体的类型，所以标上一个占位符，具体类不清楚，插入时，容器类不清楚是否与之匹配，所以就不允许。  并且读出来的东西，只能以父类进行接收。</li><li>T 代表同一类型，而? 代表不同类型。</li><li>下界不影响存，但只能以object进行接收。</li></ul></li></ul><h5 id="2-8-PECS-原则"><a href="#2-8-PECS-原则" class="headerlink" title="2.8 PECS 原则"></a>2.8 PECS 原则</h5><ul><li><p>频繁往外读取内容的，适合上界Extends。</p></li><li><p>经常往里插入的，适合用下界Super。</p></li><li><p>材料：</p><ul><li>Java是单继承，所有继承的类构成一棵树。假设A和B都在一颗继承树里（否则super，extend这些词没意义）。</li><li>A super B 表示A是B的父类或者祖先，在B的上面。</li><li>A extend B 表示A是B的子类或者子孙，在B下面。</li><li>由于树这个结构上下是不对称的，所以这两种表达区别很大。假设有两个泛型写在了函数定义里，作为函数形参（形参和实参有区别）：<ul><li>参数写成：T&lt;? super B&gt;，对于这个泛型，?代表容器里的元素类型，由于只规定了元素必须是B的超类，导致元素没有明确统一的“根”（除了Object这个必然的根），所以这个泛型你其实无法使用它，对吧，除了把元素强制转成Object。所以，对把参数写成这样形态的函数，你函数体内，只能对这个泛型做<strong>插入操作，而无法读</strong>。</li><li>参数写成： T&lt;? extends B&gt;，由于指定了B为所有元素的“根”，你任何时候都可以安全的用B来使用容器里的元素，但是插入有问题，由于供奉B为祖先的子树有很多，不同子树并不兼容，由于实参可能来自于任何一颗子树，所以你的插入很可能破坏函数实参，所以，对这种写法的形参，<strong>禁止做插入操作，只做读取</strong>。</li></ul></li></ul></li></ul><h5 id="2-9-泛型的命名规范"><a href="#2-9-泛型的命名规范" class="headerlink" title="2.9  泛型的命名规范"></a>2.9  泛型的命名规范</h5><ul><li><strong>E</strong>  :Element 常用在 java collection中，如List<e>,Iterator<e>.</e></e></li><li><strong>K, V</strong>: Key Value 代表Map的键值对</li><li><strong>N</strong>: number 数字</li><li><strong>T</strong> : type 类型</li><li><strong>S, U, V</strong> 和 <strong>T</strong>的用法一样</li></ul><h3 id="3-关于泛型的几点建议（Effective-Java）"><a href="#3-关于泛型的几点建议（Effective-Java）" class="headerlink" title="3.关于泛型的几点建议（Effective Java）"></a>3.关于泛型的几点建议（Effective Java）</h3><ul><li><p>第 23 条：请不要在新代码中使用原生类型</p><ul><li><p>如果使用原生类型，就失去了泛型在安全性和标书性方面的优势，所以尽可能的使用泛型参数，少使用原生类型。List 和List<object>  的区别在于前者逃避了泛型检查，后者则告知了编译器。如果使用List就会失去类型的安全性。所以能使用List<object> 就不使用List,并且List<string> 是 List的子类，但不是List<object>的子类。</object></string></object></object></p></li><li><p>在不确定或者不关心实际的参数的时候，就可以用一个问号代替</p></li><li><p>不要在代码中使用泛型的两个例外</p><ul><li>在类文字中必须使用原生态类型，规范不允许使用参数，List.class, String[].class  都是合法的，List&lt;String.class&gt;和 List&lt;?&gt;.class则不合法。</li><li>泛型信息在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用instance操作符是非法的。用无限制通配符类型替换原生类型，对instanceof操作符的行为不会产生任何影响</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token operator">&lt;</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Set</span><span class="token operator">></span><span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> m <span class="token operator">=</span> <span class="token punctuation">(</span>Set<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> o<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>第 24 条：消除非受检警告</p><ul><li>消除非受检警告，要尽可能的消除每一个非受检警告,每一个警告都有可能抛出ClassCastException异常，使用该注解，最好写上原因。</li><li>SuppressWarnings注解放在return语句是非法的，应该新建一个局部变量进行保存返回值</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"uncheck"</span><span class="token punctuation">)</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Arrays<span class="token punctuation">.</span><span class="token function">copeOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>第 25 条：列表优先于数组</p><ul><li>数组与泛型相比，是协变的，具体化的。 sub是super的子类型，则sub[] 就是super[]的子类型，但是泛型却是不行的。数组的错误会在运行时才抛出异常，而列表则会进行编译检查。</li><li>泛型在编译时强化它们的类型信息，在运行时丢弃或擦出元素类型信息。擦除就是使用泛型可以与没有使用泛型的代码随意互用</li><li>创建泛型、参数化类型或者类型参数的数组都是非法的。 非法的原因在于它不是类型安全的。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> 和 <span class="token keyword">new</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span>举例说明非法的原因：创建一个使用参数化类型List的数组List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> stringlist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>创建一个使用参数化类型的列表List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>由于数组是协变的，所以下面的是成立的。Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects <span class="token operator">=</span> stringList因而，就可以objects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> stringList<span class="token punctuation">;</span>但是下面的取值方式，看似是合理的，但是由于存入的是一个Integer参数画的List，所以会将Integer转换成String，这时就会抛出异常String s <span class="token operator">=</span> stringList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>第26条：优先考虑使用泛型</p></li></ul><pre class=" language-java"><code class="language-java">当在使用泛型类型时，进行转换的时候，<span class="token comment" spellcheck="true">//标量类型</span><span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>E result <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span>elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组类型</span><span class="token keyword">private</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>elements <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两种方式都可以，但当使用SuppressWarnings注解时</span><span class="token comment" spellcheck="true">//禁止数组类型的未受检转换比禁止标量类型的更加危险(2比1更加危险)。</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：Java8特性</title>
      <link href="/2018/11/18/java-java8-te-xing/"/>
      <url>/2018/11/18/java-java8-te-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Default-Method-for-Interfaces（接口的default方法）"><a href="#1-Default-Method-for-Interfaces（接口的default方法）" class="headerlink" title="1. Default Method for Interfaces（接口的default方法）"></a>1. Default Method for Interfaces（接口的default方法）</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Formula</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">calcute</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">double</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Formula formula <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Formula</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calcute</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>a <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>formula<span class="token punctuation">.</span><span class="token function">calcute</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>formula<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-Lambda-expression-集合排序"><a href="#2-Lambda-expression-集合排序" class="headerlink" title="2.Lambda expression(集合排序)"></a>2.Lambda expression(集合排序)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// #1</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>numList<span class="token punctuation">,</span> <span class="token punctuation">(</span>Integer a<span class="token punctuation">,</span> Integer b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// #2</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>numList<span class="token punctuation">,</span> <span class="token punctuation">(</span>Integer a<span class="token punctuation">,</span> Integer b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// #3</span>        numList<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>  b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>numList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="3-Functional-Intefaces-功能性接口的快速实现"><a href="#3-Functional-Intefaces-功能性接口的快速实现" class="headerlink" title="3.Functional Intefaces(功能性接口的快速实现)"></a>3.Functional Intefaces(功能性接口的快速实现)</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// #1</span>        Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> convert <span class="token operator">=</span> <span class="token punctuation">(</span>from <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// #2</span>        Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> convert <span class="token operator">=</span> Integer<span class="token operator">:</span><span class="token operator">:</span>valueof<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// #3</span>        Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> convert <span class="token operator">=</span> Something<span class="token operator">:</span><span class="token operator">:</span>startWith<span class="token punctuation">;</span>        Integer converted <span class="token operator">=</span> convert<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@FunctionalInterface</span>    <span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">{</span>        T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Something</span><span class="token punctuation">{</span>        String <span class="token function">startWith</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//构造函数的使用</span>    <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>        String name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">PersonFactory</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token operator">></span><span class="token punctuation">{</span>        T <span class="token function">create</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    PersonFactory factory <span class="token operator">=</span> Person<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">;</span>    Person person <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="4-Lambda-Scopes-使用范围"><a href="#4-Lambda-Scopes-使用范围" class="headerlink" title="4. Lambda Scopes(使用范围)"></a>4. Lambda Scopes(使用范围)</h4><h6 id="4-1-Accessing-local-variables-接受本地变量"><a href="#4-1-Accessing-local-variables-接受本地变量" class="headerlink" title="4.1 Accessing local variables(接受本地变量)"></a>4.1 Accessing local variables(接受本地变量)</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span>Converter<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> stringConverter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>stringConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="4-2-Accessing-fields-and-static-variables-属性和静态属性"><a href="#4-2-Accessing-fields-and-static-variables-属性和静态属性" class="headerlink" title="4.2 Accessing fields and static variables(属性和静态属性)"></a>4.2 Accessing fields and static variables(属性和静态属性)</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Lambda4</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> outerStaticNum<span class="token punctuation">;</span>    <span class="token keyword">int</span> outerNum<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">testScopes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        java8Study<span class="token punctuation">.</span>Converter<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> stringConverter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            outerNum <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        java8Study<span class="token punctuation">.</span>Converter<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> stringConverter1 <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            outerStaticNum <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="5-Built-in-Functional-Interfaces-内置功能接口"><a href="#5-Built-in-Functional-Interfaces-内置功能接口" class="headerlink" title="5. Built-in Functional Interfaces(内置功能接口)"></a>5. Built-in Functional Interfaces(内置功能接口)</h4><h6 id="5-1-Predicates-用于判断boolean值的接口"><a href="#5-1-Predicates-用于判断boolean值的接口" class="headerlink" title="5.1 Predicates(用于判断boolean值的接口)"></a>5.1 Predicates(用于判断boolean值的接口)</h6><pre class=" language-java"><code class="language-java">  Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>        Predicate<span class="token operator">&lt;</span>Object<span class="token operator">></span> nonNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>nonNull<span class="token punctuation">;</span>        Predicate<span class="token operator">&lt;</span>Object<span class="token operator">></span> isNull <span class="token operator">=</span> Objects <span class="token operator">:</span><span class="token operator">:</span>isNull<span class="token punctuation">;</span>        Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isEmpty <span class="token operator">=</span> String<span class="token operator">:</span><span class="token operator">:</span>isEmpty<span class="token punctuation">;</span>        Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isNotEmpty <span class="token operator">=</span> isEmpty<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> t1 <span class="token operator">=</span>  predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"job"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> t2 <span class="token operator">=</span> predicate<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"job"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String a <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> t3 <span class="token operator">=</span> nonNull<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> t4 <span class="token operator">=</span> isNull<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t1<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>t2<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>t3<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>t4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token boolean">true</span> <span class="token boolean">false</span> <span class="token boolean">false</span> <span class="token boolean">true</span></code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569555883604.png" alt="1569555883604"></p><h6 id="5-2-Functions-接受一个参数，返回一个结果"><a href="#5-2-Functions-接受一个参数，返回一个结果" class="headerlink" title="5.2 Functions(接受一个参数，返回一个结果)"></a>5.2 Functions(接受一个参数，返回一个结果)</h6><pre class=" language-java"><code class="language-java">    Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> toInteger <span class="token operator">=</span> Integer<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">;</span>    Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> backToString <span class="token operator">=</span> toInteger<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>backToString<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token number">123</span></code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569556224804.png" alt="1569556224804"></p><h6 id="5-3-Suppliers-产生指定类型结果-不接受参数"><a href="#5-3-Suppliers-产生指定类型结果-不接受参数" class="headerlink" title="5.3 Suppliers(产生指定类型结果,不接受参数)"></a>5.3 Suppliers(产生指定类型结果,不接受参数)</h6><pre class=" language-java"><code class="language-java">        Supplier<span class="token operator">&lt;</span>Person<span class="token operator">></span> personSupplier <span class="token operator">=</span> Person<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> personSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569556641067.png" alt="1569556641067"></p><h6 id="5-4-Consumers-指定对输入参数的处理动作"><a href="#5-4-Consumers-指定对输入参数的处理动作" class="headerlink" title="5.4 Consumers(指定对输入参数的处理动作)"></a>5.4 Consumers(指定对输入参数的处理动作)</h6><pre class=" language-java"><code class="language-java">Consumer<span class="token operator">&lt;</span>Person<span class="token operator">></span> greeter <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>greeter<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Lee"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="5-6-Comparators-比较器接口"><a href="#5-6-Comparators-比较器接口" class="headerlink" title="5.6 Comparators(比较器接口)"></a>5.6 Comparators(比较器接口)</h6><pre class=" language-java"><code class="language-java">Comparator<span class="token operator">&lt;</span>Person<span class="token operator">></span> comparator <span class="token operator">=</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        Person p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        comparator<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569557367186.png" alt="1569557367186"></p><h4 id="6-Optionals-防止空指针异常"><a href="#6-Optionals-防止空指针异常" class="headerlink" title="6.Optionals(防止空指针异常)"></a>6.Optionals(防止空指针异常)</h4><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> optional <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"bam"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>optional<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span>optional<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//"bam"</span>optional<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"fallback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//"bam"</span>optional<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">chartAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/2018/11/18/java-java8-te-xing/1569557923854.png" alt="1569557923854"></p><h4 id="7-Streams"><a href="#7-Streams" class="headerlink" title="7. Streams"></a>7. Streams</h4><h6 id="7-1-Filter-过滤器"><a href="#7-1-Filter-过滤器" class="headerlink" title="7.1 Filter(过滤器)"></a>7.1 Filter(过滤器)</h6><pre class=" language-java"><code class="language-java">stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="7-2-Sorted"><a href="#7-2-Sorted" class="headerlink" title="7.2 Sorted"></a>7.2 Sorted</h6><p>​        元素会自然排序，除非指定Comparator，并且只是流进行了排序，集合并不会被改变。</p><pre class=" language-java"><code class="language-java">stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="7-3-Map"><a href="#7-3-Map" class="headerlink" title="7.3 Map"></a>7.3 Map</h6><pre class=" language-java"><code class="language-java"> stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out <span class="token operator">:</span><span class="token operator">:</span> println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="7-4-Match"><a href="#7-4-Match" class="headerlink" title="7.4 Match"></a>7.4 Match</h6><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//是否存在以a开头的元素</span><span class="token keyword">boolean</span> anyStartWithA <span class="token operator">=</span>                stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//所有元素是否以a开头                    </span> <span class="token keyword">boolean</span> allStartWithA <span class="token operator">=</span>                stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//没有以Z开头的              </span>  <span class="token keyword">boolean</span> nonStartWithZ <span class="token operator">=</span>                stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="7-5-Count"><a href="#7-5-Count" class="headerlink" title="7.5 Count"></a>7.5 Count</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> startWithB <span class="token operator">=</span>                stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="7-6Reduce"><a href="#7-6Reduce" class="headerlink" title="7.6Reduce"></a>7.6Reduce</h6><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span>                stringCollection                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：JDK动态代理</title>
      <link href="/2018/11/10/java-jdk-dong-tai-dai-li/"/>
      <url>/2018/11/10/java-jdk-dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>  学习动态代理，可以先了解一下设计模式中的代理模式。<br>  <a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">设计模式–代理模式</a></p><h2 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2.JDK动态代理"></a>2.JDK动态代理</h2><p>  JDK生成类的过程中比较高效，其基于java内部的拦截器和反射机制实现的，应用的前提是目标类要基于统一的接口</p><h4 id="2-1-使用JDK动态代理的五大步骤："><a href="#2-1-使用JDK动态代理的五大步骤：" class="headerlink" title="2.1 使用JDK动态代理的五大步骤："></a>2.1 使用JDK动态代理的五大步骤：</h4><ul><li>实现InvocationHandler接口，重写自己的invoke方法。</li><li>通过Prxoy.getProxyClass获得代理类的Class</li><li>通过ProxyClazz.getConstructor获得代理类的构造函数</li><li>通过代理类的构造函数，将实现的InvocationHandler实例作为参数进行传递，获得代理类</li><li>代理类调用具体的函数方法</li></ul><p><strong><em>代码如下</em></strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//被代理类接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//被代理类实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is Jerry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"Jerry"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//InvocationJHandler的实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object target<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MyInvocationHandler</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"beforeExecute---"</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterExecute---"</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1.获取代理类的class</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">getProxyClass</span><span class="token punctuation">(</span>UserService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> UserService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2.获取代理类的构造函数</span>        Constructor constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>InvocationHandler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3.通过构造函数，拿到代理对象</span>        UserService userService  <span class="token operator">=</span> <span class="token punctuation">(</span>UserService<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//4.代理对象调用方法</span>        userService<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Proxy 提供了静态方法，可以一步获得代理类的执行结果，以上的几步可以整合为一个方法</span>        UserService userServiceProxy <span class="token operator">=</span> <span class="token punctuation">(</span>UserService<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>                UserService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>UserService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        userServiceProxy<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//执行结果</span>beforeExecute<span class="token operator">--</span><span class="token operator">-</span>getName<span class="token keyword">this</span> is JerryafterExecute<span class="token operator">--</span><span class="token operator">-</span>getNamebeforeExecute<span class="token operator">--</span><span class="token operator">-</span>getName<span class="token keyword">this</span> is JerryafterExecute<span class="token operator">--</span><span class="token operator">-</span>getName</code></pre><h4 id="2-2-补充整理："><a href="#2-2-补充整理：" class="headerlink" title="2.2 补充整理："></a>2.2 补充整理：</h4><p>  在动态代理中，InvocationHandler是核心，每一个代理实例都具有一个关联的调用处理程序，当代理对象生成后，还最后由InvocationHandler的invoke()方法调用目标方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：CGLIB</title>
      <link href="/2018/11/04/java-cglib/"/>
      <url>/2018/11/04/java-cglib/</url>
      
        <content type="html"><![CDATA[<h1 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h1><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>  CGLIB（Code Generator Library）是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。<br>  CGLIB的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。</p><h2 id="2-CGLIB-实例代码："><a href="#2-CGLIB-实例代码：" class="headerlink" title="2.CGLIB 实例代码："></a>2.CGLIB 实例代码：</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//被代理类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"Tom"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实现接口</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMethodInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------beforeExecute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object object <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------afterExecute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CglibTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyMethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User userProxy <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span>enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userProxy<span class="token punctuation">.</span><span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>beforeExecute<span class="token keyword">this</span> is Tom<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>afterExecute</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
